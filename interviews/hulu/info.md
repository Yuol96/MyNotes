# 面经算法题
## https://www.cnblogs.com/weixliu/p/3779288.html

### 对于数组A[0,1,2,3,4,...,k]，求得0<=i < j < k，且使得A[j] - A[i]为最大值。
类似于 LeetCode 121. Best Time to Buy and Sell Stock

### 对于递增的数组A[0,1,2,3,4,...,k]，数组B[0,1,2,3,4,...k']，对于0<=i<k,0<=j<k'，对于计算出的A[i]+B[j]，求其前k小个元素。
双指针法

### 实现带有重复元素的二分查找，如果查找的元素重复，返回重复元素的起始位置。
二分求`lowerBound()`, 详见[Search.java](./Search.java)

### LeetCode 222. Count Complete Tree Nodes

### 二叉搜索树的后序遍历(给定一个序列，判断该序列是否为二叉搜索树的后序遍历)
https://www.nowcoder.com/questionTerminal/a861533d45854474ac791d90e447bafd
```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length == 0) return false;
        return VerifySquenceOfBST(sequence, 0, sequence.length-1);
    }
    public boolean VerifySquenceOfBST(int [] sequence, int l, int r){
        if(l>=r) return true;
        int last = sequence[r];
        int i=l;
        while(i<r && sequence[i] < last) i++;
        if(i == r) return VerifySquenceOfBST(sequence, l, i-1);
        for(;i<r;i++)
            if(sequence[i] < last) return false;
        return VerifySquenceOfBST(sequence, l, i-1) && VerifySquenceOfBST(sequence, i, r);
    }
}
```

## https://www.1point3acres.com/bbs/thread-168076-1-1.html

### LeetCode 22. Generate Parentheses.
Backtracking

## https://www.acwing.com/blog/content/19/   ？？？？？？

### LeetCode 155. Min Stack

### 给出 n个整数和 m个操作，每个操作输入三个数 l,r,v，表示将区间 [l,r]中的每个数加上 v. 问最终数列中每个数是多少。
（Bool 加法器）

## https://max.book118.com/html/2018/0901/7131011061001145.shtm

### LeetCode 236. Lowest Common Ancestor of a Binary Tree

### 1-n n个数，去掉一个，如何快速知道缺失的数？ 
数学：`(1+n)*n/2`减去所有的数，O(n)时间, O(1)空间
异或：把所有书异或一遍，再异或1-n这n个数  O(n)时间, O(1)空间

### 如何判断一个数是2的幂

## https://blog.csdn.net/u011487593/article/details/47291199

### 有序数组转成一个平衡二叉搜索树

### 第一题是把一个字符串中的 `%20`都转成空格

### 第二题是按层打印一棵二叉树

### 第三题是找出两个有序数组里不同的数字（类似求集合的异或）

### LRU Cache

## 笔试 http://www.1010jiajiao.com/qx_portal/doc/1087717.html

## https://blog.csdn.net/likika2012/article/details/24377483

- [x] 给出因子为3，5，7至少一个的第k大的数
定义一个boolean数组，按照`寻找质数`的方法，把所有3,5,7的倍数找出来做标记，再从头数第k个

- [x] 题面是给定一个n\*n的二维数组， 数组条件， 二维数组的行是递增的， 列是递增的， 且整数都不重复， 然后给一个数判断这个数是不是在二维数组中

- [ ] 【数学题】两个人A，B仍硬币，A扔n次，B扔n+1次，A x次正面朝上，B y次正面朝上，问x>y的概率是多少 ？？？

- [ ] 【逻辑推理题】给100个白球，100个黑球混在一起，每次取两个，如果取出的颜色相同，就放回一个黑球，如果取出的颜色不同就放回一个白球，求最后剩黑球的概率。 ？？？
将黑球用0表示，白球用1表示，这样抽象出的模型就是100个0和100个1，两两异或，最后结果是0，说明最后剩下黑球的概率是1，我说了我的解法，似乎与面试官gg的解法不太一样，简单给了我他的想法，不过最后说恩，还可以，然后这题就过了。

- [x] 求绝对值最小的(最长连续子序列和)
	- [x] 求数组两两之差的绝对值最小的值

- [x] 两个有序的数组，如何找出两个数组合并后的第K大的数
双指针法是O(k)的时间  
二分查找O(logn): 两个有序数组可以得出min max，然后在这个范围内做二分查找。
具体而言，对每一数组都做二分查找，得到两个index i和j，
用`i+j+(i<nums1.length && nums1[i]==target)+(j<nums2.length && nums2[j]==target)`和k比较大小


## https://blog.csdn.net/wangyuquanliuli/article/details/9292195

- [ ] 【智力题】25匹马，有一条赛道，每次只能比较5匹马的快慢，没有计时工具，求问，要求出前三名最少需要比多少次？
- [x] 求出数组两两和为k的所有对，然后扩展求差为k的所有对，在扩展求三个数和为k的所有对
	- [x] 数组两两和为k的所有对: 排序后双指针从头和尾分别往中间走
	- [x] 求差为k的所有对: 排序后双指针都在头开始向尾走
	- [x] 扩展求三个数和为k的所有对 (15. 3Sum): 
		- 法一：jumping iteration + two sum 的 two pointers
		- 法二：jumping iteration + two sum 的 HashSet

- [ ] LeetCode 44 Wildcard Matching
- [ ] 有若干个圆，按半径大小排列好的，然后不会出现圆相交的情况，只有互斥和包涵，这些圆放在一个平面上，平面是白色的，白色上只能放黑色的圆，黑色圆上只能盖白色的圆，求最后黑色的圆的面积
- [ ] 给一段字符串，里面有代码和注释，求输出删去注释剩下的字符串

## https://blog.csdn.net/u011487593/article/details/47291285

- [x] 给定一个N位数，例如12345，从里面去掉k个数字，得到一个N-k位的数，例如去掉2，4，得到135，去掉1，5，得到234。设计算法，求出所有得到的N-k位数里面最小的那一个?
定义一个长度为N-k的array，成为R，用来存原数组的index。  
当决定R[i]的数值时，在nums[R[i-1]+1:k+i+1]中找到最小value的数字的index，存入R[i].  
可以用最小堆来优化上述操作
- [x] “找明星”，N个人中，只有一个明星：明星不认识其他所有的人，而其他人都认识明星，这些人中也可能相互认识。你每次只可以问一个人是否认识另一个人这样的问题，问最少问多少次可以找出明星。
	- 随便找两个人，问a是否认识b：
		- 如果a认识b，则a肯定不是明星
		- 如果a不认识b，则b肯定不是明星
		- 因此通过这种方式，每次问一个人肯定能排除一个人
	- 最多问N-1次就可以确认明星是谁
- [ ] 如果有两个明星呢？
- [x] 一个n\*n迷宫，方块里可能是墙，可能是路，问怎么走出出口，求最短路径。先说思路，然后写伪代码。很简单的宽度优先，每个方格里记录走的步数和来自于哪个方块。很快就解决了。
分析：宽度有限搜索问题，采用队列结构。


- [x] 21 Merge Two Sorted Lists
法一：递归
法二：iterative, 构造虚拟head

> 这个算法在哪种条件下不work， 想了许久，突然灵光一现，想出可能链表有环或者两个链表有可能有公共节点。

- [x] n\*n迷宫  
一个n\*n迷宫，方块里可能是墙，可能是路，问怎么走出出口，求最短路径。先说思
路，然后写伪代码。很简单的宽度优先，每个方格里记录走的步数和来自于哪个方块。
很快就解决了。

- [ ] N个数选两个求和
N个数，选出任意两个数求和，问所有这些可能性的和是多少。我说最简单的方法是
模拟，O(N^2)，然后问有没有更简单的，想了想，计算了下所有数出现的个数是 （N-1
）/2，所以很简单，就是   sum\*（N-1）/2，时间复杂度是O（N）

- [x] 两个有序数组各选一个数使得求和为m
A B两个有序数组，A中选一个，
B中选一个，要求和为某个指定值m，问怎么选。感觉是《编程之美》上一维数组中求两
个数和的变形，所以只要变换一下：A中的数从头往尾走，B中数从尾往前走就好；但是
这么会遗漏，如果没找到，用相同的方式，A中的数从尾往头走，B中的数从头往尾走，
看能否找到

- [x] 怎么确定有环链表？如果两个链表有公共节点，问怎么去找这个公共节点？

- [x] 已知两个矩形的四个节点信息，然后给一个API——可以得到某个点在是否在某矩形
内，问怎么判断矩形相交。
答：找到两个矩形中较小的那个，判断较小矩形的四个顶点是否在大矩形内部

- [ ] 问一个n\*n的方块内，有一条环形路径。路径上的点都是1，其他点都是0.。给路径中
的任意一个点，问这个路径所包含的面积。想了一分钟，觉得粉两步走：1）深度优先找
路径 2）宽度优先算面积 然后解释了下，说可行  ？？？

## https://blog.csdn.net/u011487593/article/details/47291441

- [x] LeetCode 343. Integer Break
- [ ] AOE关键路径
- [x] 3、二元树前序、中序求后序
- [x] LeetCode 415. Add Strings

## https://blog.csdn.net/u011487593/article/details/47292089

- [ ] 最后一个是捡石子的问题，单堆和双堆的都问了

## https://blog.csdn.net/max_kibble/article/details/80599454

- [ ] 给定一个整数数组a，分别求出满足下列条件的子串数量：1）子串[l, r]中的最大值为a[r]；2）子串[l, r]中的最小值为a[l]，最大值为a[r]   注意是子串不是子序列，第一问要求O(n)的时间复杂度，第二问要求O(n\*lgn)

## https://www.cnblogs.com/yejinru/p/3464464.html

- [x] 给你一个完全二叉树，求其中满足BST条件的最大的子树
- [x] 如何用二分写整数开根号，嗯，你没有听错 int范围内的非高精度的开根号 LeetCode 69. Sqrt(x)
	- [ ] 如何实现double型小数的开根号，精确到小数点后指定位数（多少位是由一个整数给出）
	这个问题容易犯得是这么几个错误，一个是精确位数为负数时如何让这个数还有意义，一个是在被开方数小于1的时候二分初始上下界如何确定。再一个争取做到如果二分时恰好碰到相等时，最好直接返回，使答案更精确。
- [ ] LeetCode Majority Element的扩展
有一个数组，已知其中有一个数的出现次数超出了总次数的一半，以O（1）的附加空间求出这个数，然后面试官让我证明方法的正确性，这个真是有一种方法在嘴边却说不出的感觉，卡了好久，面试官给了一个比较直观还严谨的证明。可以把找这个数的过程当成是这样的，扫描整个数组，一旦发现有两个不相同的数那么就把这两个数绑在一起扔掉，最后剩下的数中一定是出现次数超过一半的数。然后问了个推广，有长度为n的数组，一直有数出现次数超出n/3求所有满足这个条件的数，解法就是用相似的方法，扫描数组，一旦发现三个互不相同的数，那么就把他们绑在一起扔掉，最后会剩一个或两个数，那么再重新扫描一遍，对这两个数进行计数，产生结果。
- [x] 链表的快排
- [ ] 几个杨氏矩阵相关的问题. 杨氏矩阵就是一个矩阵，其中元素满足每行从左到右递增，每列从上到下递增。
	- [x] 如何在这里查找一个数。
	- [x] 如何对杨氏矩阵中元素进行排序
		- k路归并，参考LeetCode 378. Kth Smallest Element in a Sorted Matrix，维护一个最小堆
	- [ ] 给一个数组，如何根据这个数组构造出杨氏矩阵。
	- [ ] 对于一个杨氏矩阵，如果把其中的一个元素用最小值替代，如何用最少的时间维护杨氏矩阵的性质。
	我给了一个和堆的下沉操作比较相似的方法，最小值元素只能向下或者向右走，走的方向就是相邻元素值较小的那个方向，然后把对应的相邻元素与最小值元素交换，之后继续走，最多走O（m+n）步。