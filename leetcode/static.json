{"text": "**My Java Solutions for LeetCode problems**  \n\n**If you are interested in [my Python Solutions](https://github.com/Yuol96/leetcode-notes), please visit [this repo](https://github.com/Yuol96/leetcode-notes) of mine.**\n\n[TOC]\n# Top Hits\n\n## Top Interview Questions\n\n### 136. Single Number\n- [Link](https://leetcode.com/problems/single-number/)\n- Tags: Bit Manipulation\n- Stars: 1\n\n#### XOR\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int temp = 0;\n        for(int num: nums){\n            temp ^= num;\n        }\n        return temp;\n    }\n}\n```\n\n### 283. Move Zeroes\n- [Link](https://leetcode.com/problems/move-zeroes/)\n- Tags: Array, Two pointers\n- Stars: 2\n\n#### Insertion Sort\nTime: O(n^2)\nSpace: O(1)\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        for(int i=1; i<nums.length; i++){\n            int curr = i;\n            while(curr > 0 && nums[curr-1] == 0){\n                int temp = nums[curr];\n                nums[curr] = nums[curr-1];\n                nums[curr-1] = temp;\n                curr--;\n            }\n        }\n    }\n}\n```\n\n#### Slow-Fast two pointers\nWe only need to care about non-zero elements and fill the remaining array with zeros!\n\nTime: O(n)\nSpace: O(1)\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int i=0, j=0;\n        for(;j<nums.length;j++){\n            if(nums[j]!=0){\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        while(i<nums.length){\n            nums[i] = 0;\n            i++;\n        }\n    }\n}\n```\n\n### 206. Reverse Linked List\n- [Link](https://leetcode.com/problems/reverse-linked-list/)\n- Tags: Linked List\n- Stars: 1\n\n#### Iterative\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode curr = null;\n        while(head != null){\n            ListNode p = head.next;\n            head.next = curr;\n            curr = head;\n            head = p;\n        }\n        return curr;\n    }\n}\n```\n\n#### Recursive\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newHead;\n    }\n}\n```\n\n### 371. Sum of Two Integers\n- [Link](https://leetcode.com/problems/sum-of-two-integers/)\n- Tags: Bit Manipulation\n- Stars: 2\n\n#### \u884c\u6ce2\u8fdb\u4f4d\u52a0\u6cd5\u5668\n```java\nclass Solution {\n    public int getSum(int a, int b) {\n        int c = 0;\n        int result = 0;\n        for(int i=0; i<32; i++){\n            int pos = (1<<i);\n            int m = (a&pos), n = (b&pos);\n            int g = (m&n), p = (m|n);\n            result |= (m^n^c);\n            c = (g | (p & c)) << 1;\n        }\n        return result;\n    }\n}\n```\n\n#### recursive \u884c\u6ce2\u8fdb\u4f4d\u52a0\u6cd5\u5668\n```java\nclass Solution {\n    public int getSum(int a, int b) {\n        if(b==0)\n            return a;\n        return getSum((a^b), (a&b)<<1);\n    }\n}\n```\n\n### 169. Majority Element\n- [Link](https://leetcode.com/problems/majority-element/)\n- Tags: Array, Divide and Conquer, Bit Manipulation\n- Stars: 2\n\n#### Heavy Guardian (Moore Voting)\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int result = nums[0], count = 0;\n        for(int num : nums){\n            if(num == result) count++;\n            else {\n                count--;\n                if(count <= 0) {\n                    count = 1;\n                    result = num;\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n#### Divide and Conquer\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        return recurr(nums, 0, nums.length-1);\n    }\n    \n    private int recurr(int[] nums, int l, int r) {\n        if(l==r){\n            return nums[l];\n        }\n        int mid = l + ((r-l)>>1);\n        int a = recurr(nums, l, mid), b = recurr(nums, mid+1, r);\n        if(a==b){\n            return a;\n        }\n        return count(nums, l, r, a) > count(nums, l, r, b) ? a : b;\n    }\n    \n    private int count(int[] nums, int l, int r, int target){\n        int n = 0;\n        for(int i=l; i<=r; i++){\n            if(target == nums[i])\n                n++;\n        }\n        return n;\n    }\n}\n```\n\n#### binary search\nAttention that you `r-l` might overflow, so you have to use long integer.\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        // iterate to get max and min element\n        long l=nums[0], r=nums[0];\n        for(int num : nums){\n            if(l > num) l = num;\n            if(r < num) r = num;\n        }\n        // binary search by value\n        while(l<r){\n            int mid = (int)(l+((r-l)>>1));\n            int count = getLTECount(nums, mid);\n            if(count > (nums.length>>1)) r = mid;\n            else l = mid+1;\n        }\n        return (int)l;\n    }\n    private int getLTECount(int[] nums, int target){\n        int count = 0;\n        for(int num : nums)\n            if(num <= target) count++;\n        return count;\n    }\n}\n```\n\n#### Bit Manipulation\nmajority\u7684\u6bcf\u4e00bit\u90fd\u5e94\u8be5\u662fmajority\uff01\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int result = 0;\n        for(int i=0, mask=1; i<32; i++, mask<<=1){\n            int bitCount = 0;\n            for(int j=0; j<nums.length; j++){\n                if((nums[j]&mask)!=0) bitCount++;\n                if(bitCount>nums.length/2) {\n                    result |= mask;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\nOther Sub-optimal methods: Hash Table, Sorting (must appear at n/2 position), Randomization (random pick one and check if it is majority) \n\n#### Quick Selection to find the median\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int k = ((nums.length-1)>>1);\n        int l=0, r=nums.length-1;\n        while(l<r){\n            int j = partition(nums, l, r);\n            if(j == k) return nums[k];\n            else if(j>k) r = j-1;\n            else l = j+1;\n        }\n        return nums[k];\n    }\n    private int partition(int[] nums, int l, int r){\n        int i=l, j=r+1;\n        while(true){\n            while(nums[++i] < nums[l] && i<r);\n            while(nums[l] < nums[--j] && j>l);\n            if(i>=j) break;\n            swap(nums, i, j);\n        }\n        swap(nums, l, j);\n        return j;\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n### 242. Valid Anagram\n- [Link](https://leetcode.com/problems/valid-anagram/)\n- Tags: Hash Table, Sort\n- Stars: 1\n\n#### alphabet counting\n1. You don't need 2 alphabet!\n2. Arrays automatically got initialized with zero values!\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        int[] alphabet = new int[26];\n        for(int i=0; i<s.length(); i++) alphabet[s.charAt(i)-'a']++;\n        for(int i=0; i<t.length(); i++) alphabet[t.charAt(i)-'a']--;\n        for(int num : alphabet) if(num!=0) return false;\n        return true;\n    }\n}\n```\n\n### 268. Missing Number\n- [Link](https://leetcode.com/problems/missing-number/)\n- Tags: Array, Math, Bit Manipulation\n- Stars: 2\n\n#### sum (math)\nThis method might overflow when we have large amount of large numbers in `nums`!\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int sum = ((n*(n+1))>>1);\n        for(int num: nums)\n            sum -= num;\n        return sum;\n    }\n}\n```\n\n#### XOR with both index and array element\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int result = nums.length;\n        for(int i=0; i<nums.length; i++){\n            result ^= (i ^ nums[i]);\n        }\n        return result;\n    }\n}\n```\n\n#### swap sort\nGiven a num in `nums`, one can easily know the postion that this num is supposed to be in. \n\nO(n) sort:  \n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int last = -1;\n        for(int i=0; i<nums.length; i++){\n            while(nums[i] != i){\n                if(nums[i] == -1) break;\n                if(nums[i] == nums.length){\n                    last = nums[i];\n                    nums[i] = -1;\n                }\n                else swap(nums, i, nums[i]);\n            }\n        }\n        for(int i=0; i<nums.length; i++){\n            if(i != nums[i]) return i;\n        }\n        return nums.length;\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n### 121. Best Time to Buy and Sell Stock\n- [Link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n- Tags: Array, Dynamic Programming\n- Stars: 2\n\n#### my original solution 20190201\n\u4e0d\u9700\u8981\u6570\u7ec4\uff0c\u4fdd\u5b58\u5f53\u524d\u7684maxProfit\u548cminPrice\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices == null || prices.length == 0)\n            return 0;\n        int minPrice = prices[0];\n        int maxProfit = 0;\n        for(int i=1; i<prices.length; i++){\n            if(minPrice > prices[i])\n                minPrice = prices[i];\n            maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n        }\n        return maxProfit;\n    }\n}\n```\n\n#### DP\nmax subarray problem, using Kadane's Algorithm.\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0)\n            return 0;\n        int[] dp = new int[prices.length];\n        // dp[i] means maxProfit we can get in the contiguous subarray ended up with prices[i]\n        for(int i=1; i<prices.length; i++){\n            dp[i] = Math.max(0, dp[i-1] + prices[i] - prices[i-1]);\n        }\n        int maxProfit = 0;\n        for(int i=0; i<dp.length; i++)\n            if(maxProfit < dp[i])\n                maxProfit = dp[i];\n        return maxProfit;\n    }\n}\n```\nThe space of the algorithm above can be further optimized:\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0)\n            return 0;\n        int maxProfit = 0, dp = 0;\n        for(int i=1; i<prices.length; i++){\n            dp = Math.max(0, dp + prices[i] - prices[i-1]);\n            maxProfit = Math.max(maxProfit, dp);\n        }\n        return maxProfit;\n    }\n}\n```\nNotice that we only care about differences of the prices array.\n\n### 21. Merge Two Sorted Lists\n- [Link](https://leetcode.com/problems/merge-two-sorted-lists/)\n- Tags: Linked List\n- Stars: 1\n\n#### iterative (my soluton)\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode root = new ListNode(0), curr = root;\n        while(l1 != null && l2 != null){\n            if(l1.val < l2.val){\n                curr.next = l1;\n                l1 = l1.next;\n            }\n            else {\n                curr.next = l2;\n                l2 = l2.next;\n            }\n            curr = curr.next;\n        }\n        curr.next = l1!=null ? l1 : l2;\n        return root.next;\n    }\n}\n```\n\n#### recursive \n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1 == null) return l2;\n        if(l2 == null) return l1;\n        ListNode root;\n        if(l1.val < l2.val){\n            root = l1;\n            root.next = mergeTwoLists(l1.next, l2);\n        }\n        else {\n            root = l2;\n            root.next = mergeTwoLists(l1, l2.next);\n        }\n        return root;\n    }\n}\n```\n\n### 202. Happy Number\n- [Link](https://leetcode.com/problems/happy-number/)\n- Tags: Hash Table, Math\n- Stars: 2\n\n#### HashSet\n```java\nclass Solution {\n    public boolean isHappy(int n) {\n        HashSet<Integer> st = new HashSet<Integer>();\n        while(!st.contains(n)){\n            if(n == 1)\n                return true;\n            st.add(n);\n            String str = Integer.toString(n);\n            n = 0;\n            for(int i=0; i<str.length(); i++){\n                int a = str.charAt(i) - '0';\n                n += a*a;\n            }\n        }\n        return false;\n    }\n}\n```\n\n#### Floyd Cycle detection algorithm\nThe best video to learn about Floyd Cycle detection : [https://www.youtube.com/watch?v=LUm2ABqAs1w](https://www.youtube.com/watch?v=LUm2ABqAs1w)\n\n```java\nclass Solution {\n    public boolean isHappy(int n) {\n        int slow=n, fast=n;\n        do {\n            slow = digitsSquareSum(slow);\n            fast = digitsSquareSum(fast);\n            fast = digitsSquareSum(fast);\n        }\n        while(slow != fast);\n        if(slow == 1) return true;\n        return false;\n    }\n    \n    private int digitsSquareSum(int n){\n        int result = 0;\n        while(n>0){\n            int digit = (n%10);\n            result += digit * digit;\n            n /= 10;\n        }\n        return result;\n    }\n}\n```\n\n### 326. Power of Three\n- [Link](https://leetcode.com/problems/power-of-three/)\n- Tags: Math\n- Stars: 3\n\n#### Math\n```java\nclass Solution {\n    public boolean isPowerOfThree(int n) {\n        // 1162261467 = 3**19 < 2**31-1 < 3**20\n        return (n>0 && 1162261467%n == 0);\n    }\n}\n```\n\n#### binary search\n```java\nclass Solution {\n    public boolean isPowerOfThree(int n) {\n        int l=0, r=19;\n        while(l<=r){\n            int mid = l + ((r-l)>>1);\n            int power = (int)Math.pow(3, mid);\n            if(power == n) return true;\n            else if(power > n) r = mid-1;\n            else l = mid+1;\n        }\n        return false;\n    }\n}\n```\n\n### 198. House Robber\n- [Link](https://leetcode.com/problems/house-robber/)\n- Tags: Dynamic Programming\n- Stars: 1\n\n#### DP iterative memo\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        for(int i=1; i<nums.length; i++){\n            dp[i] = nums[i];\n            if(i-2>=0) dp[i] += dp[i-2];\n            if(i-3>=0) dp[i] = Math.max(dp[i], dp[i-3]+nums[i]);\n        }\n        int result = dp[nums.length-1];\n        if(nums.length-2 >=0 && dp[nums.length-2] > result) result = dp[nums.length-2];\n        return result;\n        // dp[i] = Math.max(dp[i-2]+nums[i], dp[i-3]+nums[i]);\n    }\n}\n```\n\n#### DP iterative + 2 variables\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0)\n            return 0;\n        if(nums.length == 1)\n            return nums[0];\n        int a = nums[0], b = nums[1];\n        if(nums.length == 2)\n            return Math.max(a, b);\n        int c = a + nums[2];\n        for(int i=3; i<nums.length; i++){\n            int temp = Math.max(a+nums[i], b+nums[i]);\n            a = b;\n            b = c;\n            c = temp;\n        }\n        return Math.max(b, c);\n    }\n}\n```\n\n#### DP recursive\n```java\nclass Solution {\n    private HashMap<Integer, Integer> map;\n    public Solution() {\n        map = new HashMap<Integer, Integer>();\n    }\n    public int rob(int[] nums) {\n        return rob(nums, nums.length-1);\n    }\n    public int rob(int[] nums, int i){\n        if(i < 0)\n            return 0;\n        if(i == 0)\n            return nums[0];\n        if(i == 1)\n            return Math.max(nums[0], nums[1]);\n        if(map.containsKey(i))\n            return map.get(i);\n        map.put(i, Math.max(rob(nums, i-1), rob(nums, i-2) + nums[i]));\n        return map.get(i);\n    }\n}\n```\n\n### 213. House Robber II\n- [Link](https://leetcode.com/problems/house-robber-ii/)\n- Tags: Dynamic Programming\n- Stars: 1\n\n#### 2 pass House Robber I\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n        return Math.max(rob(nums, 0, nums.length-1), rob(nums, 1, nums.length));\n    }\n    public int rob(int[] nums, int start, int end){\n        if(start >= end) return 0;\n        int[] dp = new int[end-start];\n        dp[0] = nums[start];\n        for(int i=start+1; i<end; i++){\n            dp[i-start] = nums[i];\n            if(i-2>=start) dp[i-start]+=dp[i-2-start];\n            if(i-3>=start) dp[i-start] = Math.max(dp[i-start], dp[i-3-start]+nums[i]);\n        }\n        int result = dp[end-1-start];\n        if(end-2>=start) result = Math.max(result, dp[end-2-start]);\n        return result;\n    }\n}\n```\n\n### 337. House Robber III\n- [Link](https://leetcode.com/problems/house-robber-iii/)\n- Tags: Tree, DFS\n- Stars: 3\n\n#### DFS\n```java\nclass Solution {\n    public int rob(TreeNode root) {\n        return rob(root, false);\n    }\n    public int rob(TreeNode root, boolean parentRobbed){\n        if(root == null) return 0;\n        if(parentRobbed) return rob(root.left, false) + rob(root.right, false);\n        return Math.max(rob(root.left, false) + rob(root.right, false), \n                        rob(root.left, true) + rob(root.right, true) + root.val);\n    }\n}\n```\n\n#### DFS optimized (memo)\n```java\nclass Solution {\n    public int rob(TreeNode root) {\n        Tuple tup = DFS(root);\n        return Math.max(tup.robRoot, tup.notRobRoot);\n    }\n    private Tuple DFS(TreeNode root) {\n        if(root == null) return new Tuple(0,0);\n        Tuple l = DFS(root.left);\n        Tuple r = DFS(root.right);\n        int robRoot = root.val + l.notRobRoot + r.notRobRoot;\n        int notRobRoot = Math.max(l.notRobRoot + r.notRobRoot, \n                                  Math.max(l.notRobRoot + r.robRoot, \n                                           Math.max(l.robRoot + r.notRobRoot, \n                                                    l.robRoot + r.robRoot)));\n        return new Tuple(robRoot, notRobRoot);\n    }\n}\npublic class Tuple {\n    int robRoot, notRobRoot;\n    Tuple(int a, int b){\n        robRoot = a;\n        notRobRoot = b;\n    }\n}\n```\n\n### 66. Plus One\n- [Link](https://leetcode.com/problems/plus-one/)\n- Tags: Array, Math\n- Stars: 1\n\n#### \u6570\u7ec4\u521d\u59cb\u5316\n\u6ce8\u610f\uff1a\u9ed8\u8ba4\u521d\u59cb\u5316\uff0c\u6570\u7ec4\u5143\u7d20\u76f8\u5f53\u4e8e\u5bf9\u8c61\u7684\u6210\u5458\u53d8\u91cf\uff0c\u9ed8\u8ba4\u503c\u8ddf\u6210\u5458\u53d8\u91cf\u7684\u89c4\u5219\u4e00\u6837\u3002**\u6570\u5b570**\uff0c\u5e03\u5c14false\uff0cchar\\u0000\uff0c\u5f15\u7528\uff1anull\n\n\u672c\u9898\u4e0d\u9002\u5408\u628a`Arrays.asList()`\u8f6c\u5316\u4e3aList, `.asList`\u65b9\u6cd5\u4e0d\u9002\u7528\u4e8e\u57fa\u672c\u6570\u636e\u7c7b\u578b\uff08byte, short, int, long, float, double, boolean\uff09\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        for(int i=digits.length-1; i>=0; i--){\n            if(digits[i]<9){\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        int[] ret = new int[digits.length+1];\n        ret[0] = 1;\n        return ret;\n    }\n}\n```\n\n### 172. Factorial Trailing Zeroes\n- [Link](https://leetcode.com/problems/factorial-trailing-zeroes/)\n- Tags: Math\n- Stars: 3\n\n#### Increment (Time Limit Exceeded)\nTime: O(n)\n```java\nclass Solution {\n    public int trailingZeroes(int n) {\n        int count = 0;\n        for(int i=1; i<=n; i++){\n            int temp = i;\n            while(temp%5 == 0 && temp>0){\n                count++;\n                temp /= 5;\n            }\n        }\n        return count;\n    }\n}\n```\n\n#### Recursive\n1\\*2\\*3 --multiply by three 5-> 1\\*2\\*3\\*4\\***5**\\*6\\*7\\*8\\*9\\***10**\\*11\\*12\\*13\\*14\\***15**\n\nTime: O(logn)\n```java\nclass Solution {\n    public int trailingZeroes(int n) {\n        if(n<5)\n            return 0;\n        return trailingZeroes(n/5) + n/5;\n    }\n}\n```\n\n#### Iterative\nSimilar to the Recursive method\n```java\nclass Solution {\n    public int trailingZeroes(int n) {\n        int count = 0;\n        while(n>4){\n            n /= 5;\n            count += n;\n        }\n        return count;\n    }\n}\n```\n\n### 155. Min Stack\n- [Link](https://leetcode.com/problems/min-stack/)\n- Tags: Stack, Design\n- Stars: 2\n\n#### Use two stacks\nStore series of minValue into another stack to obtain O(1) time!\n```java\nclass MinStack {\n    Stack<Integer> minst, numst;\n\n    public MinStack() {\n        minst = new Stack<Integer>();\n        numst = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        numst.push(x);\n        if(minst.empty()) minst.push(x);\n        else{\n            minst.push(Math.min(minst.peek(), x));\n        }\n    }\n    \n    public void pop() {\n        minst.pop();\n        numst.pop();\n    }\n    \n    public int top() {\n        return numst.peek();\n    }\n    \n    public int getMin() {\n        return minst.peek();\n    }\n}\n```\n\n#### only use one Stack\n1. Use only one stack by storing the gap between min value and current value in it. \n2. Since we store differences of integers, we need to convert it into `Long`. \n```java\nclass MinStack {\n    long min;\n    Stack<Long> st;\n\n    public MinStack() {\n        st = new Stack<Long>();\n        min = Integer.MAX_VALUE;\n    }\n    \n    public void push(int x) {\n        st.push(x-min);\n        if(x<min)\n            min = x;\n    }\n    \n    public void pop() {\n        long temp = st.pop();\n        if(temp<0)\n            min -= temp;\n    }\n    \n    public int top() {\n        long temp = st.peek();\n        if(temp<0)\n            return (int)min;\n        return (int)(temp + min);\n    }\n    \n    public int getMin() {\n        return (int)min;\n    }\n}\n```\n\n\n### 234. Palindrome Linked List\n- [Link](https://leetcode.com/problems/palindrome-linked-list/)\n- Tags: Linked List, Two Pointers\n- Stars: 1\n\n#### halve and reverse\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if(head == null) return true;\n        \n        int count = countListNode(head);\n        ListNode mid = moveToMid(head, count);\n        if(count%2==0){\n            ListNode temp = mid.next;\n            mid.next = null;\n            mid = temp;\n        }\n        ListNode reverse = getReversedList(mid);\n        while(reverse!=null && head!=null){\n            if(reverse.val != head.val)\n                return false;\n            reverse = reverse.next;\n            head = head.next;\n        }\n        return true;\n    }\n    private int countListNode(ListNode head){\n        int count = 0;\n        while(head!=null){\n            count++;\n            head = head.next;\n        }\n        return count;\n    }\n    private ListNode moveToMid(ListNode head, int count){\n        ListNode p = head;\n        for(int i=0; i<count/2-1; i++){\n            p = p.next;\n        }\n        if(count%2==1) p = p.next;\n        return p;\n    }\n    private ListNode getReversedList(ListNode head){\n        ListNode newhead = null;\n        while(head!=null){\n            ListNode temp = head.next;\n            head.next = newhead;\n            newhead = head;\n            head = temp;\n        }\n        return newhead;\n    }\n}\n```\n\n### 14. Longest Common Prefix\n- [Link](https://leetcode.com/problems/longest-common-prefix/)\n- Tags: String\n- Stars: 1\n\n#### compare chars in each position\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0) return \"\";\n        int count = 0, minLen = Integer.MAX_VALUE;\n        for(String s: strs)\n            if(minLen>s.length())\n                minLen = s.length();\n        while(count<minLen){\n            char c = strs[0].charAt(count);\n            for(int i=1; i<strs.length; i++){\n                if(strs[i].charAt(count)!=c)\n                    return strs[0].substring(0, count);\n            }\n            count++;\n        }\n        return strs[0].substring(0, count);\n    }\n}\n```\n#### String.indexOf\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs == null || strs.length == 0)    return \"\";\n        String pre = strs[0];\n        int i = 1;\n        while(i < strs.length){\n            while(strs[i].indexOf(pre) != 0)\n                pre = pre.substring(0,pre.length()-1);\n            i++;\n        }\n        return pre;\n    }\n}\n```\n#### sort and compare the first and last String\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs == null || strs.length == 0)    return \"\";\n        Arrays.sort(strs);\n        int count = 0;\n        String a=strs[0], b=strs[strs.length-1];\n        for(int i=0; i<a.length(); i++){\n            if(b.length()>i && b.charAt(i)==a.charAt(i))\n                count++;\n            else\n                return a.substring(0, count);\n        }\n        return a.substring(0, count);\n    }\n}\n```\n\n### 160. Intersection of Two Linked Lists\n- [Link](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n- Tags: Linked List\n- Stars: 1\n\n#### turning into a loop\nWe don't need to know the length of each lists. We just want to ensure that two pointers reach the intersection point at the same time. \n\nNotice that `a` and `b` will eventually be `null` if the two linked lists have no intersection. Therefore, we have no need to worry about infinite loop problem. \n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA, b = headB;\n        while(a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n\n#### get lengths and eliminate differences\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = getLen(headA), lenB = getLen(headB);\n        while(lenA>lenB){\n            headA = headA.next;\n            lenA--;\n        }\n        while(lenB>lenA){\n            headB = headB.next;\n            lenB--;\n        }\n        while(headA!=headB){\n            headA = headA.next;\n            headB = headB.next;\n        }\n        return headA;\n    }\n    private int getLen(ListNode head){\n        int count = 0;\n        ListNode p = head;\n        while(p!=null){\n            p = p.next;\n            count++;\n        }\n        return count;\n    }\n}\n```\n\n### 28. Implement strStr()\n- [Link](https://leetcode.com/problems/implement-strstr/)\n- Tags: Two Pointers, String\n- Stars: 2\n\n#### KMP\n[\u539f\u7406\u8bb2\u89e3(\u5ffd\u7565\u4ee3\u7801\u90e8\u5206)](https://m.toutiaocdn.com/group/6578243698759303688/?iid=59744622620&app=news_article&timestamp=1549524948&group_id=6578243698759303688&tt_from=copy_link&utm_source=copy_link&utm_medium=toutiao_ios&utm_campaign=client_share)\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int[] next = getNextArray(needle);\n        int i=0, j=0;\n        while(j<needle.length() && i<haystack.length()){\n            while(haystack.charAt(i)!=needle.charAt(j) && j>0){\n                j = next[j];\n            }\n            if(haystack.charAt(i)==needle.charAt(j))\n                j++;\n            i++;\n        }\n        if(j==needle.length())\n            return i-needle.length();\n        return -1;\n    }\n    private int[] getNextArray(String s){\n        int[] next = new int[s.length()];\n        for(int i=2; i<s.length(); i++){\n            int maxCommonLen = next[i-1];\n            while(maxCommonLen>0 && s.charAt(i-1) != s.charAt(maxCommonLen)){\n                maxCommonLen = next[maxCommonLen];\n            }\n            if(s.charAt(i-1) == s.charAt(maxCommonLen))\n                next[i] = maxCommonLen+1;\n        }\n        return next;\n    }\n}\n```\n\n### 190. Reverse Bits\n- [Link](https://leetcode.com/problems/reverse-bits/)\n- Tags: Bit Manipulation\n- Stars: 1\n\n#### move bit one by one\n```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int result = 0;\n        for(int i=0; i<32; i++){\n            result |= ((n&1)<<(31-i));\n            n = n>>>1;\n        }\n        return result;\n    }\n}\n```\n\n#### divide and conquer\n```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        n = (n>>>16) | (n<<16);\n        n = ((n&0xFF00FF00)>>>8) | ((n&0x00FF00FF)<<8);\n        n = ((n&0xF0F0F0F0)>>>4) | ((n&0x0F0F0F0F)<<4);\n        n = ((n&0xCCCCCCCC)>>>2) | ((n&0x33333333)<<2);\n        n = ((n&0xAAAAAAAA)>>>1) | ((n&0x55555555)<<1);\n        return n;\n    }\n}\n```\n\n### 189. Rotate Array\n- [Link](https://leetcode.com/problems/rotate-array/)\n- Tags: Array\n- Stars: 1\n\n#### rotate partially\nAttention that `k` needs to be reduced to [0, nums.length).\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        rotate(nums, 0, nums.length-k-1);\n        rotate(nums, nums.length-k, nums.length-1);\n        rotate(nums, 0, nums.length-1);\n    }\n    private void rotate(int[] nums, int l, int r){\n        while(l<r)\n            swap(nums, l++, r--);\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n### 238. Product of Array Except Self\n- [Link](https://leetcode.com/problems/product-of-array-except-self/)\n- Tags: Array\n- Stars: 1\n\n#### Use only one array\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] left = new int[nums.length];\n        // int[] right = new int[nums.length];\n        left[0] = 1;\n        for(int i=1; i<nums.length; i++)\n            left[i] = left[i-1]*nums[i-1];\n        // right[nums.length-1] = 1;\n        int right = 1;\n        for(int i=nums.length-2; i>=0; i--){\n            // right[i] = right[i+1]*nums[i+1];\n            right *= nums[i+1];\n            left[i] *= right;\n        }\n        // for(int i=0; i<nums.length; i++)\n        //     left[i] *= right[i];\n        return left;\n    }\n}\n```\n\n### 347. Top K Frequent Elements\n- [Link](https://leetcode.com/problems/top-k-frequent-elements/)\n- Tags: Hash Table, Heap\n- Stars: 1\n\n#### HashMap\n```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int num: nums)\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        HashMap<Integer, List<Integer>> freq2list = new HashMap<Integer, List<Integer>>();\n        for(int num: map.keySet()){\n            int freq = map.get(num);\n            if(freq2list.get(freq)==null)\n                freq2list.put(freq, new ArrayList<Integer>());\n            freq2list.get(freq).add(num);\n        }\n        List<Integer> result = new ArrayList<Integer>();\n        for(int i=nums.length; i>=1 && k>0; i--){\n            if(freq2list.containsKey(i)){\n                result.addAll(freq2list.get(i));\n                k -= freq2list.get(i).size();\n            }\n        }\n        return result;\n    }\n}\n```\n\n#### maxHeap and Map.Entry\n```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int num: nums)\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        PriorityQueue<Map.Entry<Integer, Integer>> maxHeap = new PriorityQueue<>((a,b)->(b.getValue()-a.getValue()));\n        for(Map.Entry<Integer, Integer> entry: map.entrySet()){\n            maxHeap.add(entry);\n        }\n        List<Integer> result = new ArrayList<Integer>();\n        while(k>0){\n            result.add(maxHeap.poll().getKey());\n            k--;\n        }\n        return result;\n    }\n}\n```\n\n#### TreeMap\n```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int num: nums)\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        TreeMap<Integer, List<Integer>> freq2list = new TreeMap<>();\n        for(int num: map.keySet()){\n            int freq = map.get(num);\n            if(freq2list.get(freq) == null)\n                freq2list.put(freq, new ArrayList<Integer>());\n            freq2list.get(freq).add(num);\n        }\n        List<Integer> result = new ArrayList<Integer>();\n        while(k>0){\n            Map.Entry<Integer, List<Integer>> entry = freq2list.pollLastEntry();\n            result.addAll(entry.getValue());\n            k -= entry.getValue().size();\n        }\n        return result;\n    }\n}\n```\n\n### 384. Shuffle an Array\n- [Link](https://leetcode.com/problems/shuffle-an-array/)\n- Tags: Design\n- Stars: 1\n\n#### swap step by step\n```java\nclass Solution {\n    private int[] arr;\n    public Solution(int[] nums) {\n        arr = nums;\n    }\n    /** Resets the array to its original configuration and return it. */\n    public int[] reset() {\n        return arr;\n    }\n    /** Returns a random shuffling of the array. */\n    public int[] shuffle() {\n        if(arr==null) return null;\n        int[] newArr = arr.clone();\n        Random rand = new Random();\n        for(int i=newArr.length-1; i>=1; i--){\n            int randpos = rand.nextInt(i+1);\n            swap(newArr, i, randpos);\n        }\n        return newArr;\n    }\n    private static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n### 378. Kth Smallest Element in a Sorted Matrix\n- [Link](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n- Tags: Binary Search, Heap\n- Stars: 3\n\n#### Max Heap\n```java\npublic class Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        PriorityQueue<Tuple> qu = new PriorityQueue<>();\n        for(int i=0; i<n; i++){\n            qu.add(new Tuple(0, i, matrix[0][i]));\n        }\n        Tuple temp = qu.peek();\n        for(int i=0; i<k; i++){\n            temp = qu.poll();\n            if(temp.row < n-1)\n                qu.add(new Tuple(temp.row+1, temp.col, matrix[temp.row+1][temp.col]));\n        }\n        return temp.val;\n    }\n}\nclass Tuple implements Comparable<Tuple> {\n    int row, col, val;\n    public Tuple(int x, int y, int v){\n        row = x; col = y; val = v;\n    }\n    @Override\n    public int compareTo(Tuple o){\n        return this.val - o.val;\n    }\n}\n```\n\n\n#### Binary Search\n<span id=\"378-binary-search\"></span>\n1. Attention: when `count == k`, `mid` might not exists in `matrix`, so we need to get the largest element that is less than or equal to `mid` in `matrix`. Therefore, we have `getMaxlte`.\n2. There's a situation that might break the while loop, i.e., there are more than one elements that have the same value as the kth smallest. When this happens, r will goes below l, and it breaks the while loop. Therefore, we need to return `l` instead of an arbitrary number outside the while loop. \n3. The whole picture of this algorithm:\n> The key point for any binary search is to figure out the \"Search Space\". For me, I think there are two kind of \"Search Space\" -- index and range(the range from the smallest number to the biggest number). Most usually, when the array is sorted in one direction, we can use index as \"search space\", when the array is unsorted and we are going to find a specific number, we can use \"range\". \n\nSimilar to [287. Find the Duplicate Number](#287-binary-search).\n\n```java\nclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        int l = matrix[0][0], r = matrix[n-1][n-1];\n        while(l<=r){\n            int mid = l + ((r-l)>>1);\n            int count = countlte(matrix, mid);\n            if(count == k)\n                return getMaxlte(matrix, mid);\n            else if(count > k)\n                r = mid - 1;\n            else \n                l = mid + 1;\n        }\n        return l;\n    }\n    private int countlte(int[][] matrix, int target){\n        int n = matrix.length, count = 0;\n        for(int[] row: matrix){\n            int j = n;\n            while(j>0 && row[j-1] > target)\n                j--;\n            count += j;\n        }\n        return count;\n    }\n    private int getMaxlte(int[][] matrix, int target){\n        int maxVal = Integer.MIN_VALUE;\n        int n = matrix.length;\n        for(int[] row: matrix)\n            for(int ele: row)\n                if(ele <= target && maxVal < ele)\n                    maxVal = ele;\n        return maxVal;\n    }\n    \n}\n```\n\n### 287. Find the Duplicate Number\n- [Link](https://leetcode.com/problems/find-the-duplicate-number/)\n- Tags: Array, Two Pointers, Binary Search\n- Stars: 3\n\n#### Binary Search\n<span id=\"287-binary-search\"></span>\nSimilar to [378. Kth Smallest Element in a Sorted Matrix](#378-binary-search)\n```java\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int n = nums.length - 1;\n        int l = 1, r = n;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            int count = countLTE(nums, mid);\n            if(count > mid)\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n    private int countLTE(int[] nums, int target){\n        int count = 0;\n        for(int num: nums)\n            if(num <= target)\n                count++;\n        return count;\n    }\n}\n```\n\n\n#### slow-fast two pointers\n<span id=\"287-two-pointers\"></span>\nSimilar to [142. Linked List Cycle II](#142-two-pointers)\n```java\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = 0, fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        }\n        while(slow!=fast);\n        fast = 0;\n        while(slow != fast){\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return slow;\n    }\n}\n```\n\n### 142. Linked List Cycle II\n- [Link](https://leetcode.com/problems/linked-list-cycle-ii/)\n- Tags: Linked List, Two Pointers\n- Stars: 2\n\n\n#### slow-fast two pointers\n<span id=\"142-two-pointers\"></span>\nSimilar to [287. Find the Duplicate Number](#287-two-pointers)\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode slow = head, fast = head;\n        do{\n            if(fast.next == null || fast.next.next == null)\n                return null;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        while(slow != fast);\n        fast = head;\n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```\n\n### 328. Odd Even Linked List\n- [Link](https://leetcode.com/problems/odd-even-linked-list/)\n- Tags: Linked List\n- Stars: 1\n\n#### two heads\n```java\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if(head == null) return null;\n        ListNode curr = head, odd = head, even = head.next;\n        while(curr.next != null){\n            ListNode temp = curr.next;\n            curr.next = temp.next;\n            curr = temp;\n        }\n        curr = odd;\n        while(curr.next != null)\n            curr = curr.next;\n        curr.next = even;\n        return odd;\n    }\n}\n```\n\n### 102. Binary Tree Level Order Traversal\n- [Link](https://leetcode.com/problems/binary-tree-level-order-traversal/)\n- Tags: Tree, BFS\n- Stars: 1\n\n\n#### BFS\n<span id=\"102-BFS\"></span>\nSimilar to [103. Binary Tree Zigzag Level Order Traversal](#103-BFS)\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        Queue<TreeNode> qu = new LinkedList<>();\n        qu.add(root);\n        List<Integer> row = new ArrayList<>();\n        int count = 1;\n        while(!qu.isEmpty()){\n            TreeNode temp = qu.poll();\n            if(temp.left != null)\n                qu.add(temp.left);\n            if(temp.right != null)\n                qu.add(temp.right);\n            row.add(temp.val);\n            count--;\n            if(count == 0){\n                count = qu.size();\n                result.add(row);\n                row = new ArrayList<>();\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 341. Flatten Nested List Iterator\n- [Link](https://leetcode.com/problems/flatten-nested-list-iterator/)\n- Tags: Stack, Design\n- Stars: 2\n\n#### not real iterator\n```java\npublic class NestedIterator implements Iterator<Integer> {\n    Stack<NestedInteger> st;\n    public NestedIterator(List<NestedInteger> nestedList) {\n        st = new Stack<>();\n        for(int i=nestedList.size()-1; i>=0; i--)\n            st.push(nestedList.get(i));\n    }\n    @Override\n    public Integer next() {\n        if(!hasNext()) return null;\n        return st.pop().getInteger();\n    }\n    @Override\n    public boolean hasNext() {\n        while(!st.empty()){\n            NestedInteger curr = st.peek();\n            if(curr.isInteger()){\n                return true;\n            }\n            else{\n                st.pop();\n                List<NestedInteger> list = curr.getList();\n                for(int i=list.size()-1; i>=0; i--)\n                    st.push(list.get(i));\n            }\n        }\n        return false;\n    }\n}\n```\n\n#### real iterator\n```java\npublic class NestedIterator implements Iterator<Integer> {\n    Stack<ListIterator<NestedInteger>> st;\n    public NestedIterator(List<NestedInteger> nestedList) {\n        st = new Stack<>();\n        st.push(nestedList.listIterator());\n    }\n    @Override\n    public Integer next() {\n        if(!hasNext()) return null;\n        return st.peek().next().getInteger();\n    }\n    @Override\n    public boolean hasNext() {\n        while(!st.empty()){\n            if(!st.peek().hasNext()){\n                st.pop();\n            }\n            else{\n                NestedInteger curr = st.peek().next();\n                if(curr.isInteger()) {\n                    st.peek().previous();\n                    return true;\n                }\n                st.push(curr.getList().listIterator());\n            }\n        }\n        return false;\n    }\n}\n```\n\n### 48. Rotate Image\n- [Link](https://leetcode.com/problems/rotate-image/)\n- Tags: Array\n- Stars: 1\n\n#### Onion\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        // rotate(matrix, 0, matrix.length-1);\n        for(int i=0, j=matrix.length-1; i<j; i++, j--){\n            rotate(matrix, i, j);\n        }\n    }\n    private void rotate(int[][] matrix, int min, int max){\n        if(min >= max) return ;\n        int len = max-min;\n        for(int i=0; i<len; i++){\n            int temp = matrix[min][min+i];\n            matrix[min][min+i] = matrix[max-i][min];\n            matrix[max-i][min] = matrix[max][max-i];\n            matrix[max][max-i] = matrix[min+i][max];\n            matrix[min+i][max] = temp;\n        }\n        // rotate(matrix, min+1, max-1);\n    }\n}\n```\n\n#### swap\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        reverse(matrix);\n        int n = matrix.length;\n        for(int i=0; i<n; i++)\n            for(int j=i+1; j<n; j++)\n                diagSwap(matrix, i, j);\n    }\n    private void reverse(int[][] matrix){\n        int l=0, r=matrix.length-1;\n        while(l<r)\n            swap(matrix, l++, r--);\n    }\n    private void swap(int[][] matrix, int i, int j){\n        int[] temp = matrix[i];\n        matrix[i] = matrix[j];\n        matrix[j] = temp;\n    }\n    private void diagSwap(int[][] matrix, int i, int j){\n        int temp = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = temp;\n    }\n}\n```\n\n### 62. Unique Paths\n- [Link](https://leetcode.com/problems/unique-paths/)\n- Tags: Array, Dynamic Programming\n- Stars: 2\n\n#### DP\nThis is a space-optimized DP solution. `dp[i][j] = dp[i-1][j] + dp[i][j-1]`\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] dp = new int[m];\n        Arrays.fill(dp, 1);\n        for(int i=1; i<n; i++)\n            for(int j=1; j<m; j++) \n                dp[j] += dp[j-1];\n        return dp[dp.length-1];\n    }\n}\n```\n\n#### Math\nThis is a tricky solution. By observing the DP matrix,\n```\n1   1   1   1\n1   2   3   4\n1   3   6   10\n1   4   10  20\n1   5   15  35\n1   6   21  56\n```\nwe can see a Pascal's triangle in the diagonal direction.\nTherefore, we have formula `$C_{m+n-2}^{m-1}$` for the final result.\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        m--; n--;\n        int min = Math.min(m, n);\n        if(min == 0) return 1;\n        long a = factorial(m+n, m+n-min+1);\n        long b = factorial(min, 1);\n        return (int)(a/b);\n    }\n    private long factorial(int max, int min){\n        long result = (long)min;\n        for(int i=min+1; i<=max; i++)\n            result *= i;\n        return result;\n    }\n}\n```\n\n### 215. Kth Largest Element in an Array\n- [Link](https://leetcode.com/problems/kth-largest-element-in-an-array/)\n- Tags: Divide and Conquer, Heap\n- Stars: 4\n\n#### Quick Selection\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int l = 0, r = nums.length-1;\n        while(l<r){\n            int idx = partition(nums, l, r);\n            if(idx+1 == k) return nums[idx];\n            else if(idx+1 > k) r = idx-1; //\n            else l = idx+1; // how can this line deal with duplicates??\n        }\n        return nums[k-1];\n    }\n    private int partition(int[] nums, int l, int r){\n        int i=l, j=r+1;\n        while(true){\n            while(nums[++i] > nums[l] && i<r);\n            while(nums[l] > nums[--j] && j>l);\n            if(i>=j) break;\n            swap(nums, i, j);\n        }\n        swap(nums, l, j); //  It's j!! not i!!\n        return j;  //  It's j!! not i!!\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n### 49. Group Anagrams\n- [Link](https://leetcode.com/problems/group-anagrams/)\n- Tags: Hash Table, Sting\n- Stars: 1\n\n#### Encoding String into Integer by primes\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<Integer, List<String>> map = new HashMap<>();\n        // int[] primes = getPrimes();\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\n        for(String s: strs){\n            int num = getNum(primes, s);\n            if(!map.containsKey(num))\n                map.put(num, new ArrayList<>());\n            map.get(num).add(s);\n        }\n        List<List<String>> result = new ArrayList<>();\n        for(List<String> list : map.values()){\n            result.add(list);\n        }\n        return result;\n    }\n    // private int[] getPrimes(){\n    //     int[] primes = new int[26];\n    //     int k=0;\n    //     int N = 102;\n    //     boolean[] isPrime = new boolean[N];\n    //     for(int i=2; i<N; i++)\n    //         isPrime[i] = true;\n    //     for(int i=2; i<N; i++){\n    //         if(isPrime[i]){\n    //             primes[k++] = i;\n    //             if(k==26)  return primes;\n    //             for(int j=i+i; j<N; j+=i)\n    //                 isPrime[j] = false;\n    //         }\n    //     }\n    //     return null;\n    // }\n    private int getNum(int[] primes, String s){\n        int result = 1;\n        for(int i=0; i<s.length(); i++)\n            result *= primes[s.charAt(i)-'a'];\n        return result;\n    }\n}\n```\n\n#### Hashable Array\n1. When implementing `HashArray.equals()`, the parameter `o` must be of type `Object`!!\n2. Pay attention to the usage of `map.computeIfAbsent` and its return value. \n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<HashArray, List<String>> map = new HashMap<>();\n        for(String s: strs){\n            HashArray ha = new HashArray(s);\n            map.computeIfAbsent(ha, key->new ArrayList<>()).add(s);\n        }\n        List<List<String>> result = new ArrayList<>();\n        for(List<String> list: map.values())\n            result.add(list);\n        return result;\n    }\n}\nclass HashArray {\n    int[] arr = new int[26];\n    public HashArray(String s){\n        for(char c: s.toCharArray())\n            arr[c-'a']++;\n    }\n    public boolean equals(Object o) {\n        return Arrays.equals(this.arr, ((HashArray)o).arr);\n    }\n    public int hashCode(){\n        return Arrays.hashCode(arr);\n    }\n}\n```\n\n### 289. Game of Life\n- [Link](https://leetcode.com/problems/game-of-life/)\n- Tags: Array\n- Stars: 1\n\n#### Encoding all possible states\nThe key idea is to encode all 4 possible transitions:  \n    live -> live,  1  \n    live -> dead,  -1  \n    dead -> live,  2  \n    dead -> dead.  0  \n\nIn this way, we can calculate `num = (Math.abs(board[i][j])&1)`\n```java\nclass Solution {\n    public void gameOfLife(int[][] board) {\n        for(int i=0; i<board.length; i++)\n            for(int j=0; j<board[0].length; j++){\n                int num = countCells(board, i, j);\n                if(board[i][j] == 1)\n                    if(num<2 || num>3) \n                        board[i][j] = -1;\n                else\n                    if(num == 3)\n                        board[i][j] = 2;\n            }\n        for(int i=0; i<board.length; i++)\n            for(int j=0; j<board[0].length; j++){\n                if(board[i][j] == -1) board[i][j] = 0;\n                if(board[i][j] == 2) board[i][j] = 1;\n            }\n    }\n    private int countCells(int[][] board,int x,int y){\n        int count = 0;\n        for(int i=x-1; i<=x+1; i++)\n            for(int j=y-1; j<=y+1; j++){\n                if(i==x && j==y) continue;\n                if(i>=0 && j>=0 && i<board.length && j<board[0].length){\n                    count += (Math.abs(board[i][j])&1);\n                }\n            }\n        return count;\n    }\n}\n```\n\n### 11. Container With Most Water\n- [Link](https://leetcode.com/problems/container-with-most-water/)\n- Tags: Array, Two Pointers\n- Stars: 3\n\n#### Not My Solution\n[Here is an awesome explanation!](https://leetcode.com/problems/container-with-most-water/discuss/6099/Yet-another-way-to-see-what-happens-in-the-O(n)-algorithm)\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int l = 0, r = height.length-1;\n        int area = Integer.MIN_VALUE;\n        while(l<r){\n            area = Math.max(area, Math.min(height[l], height[r])*(r-l));\n            if(height[l] < height[r]) l++;\n            else r--;\n        }\n        return area;\n    }\n}\n```\n\n### 380. Insert Delete GetRandom O(1)\n- [Link](https://leetcode.com/problems/insert-delete-getrandom-o1/)\n- Tags: Array, Hash Table, Design\n- Stars: 3\n\n#### Tomb\n```java\nclass RandomizedSet {\n    HashMap<Integer, Integer> map;\n    List<Integer> list;\n    Random rand;\n    /** Initialize your data structure here. */\n    public RandomizedSet() {\n        rand = new Random();\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    public boolean insert(int val) {\n        if(map.containsKey(val)) \n            return false;\n        map.put(val, list.size());\n        list.add(val);\n        return true;\n    }\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    public boolean remove(int val) {\n        if(!map.containsKey(val)) \n            return false;\n        int idx = map.get(val);\n        list.set(idx, null);\n        map.remove(val);\n        if(map.size() <= list.size()/2){\n            map = new HashMap<>();\n            List<Integer> newList = new ArrayList<>();\n            for(int i=0; i<list.size(); i++){\n                Integer num = list.get(i);\n                if(num != null){\n                    map.put(num, newList.size());\n                    newList.add(num);\n                }\n            }\n            list = newList;\n        }\n        return true;\n    }\n    /** Get a random element from the set. */\n    public int getRandom() {\n        while(true){\n            int idx = rand.nextInt(list.size());\n            Integer num = list.get(idx);\n            if(num!=null) return num;\n        }\n    }\n}\n```\n\n#### swap\n```java\nclass RandomizedSet {\n    HashMap<Integer, Integer> map;\n    List<Integer> list;\n    Random rand;\n    /** Initialize your data structure here. */\n    public RandomizedSet() {\n        rand = new Random();\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    public boolean insert(int val) {\n        if(map.containsKey(val)) \n            return false;\n        map.put(val, list.size());\n        list.add(val);\n        return true;\n    }\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    public boolean remove(int val) {\n        if(!map.containsKey(val))  return false;\n        int idx = map.get(val);\n        if(idx < list.size()-1){\n            int lastone = list.get(list.size()-1);\n            map.put(lastone, idx);\n            list.set(idx, lastone);\n        }\n        list.remove(list.size()-1);\n        map.remove(val);\n        return true;\n    }\n    /** Get a random element from the set. */\n    public int getRandom() {\n        return list.get(rand.nextInt(list.size()));\n    }\n}\n```\n\n### 36. Valid Sudoku\n- [Link](https://leetcode.com/problems/valid-sudoku/)\n- Tags: Hash Table\n- Stars: 3\n\n#### Encoding by self-defined Class\ntype == 0 --> row  \ntype == 1 --> col  \ntype == 2 --> 3x3 block  \n```java\nclass Solution {\n    public boolean isValidSudoku(char[][] board) {\n        HashSet<Tuple> st = new HashSet<>(3*81);\n        for(int i=0; i<9; i++)\n            for(int j=0; j<9; j++)\n                if(board[i][j] != '.'){\n                    char c = board[i][j];\n                    if(!st.add(new Tuple(0, i, c)) ||\n                       !st.add(new Tuple(1, j, c)) ||\n                       !st.add(new Tuple(2, i/3, j/3 ,c)))\n                        return false;\n                }\n        return true;\n    }\n}\nclass Tuple {\n    int type, i, j;\n    char c;\n    public Tuple(int t, int k, char ch){\n        this(t, k, k, ch);\n    }\n    public Tuple(int t, int x, int y, char ch){\n        c = ch;\n        type = t;\n        i = x;\n        j = y;\n    }\n    public boolean equals(Object o){\n        Tuple obj = (Tuple) o;\n        if(this.type != obj.type || this.c!=obj.c) return false;\n        if(type == 0) return this.i==obj.i;\n        if(type == 1) return this.j==obj.j;\n        else return this.i==obj.i && this.j==obj.j;\n    }\n    public int hashCode(){\n        return (Integer.hashCode(type) +\n            Integer.hashCode(i) +\n            Integer.hashCode(j) +\n            Integer.hashCode(c));\n    }\n}\n```\n\n#### Encoding by native String\n\"r%d%c\" --> row  \n\"c%d%c\" --> col  \n\"b%d%d%c\" --> 3x3 block  \n```java\nclass Solution {\n    public boolean isValidSudoku(char[][] board) {\n        HashSet<String> st = new HashSet<>();\n        for(int i=0; i<9; i++)\n            for(int j=0; j<9; j++)\n                if(board[i][j] != '.'){\n                    char ch = board[i][j];\n                    if(!st.add(\"r\"+i+ch) || \n                       !st.add(\"c\"+j+ch) || \n                       !st.add(\"b\"+i/3+j/3+ch))\n                        return false;\n                }\n        return true;\n    }\n}\n```\n\n### 75. Sort Colors\n- [Link](https://leetcode.com/problems/sort-colors/)\n- Tags: Array, Two Pointers, Sort\n- Stars: 1\n\n#### one pass solution\ntwo pointers\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int curr=0, i=0, j=nums.length-1;\n        while(curr<=j){\n            if(nums[curr] == 2) swap(nums, curr, j--);\n            else if(nums[curr] == 1) curr++;\n            else swap(nums, curr++, i++);\n        }\n    }\n    private void swap(int[] nums, int i, int j){\n        if(nums[i] != nums[j]){\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n    }\n}\n```\n\n#### two pass solution\nCount\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int zeros=0, ones=0, twos=0;\n        for(int num: nums){\n            if(num==0) zeros++;\n            else if(num==1) ones++;\n            else twos++;\n        }\n        int i=0;\n        while(zeros-->0) nums[i++]=0;\n        while(ones-->0) nums[i++]=1;\n        while(twos-->0) nums[i++]=2;\n    }\n}\n```\n\n### 162. Find Peak Element\n- [Link](https://leetcode.com/problems/find-peak-element/)\n- Tags: Array, Binary Search\n- Stars: 1\n\n#### Binary Search differences of adjacent elements\n```java\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(goesUp(nums, nums.length-1)) return nums.length-1;\n        int l=0, r=nums.length-1;\n        while(true){\n            int mid = l + ((r-l)>>1);\n            if(goesUp(nums, mid)) l = mid;\n            else r = mid;\n            if(l + 1 >= r) break;\n        }\n        return l;\n    }\n    private boolean goesUp(int[] nums, int idx){\n        if(idx == 0) return true;\n        return nums[idx]>nums[idx-1];\n    }\n}\n```\n\n#### binary search too\n```java\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        if(nums.length == 1) return 0;\n        // if(nums[0]>nums[1]) return 0;\n        if(nums[nums.length-1] > nums[nums.length-2]) return nums.length-1;\n        int l=0, r=nums.length-1;\n        while(l<r){\n            int mid = l+((r-l)>>1);\n            // if(nums[mid]>nums[mid-1]) l = mid;\n            // else r = mid-1;\n            if(nums[mid]>nums[mid+1]) r = mid;\n            else l = mid+1;\n        }\n        return l;\n    }\n}\n```\n\n### 103. Binary Tree Zigzag Level Order Traversal\n- [Link](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)\n- Tags: Stack, Tree, BFS\n- Stars: 1\n\n#### BFS\n<span id=\"103-BFS\"></span>\nSimilar to [102. Binary Tree Level Order Traversal](#102-BFS)\n```java\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        Queue<TreeNode> qu = new LinkedList<>();\n        qu.add(root);\n        int count = 1;\n        List<Integer> list = new ArrayList<>();\n        while(!qu.isEmpty()){\n            TreeNode temp = qu.poll();\n            count--;\n            if(temp.left != null) qu.add(temp.left);\n            if(temp.right != null) qu.add(temp.right);\n            list.add(temp.val);\n            if(count == 0){\n                count = qu.size();\n                result.add(list);\n                list = new ArrayList<>();\n            }\n        }\n        for(int i=1; i<result.size(); i+=2)\n            reverse(result.get(i));\n        return result;\n    }\n    private void reverse(List<Integer> list){\n        int i=0, j=list.size()-1;\n        while(i<j)\n            Collections.swap(list, i++, j--);\n    }\n}\n```\n\n### 279. Perfect Squares\n- [Link](https://leetcode.com/problems/perfect-squares/)\n- Tags: Math, Dynamic Programming, BFS\n- Stars: 2\n\n#### static DP 298ms\n```java\nclass Solution {\n    int maxSq;\n    HashMap<Integer,Integer> map;\n    public int numSquares(int n) {\n        maxSq = getSquares(n);\n        map = new HashMap<>();\n        return getNumSquares(n);\n    }\n    private int getNumSquares(int n){\n        if(n<=0) return 0;\n        if(map.containsKey(n)) return map.get(n);\n        int min = Integer.MAX_VALUE;\n        for(int i=1; i<=maxSq; i++){\n            int sq = i*i;\n            if(sq>n) break;\n            min = Math.min(min, 1 + getNumSquares(n-sq));\n        }\n        map.put(n, min);\n        return min;\n    }\n    private int getSquares(int n){\n        int l=1, r=46340;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            int sq = mid*mid;\n            if(sq == n) return mid;\n            else if(sq > n) r = mid;\n            else l = mid+1;\n        }\n        return l;\n    }\n}\n```\n\n#### DP 25ms\n<span id=\"279-DP\" />\n\nSimilar to [322. Coin Change](#322-DP)\n```java\nclass Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n+1];\n        for(int i=2; i<n+1; i++) dp[i] = Integer.MAX_VALUE;\n        dp[1] = 1;\n        for(int i=2; i<=n; i++){\n            for(int j=1; j*j<=i; j++){\n                dp[i] = Math.min(dp[i], 1+dp[i-j*j]);\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n#### BFS 87ms\n```java\nclass Solution {\n    public int numSquares(int n) {\n        Queue<Integer> qu = new LinkedList<>();\n        qu.add(n);\n        int count = 1, level = 0;\n        while(!qu.isEmpty()){\n            int curr = qu.poll();\n            count--;\n            if(curr == 0) return level;\n            for(int i=1; i*i<=curr; i++){\n                int val = curr-i*i;\n                if(val == 0) return level+1;\n                qu.add(val);\n            }\n            if(count == 0){\n                count = qu.size();\n                level++;\n            }\n        }\n        return 0;\n    }\n}\n```\n\n### 322. Coin Change\n- [Link](https://leetcode.com/problems/coin-change/)\n- Tags: Dynamic Programming\n- Stars: 2\n\n#### DP\n<span id=\"322-DP\" />\n\nSimilar to [279. Perfect Squares](#279-DP)\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(amount == 0) return 0;\n        if(coins.length == 0) return -1;\n        int[] dp = new int[amount+1];\n        Arrays.fill(dp, -1);\n        Arrays.sort(coins);\n        dp[0] = 0;\n        for(int i=0; i<=amount; i++){\n            for(int coin : coins){\n                if(coin > i) break;\n                if(dp[i-coin] == -1) continue;\n                dp[i] = dp[i] == -1 ? dp[i-coin]+1 : Math.min(dp[i], dp[i-coin]+1);\n            }\n        }\n        return dp[amount];\n    }\n}\n```\n\n#### still DP, but init with a self-defined maxVal instead of -1\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(amount == 0) return 0;\n        if(coins.length == 0) return -1;\n        int[] dp = new int[amount+1];\n        int maxVal = amount+1;\n        Arrays.fill(dp, maxVal);\n        Arrays.sort(coins);\n        dp[0] = 0;\n        for(int i=0; i<=amount; i++){\n            for(int coin : coins){\n                if(coin > i) break;\n                dp[i] = Math.min(dp[i], dp[i-coin]+1);\n            }\n        }\n        return dp[amount] == maxVal ? -1 : dp[amount];\n    }\n}\n```\n\n### 240. Search a 2D Matrix II\n- [Link](https://leetcode.com/problems/search-a-2d-matrix-ii/)\n- Tags: Binary Search, Divide and Conquer\n- Stars: 1\n\n#### BST\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if(matrix.length == 0 || matrix[0].length==0) return false;\n        int m = matrix.length, n = matrix[0].length;\n        int i=0, j=n-1;\n        while(i<m && j>=0){\n            if(matrix[i][j] == target) return true;\n            else if(matrix[i][j] < target) i++;\n            else j--;\n        }\n        return false;\n    }\n}\n```\n\n### 300. Longest Increasing Subsequence\n- [Link](https://leetcode.com/problems/longest-increasing-subsequence/)\n- Tags: Binary Search, Dynamic Programming\n- Stars: 3\n\n#### DP O(n^2)\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] dp = new int[nums.length];\n        Arrays.fill(dp, 1);\n        for(int i=1; i<nums.length; i++){\n            for(int j=0; j<i; j++){\n                if(nums[j] < nums[i]){\n                    dp[i] = Math.max(dp[i], 1+dp[j]);\n                }\n            }\n        }\n        int result = 0;\n        for(int i=0; i<dp.length; i++){\n            if(result < dp[i]) result = dp[i];\n        }\n        return result;\n    }\n}\n```\n\n#### binary search O(nlogn)\n<span id=\"300-binary-search\"></span>\n`tails[i]` = the min value of the last elements of all subsequences with length of i+1. \n\nSimilar to [334. Increasing Triplet Subsequence](#334-binary-search)\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] tails = new int[nums.length];\n        int maxLen = 0;\n        for(int num: nums){\n            int idx = Arrays.binarySearch(tails, 0, maxLen, num);\n            if(idx<0) idx = -(idx+1);\n            tails[idx] = num;\n            if(maxLen == idx) maxLen++;\n        }\n        return maxLen;\n    }\n}\n```\n\n### 334. Increasing Triplet Subsequence\n- [Link](https://leetcode.com/problems/increasing-triplet-subsequence/)\n- Tags: \n- Stars: 2\n\n#### binary search \n<span id=\"334-binary-search\"></span>\nSimilar to [300. Longest Increasing Subsequence](#300-binary-search)\n```java\nclass Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int[] tails = new int[3];\n        int maxLen = 0;\n        for(int num: nums){\n            int idx = getIdx(tails, maxLen, num);\n            tails[idx] = num;\n            if(idx == maxLen) maxLen++;\n            if(maxLen == 3) return true;\n        }\n        return false;\n    }\n    private int getIdx(int[] tails, int maxLen, int num){\n        for(int i=0; i<maxLen; i++){\n            if(num <= tails[i]) return i;\n        }\n        return maxLen;\n    }\n}\n```\n\n#### another binary search\n```java\nclass Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int a=Integer.MAX_VALUE, b=Integer.MAX_VALUE;\n        for(int num: nums){\n            if(num<=a) a = num;\n            else if(num<=b) b = num;\n            else return true;\n        }\n        return false;\n    }\n}\n```\n\n### 105. Construct Binary Tree from Preorder and Inorder Traversal\n- [Link](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n- Tags: Array, Tree, DFS\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return buildTree(preorder, 0, inorder, 0, inorder.length);\n    }\n    private TreeNode buildTree(int[] preorder, int m, \n                               int[] inorder, int n, int len){\n        if(len == 0) return null;\n        TreeNode root = new TreeNode(preorder[m]);\n        int mid = indexOf(inorder, n, len, root.val);\n        root.left = buildTree(preorder, m+1, inorder, n, mid-n);\n        root.right = buildTree(preorder, m+(mid-n+1), inorder, mid+1, len-(mid-n+1));\n        return root;\n    }\n    private int indexOf(int[] nums, int start, int len, int target){\n        for(int i=start; i<start+len; i++)\n            if(nums[i]==target)\n                return i;\n        return -1;\n    }\n}\n```\n\n### 73. Set Matrix Zeroes\n- [Link](https://leetcode.com/problems/set-matrix-zeroes/)\n- Tags: Array\n- Stars: 3\n\n#### O(mn) time and O(1) space\n```java\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        if(matrix.length==0 || matrix[0].length==0) return ;\n        // check whether the first row has zero;\n        boolean firstRowZero = false;\n        for(int j=0; j<matrix[0].length; j++)\n            if(matrix[0][j]==0){\n                firstRowZero = true;\n                break;\n            }\n        // Set all rows that have zero to zeros, and mark the zero column in the first row\n        for(int i=1; i<matrix.length; i++){\n            boolean rowZero = false;\n            for(int j=0; j<matrix[0].length; j++){\n                if(matrix[i][j]==0){\n                    rowZero = true;\n                    matrix[0][j] = 0;\n                }\n            }\n            if(rowZero) Arrays.fill(matrix[i], 0);\n        }\n        // Set all the zero columns to zeros\n        for(int j=0; j<matrix[0].length; j++)\n            if(matrix[0][j]==0)\n                for(int i=1; i<matrix.length; i++)\n                    matrix[i][j] = 0;\n        // deal with the first row\n        if(firstRowZero) Arrays.fill(matrix[0], 0);\n    }\n}\n```\n\n### 395. Longest Substring with At Least K Repeating Characters\n- [Link](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/)\n- Tags: \n- Stars: 3\n\n#### two pointers\n```java\nclass Solution {\n    public int longestSubstring(String s, int k) {\n        return longestSubstring(s, 0, s.length()-1, k);\n    }\n    public int longestSubstring(String s, int l, int r, int k){\n        if(r-l+1 < k) return 0;\n        int[] stat = new int[26];\n        for(int i=l; i<=r; i++) stat[s.charAt(i)-'a']++;\n        int charIdx = getCharIdx(stat, k);\n        while(l<=r && charIdx != -1){\n            if(s.charAt(r)-'a' == charIdx){\n                stat[charIdx]--;\n                r--;\n            }\n            else if (s.charAt(l)-'a' == charIdx){\n                stat[charIdx]--;\n                l++;\n            }\n            else {\n                for(int i=l; i<=r; i++)\n                    if(s.charAt(i)-'a' == charIdx){\n                        return Math.max(longestSubstring(s, l, i-1, k), \n                                        longestSubstring(s, i+1, r, k));\n                    }\n            }\n            if(stat[charIdx] == 0) charIdx = getCharIdx(stat, k);\n        }\n        if(l>r) return 0;\n        return r-l+1;\n    }\n    private int getCharIdx(int[] stat, int k){\n        for(int j=0; j<26; j++)\n            if(stat[j]>0 && stat[j]<k)\n                return j;\n        return -1;\n    }\n}\n```\n\n### 207. Course Schedule\n- [Link](https://leetcode.com/problems/course-schedule/)\n- Tags: BFS, DFS, Graph, Topological Sort\n- Stars: 1\n\n#### Topological Sort\n<span id=\"207-topo-sort\"></span>\nSimilar to [210. Course Schedule II](#210-topo-sort)\n```java\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] degrees = new int[numCourses];\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        for(int[] edge: prerequisites)\n            graph.computeIfAbsent(edge[1], key->new ArrayList<>()).add(edge[0]);\n        for(int[] edge: prerequisites) \n            degrees[edge[0]]++;\n        Queue<Integer> qu = new LinkedList<>();\n        for(int i=0; i<numCourses; i++)\n            if(degrees[i] == 0) qu.add(i);\n        while(!qu.isEmpty()){\n            int course = qu.poll();\n            if(graph.containsKey(course))\n                for(int subCourse: graph.get(course))\n                    if(--degrees[subCourse] == 0) qu.add(subCourse);\n        }\n        for(int degree: degrees)\n            if(degree>0) return false;\n        return true;\n    }\n}\n```\n\n#### DFS\n1. Use `visiting` array to trace along the DFS path. Just like what backtracking usually does, you set visiting[i] to true before DFS, and reset it to false after DFS. \n2. The `visited` array is just used to remember the DFS result of each node to avoid recomputation. \n```java\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        for(int[] edge: prerequisites)\n            graph.computeIfAbsent(edge[1], key->new ArrayList<>()).add(edge[0]);\n        for(int i=0; i<numCourses; i++)\n            if(!DFS(graph, new boolean[numCourses], new boolean[numCourses], i)) return false;\n        return true;\n        \n    }\n    private boolean DFS(HashMap<Integer, List<Integer>> graph, boolean[] visited, boolean[] visiting, int course){\n        if(visited[course]) return true;\n        \n        if(visiting[course]) return false;\n        visiting[course] = true;\n        if(graph.containsKey(course))\n            for(Integer subCourse: graph.get(course)){\n                if(!DFS(graph, visited, visiting, subCourse)) return false;\n            }\n        visiting[course] = false;\n        \n        visited[course] = true;\n        return true;\n    }\n}\n```\n\n### 210. Course Schedule II\n- [Link](https://leetcode.com/problems/course-schedule-ii/)\n- Tags: BFS, DFS, Graph, Topological Sort\n- Stars: 1\n\n#### Topological Sort\n<span id=\"210-topo-sort\"></span>\nSimilar to [207. Course Schedule](#210-topo-sort)\n```java\nclass Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        int[] degrees = new int[numCourses];\n        for(int[] edge: prerequisites){\n            graph.computeIfAbsent(edge[1], key-> new ArrayList<>()).add(edge[0]);\n            degrees[edge[0]]++;\n        }\n        Queue<Integer> qu = new LinkedList<>();\n        for(int i=0; i<numCourses; i++) \n            if(degrees[i] == 0) qu.add(i);\n        int[] result = new int[numCourses];\n        int i=0;\n        while(!qu.isEmpty()){\n            int course = qu.poll();\n            if(graph.containsKey(course))\n                for(int subcourse : graph.get(course)) \n                    if(--degrees[subcourse] == 0) qu.add(subcourse);\n            result[i++] = course;\n        }\n        if(i != numCourses) return new int[0];\n        return result;\n    }\n    \n}\n```\n\n### 34. Find First and Last Position of Element in Sorted Array\n- [Link](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n- Tags: Array, Binary Search\n- Stars: 3\n\n#### Binary Search Lower Bound\nThis question needs careful consideration of the boundaries!\n\n1. To ensure the output of lowerBound is still in the range of [0, nums.length-1], `int b = lowerBound(nums, a, nums.length-1, target+1);` cannot be `int b = lowerBound(nums, a+1, nums.length-1, target+1);` in order to adapt to the case where `a==b`\n2. We still need `arr[1] = nums[b] == target ? b : b-1;` because b might be the last element and thus nums[b] might be smaller than `target+1`\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] arr = {-1,-1};\n        if(nums.length == 0) return arr;\n        int a = lowerBound(nums, 0, nums.length-1, target);\n        if(nums[a]!=target) return arr;\n        int b = lowerBound(nums, a, nums.length-1, target+1);\n        arr[0] = a; \n        arr[1] = nums[b] == target ? b : b-1;\n        return arr;\n    }\n    private int lowerBound(int[] nums, int i, int j, int target){\n        int l=i, r=j;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            if(nums[mid] == target) r = mid;\n            else if(nums[mid] > target) r = mid-1;\n            else l = mid+1;\n        }\n        return l;\n    }\n}\n```\n\n### 236. Lowest Common Ancestor of a Binary Tree\n- [Link](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n- Tags: Tree\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    TreeNode node;\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        helper(root, p, q);\n        return node;\n    }\n    private int helper(TreeNode root, TreeNode p, TreeNode q){\n        if(root == null) return 0;\n        int a = helper(root.left, p, q);\n        if(a == 2) return 2;\n        int b = helper(root.right, p, q);\n        if(b == 2) return 2;\n        int result = a + b;\n        if(root == p || root == q) result++;\n        if(result == 2) node = root;\n        return result;\n    }\n}\n```\n\n#### DFS without helper counting function\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null) return null;\n        if(root == p || root == q) return root;\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\n        if(l == null) return r;\n        if(r == null) return l;\n        return root;\n    }\n}\n```\n\n### 235. Lowest Common Ancestor of a Binary Search Tree\n- [Link](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n- Tags: Tree\n- Stars: 1\n\n#### BST, beats 100%\nPlease refer to **236**.\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null) return null;\n        if(p.val > q.val) return lowestCommonAncestor(root, q, p);\n        if(root.val < p.val) return lowestCommonAncestor(root.right, p, q);\n        if(root.val > q.val) return lowestCommonAncestor(root.left, p, q);\n        return root;\n    }\n}\n```\n\n### 139. Word Break\n- [Link](https://leetcode.com/problems/word-break/)\n- Tags: Dynamic Programming\n- Stars: 3\n\n#### DP\n```java\nclass Solution {\n    HashMap<Character, List<String>> map = new HashMap<>();\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str: wordDict)\n            map.computeIfAbsent(str.charAt(str.length()-1), key->new ArrayList<>()).add(str);\n        boolean[] dp = new boolean[s.length()];\n        for(int i=0; i<s.length(); i++){\n            char c = s.charAt(i);\n            String subs = s.substring(0, i+1);\n            if(map.containsKey(c))\n               for(String word: map.get(c)){\n                   if(subs.endsWith(word) && (i<word.length() || dp[i-word.length()])) dp[i] = true;\n               }\n        }\n        return dp[s.length()-1];\n    }\n}\n```\n\n### 19. Remove Nth Node From End of List\n- [Link](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n- Tags: Linked List, Two Pointers\n- Stars: 3\n\n#### one pass solution\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if(head == null) return null;\n        ListNode fast = head, slow = head;\n        for(int i=0; i<n; i++) fast = fast.next;\n        if(fast == null) return head.next;\n        while(fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}\n```\n\n### 56. Merge Intervals\n- [Link](https://leetcode.com/problems/merge-intervals/)\n- Tags: Array, Sort\n- Stars: 3\n\n#### sort\nThe way of writting a sort function can be simplified to `intervals.sort((o1, o2)->o1.start-o2.start);`.\n\nTake a look at [435. Non-overlapping Intervals](#435. Non-overlapping Intervals) \n```java\nclass Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        if(intervals.size() == 0) return intervals;\n        Collections.sort(intervals, new Comparator<Interval>() {\n            @Override\n            public int compare(Interval o1, Interval o2){\n                return o1.start - o2.start;\n            }\n        });\n        int start = intervals.get(0).start, end = intervals.get(0).end;\n        int i=1;\n        List<Interval> result = new ArrayList<>();\n        for(; i<intervals.size(); i++){\n            if(intervals.get(i).start > end){\n                result.add(new Interval(start, end));\n                start = intervals.get(i).start; end = intervals.get(i).end;\n            }\n            else {\n                end = Math.max(end, intervals.get(i).end);\n            }\n        }\n        result.add(new Interval(start, end));\n        return result;\n    }\n}\n```\n\n### 435. Non-overlapping Intervals\n- [Link](https://leetcode.com/problems/non-overlapping-intervals/description/)\n- Tags: Greedy\n- Stars: 2\n\n### 134. Gas Station\n- [Link](https://leetcode.com/problems/gas-station/)\n- Tags: Greedy\n- Stars: 3\n\n#### pseudo two pointers\n1. `while(slow < len && gas[slow]<0) slow++;` cannot be written as `while(slow < len && gas[slow]<=0) slow++;`. Consider cases like `gas[i] == cost[i]` for all possible i. \n2. Let's assume `remain[i] = gas[i]-cost[i]`. When `sum(remain, slow, fast) < 0`, all the stations between slow and fast cannot satisfy the demand.  \nThis idea comes from the fact that the array is an non-decreasing array.  \nWe know that when we have `slow` fixed and start considering `fast`, any station i between slow and fast should hold `sum(remain, slow, i) >= 0`. \nLet's assume there is an station k between slow and fast, which satisfy `sum(remain, k, fast) > 0`.\nFrom this, we can easily get `sum(remain, slow, k-1) < 0`, which is contradicted to the assumption. \nTherefore, as long as `sum(remain, slow, fast) < 0`, we can skip all the stations between slow and fast, and set `slow = fast + 1`. \n3. If `sum(gas) >= sum(cost)`, there must be a solution. Otherwise, no solution. \n```java\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        for(int i=0; i<gas.length; i++) gas[i] -= cost[i];\n        int slow = 0, len = gas.length;\n        while(slow < len && gas[slow]<0) slow++;\n        if(slow == len) return -1;\n        int fast = slow, result = 0;\n        while(true){\n            result += gas[fast];\n            fast = (fast+1)%len;\n            if(result < 0){\n                if(fast > slow) {\n                    slow = fast;\n                    while(slow < len && gas[slow]<0) slow++;\n                    if(slow == len) return -1;\n                    result = gas[slow];\n                    fast = (slow+1)%len;\n                }\n                else return -1;\n            }\n            if(fast == slow) return slow;\n        }\n    }\n}\n```\n\n### 33. Search in Rotated Sorted Array\n- [Link](https://leetcode.com/problems/search-in-rotated-sorted-array/)\n- Tags: Array, Binary Search\n- Stars: 2\n\n#### Method 1: use binary search for 3 times\nThe most direct method is to find the pivot, and then separate `nums` into two subarrays according to the position of the pivot, and then apply binary search to each subarray. \n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if(nums.length == 0) return -1;\n        int l = 0, r = nums.length-1;\n        while(l+1 < r){\n            int mid = l + ((r-l)>>1);\n            if(nums[mid] < nums[0]) r = mid;\n            else l = mid;\n        }\n        // System.out.println(l + \" \" + r);\n        int a = Arrays.binarySearch(nums, 0, r, target);\n        if(a<0){\n            int b = Arrays.binarySearch(nums, r, nums.length, target);\n            if(b<0) return -1;\n            return b;\n        }\n        return a;\n    }\n}\n```\n\n#### Method 2: use binary search for 2 times\nJust like the above solution, we find the pivot first. Once we have pivot, we can establish a mapping of indices before and after the rotation. \n\nBe careful to a special case where `shift == 0` (i.e. the position of the smallest element)\n\nTime: 6 ms\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        // compute `shift`\n        if(nums.length == 0) return -1;\n        int l = 0, r = nums.length-1;\n        int shift = -1;\n        if(nums[l] < nums[r]) shift = 0;\n        else {\n            while(l+1 < r){\n                int mid = l + ((r-l)>>1);\n                if(nums[mid] < nums[0]) r = mid;\n                else l = mid;\n            }\n            shift = r;\n        }\n        // use `shift` to map index\n        l = 0;\n        r = nums.length-1;\n        while(l<=r) {\n            int mid = l + ((r-l)>>1);\n            int midAfterRotate = (mid+shift)%nums.length; //idxAfterRotate(mid, shift, nums.length);\n            if(nums[midAfterRotate] == target) return midAfterRotate;\n            else if(nums[midAfterRotate] > target) r = mid - 1;\n            else l = mid + 1;\n        }\n        return -1;\n    }\n    // private int idxAfterRotate(int i, int k, int len){\n    //     return (i+k)%len;\n    // }\n}\n```\n\n#### Method 3: use binary search for 3 times\n`nums` is almost in a sorted order, and we can take advantage of it! \n\nwe can divide this problem into two cases:  \n1. `target >= nums[0]`: target is in the left part\n2. `target < nums[0]`: target is in the right part\n\nFor each case, we only need to deal with a situation when `nums[mid]` is in the wrong part.\n\nTime: 6 ms\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if(nums.length == 0) return -1;\n        int l = 0, r = nums.length - 1;\n        // take care of the special case\n        if(nums[l] < nums[r]){\n            int idx = Arrays.binarySearch(nums, l, r+1, target);\n            return idx<0 ? -1 : idx;\n        }\n        if(target >= nums[0]){\n            // target is in the left part\n            while(l<=r){\n                int mid = l + ((r-l)>>1);\n                if(nums[mid] < nums[0]) r = mid-1;\n                else if(nums[mid] == target) return mid;\n                else if(nums[mid] > target) r = mid-1;\n                else l = mid + 1;\n            }\n            return -1;\n        }\n        else {\n            // target is in the right part\n            while(l<=r){\n                int mid = l + ((r-l)>>1);\n                if(nums[mid] >= nums[0]) l = mid+1;\n                else if(nums[mid] == target) return mid;\n                else if(nums[mid] > target) r = mid-1;\n                else l = mid+1;\n            }\n            return -1;\n        }\n    }\n}\n```\n\n### 150. Evaluate Reverse Polish Notation\n- [Link](https://leetcode.com/problems/evaluate-reverse-polish-notation/)\n- Tags: Stack\n- Stars: 1\n\n#### stack\n1. `token.length()>1` is used to deal with negative numbers.\n2. pay attention to the order of parameters in `compute` function\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> st = new Stack<>();\n        for(String token: tokens){\n            // System.out.println(st.toString());\n            if(Character.isDigit(token.charAt(0)) || token.length()>1){ \n                int num = Integer.parseInt(token);\n                st.push(num);\n            }\n            else {\n                st.push(compute(st.pop(), st.pop(), token.charAt(0)));\n            }\n        }\n        // System.out.println(st.toString());\n        return st.pop();\n    }\n    private int compute(int b, int a, char c){\n        if(c == '+') return a+b;\n        else if(c=='-') return a-b;\n        else if(c=='*') return a*b;\n        else return a/b;\n    }\n}\n```\n\n### 55. Jump Game\n- [Link](https://leetcode.com/problems/jump-game/)\n- Tags: Array, Greedy\n- Stars: 1\n\n#### DP\n```java\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int dp = nums[0];\n        for(int i=1; i<nums.length; i++){\n            if(dp < i) return false;\n            dp = Math.max(dp, i+nums[i]);\n        }\n        return dp>=nums.length-1;\n    }\n}\n```\n\n### 2. Add Two Numbers\n- [Link](https://leetcode.com/problems/add-two-numbers/)\n- Tags: Linked List, Math\n- Stars: 1\n\n#### simple solution beats 91.83% in time and 96.99% in space\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        int cin = 0;\n        ListNode head = new ListNode(-1);\n        ListNode curr = head;\n        while(l1 != null || l2 != null){\n            int temp = cin;\n            if(l1 != null) {\n                temp += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){\n                temp += l2.val;\n                l2 = l2.next;\n            }\n            curr.next = new ListNode(temp%10);\n            curr = curr.next;\n            cin = temp/10;\n        }\n        if(cin > 0)\n            curr.next = new ListNode(cin);\n        return head.next;\n    }\n}\n```\n\n### 54. Spiral Matrix\n- [Link](https://leetcode.com/problems/spiral-matrix/)\n- Tags: Array\n- Stars: 1\n\n#### recursive\nThe key of this problem lies in the boundaries.\n\n`if(m != 2*k+1)` and `if(n != 2*k+1)` are used to deal with rectangular matrices to prevent duplicates. \n```java\nclass Solution {\n    List<Integer> result = new ArrayList<>();\n    int m,n;\n    public List<Integer> spiralOrder(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0) return result;\n        this.m = matrix.length;\n        this.n = matrix[0].length;\n        spiralOrder(matrix, 0);\n        return result;\n    }\n    private void spiralOrder(int[][] matrix, int k){\n        if(k>(m-1)/2 || k>(n-1)/2) return ;\n        result.add(matrix[k][k]);\n        for(int j=k+1; j<n-k; j++) result.add(matrix[k][j]);\n        for(int i=k+1; i<m-k; i++) result.add(matrix[i][n-k-1]);\n        if(m != 2*k+1)\n            for(int j=n-k-2; j>=k; j--) result.add(matrix[m-k-1][j]);\n        if(n != 2*k+1)\n        for(int i=m-k-2; i>=k+1; i--) result.add(matrix[i][k]);\n        spiralOrder(matrix, k+1);\n    }\n}\n```\n\n### 152. Maximum Product Subarray\n- [Link](https://leetcode.com/problems/maximum-product-subarray/)\n- Tags: Array, Dynamic Programming\n- Stars: 3\n\n#### DP, space-optimized\n`dp[i]` means the largest product of the subarray ended up with nums[i]  \nHere we use `maxVal` and `minVal` to record the local state of an iteration. \n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        // int[] dp = new int[nums.length];\n        int dp;\n        int maxVal, minVal;\n        // maxVal = minVal = dp[0] = nums[0];\n        maxVal = minVal = dp = nums[0];\n        for(int i=1; i<nums.length; i++){\n            int num = nums[i];\n            if(num > 0){\n                maxVal = Math.max(num, maxVal * num);\n                minVal = Math.min(num, minVal * num);\n            }\n            else if(num < 0){\n                int nextMinVal = Math.min(num, maxVal * num);\n                maxVal = Math.max(num, minVal * num);\n                minVal = nextMinVal;\n            }\n            else {\n                maxVal = minVal = 0;\n            }\n            // dp[i] = maxVal;\n            if(dp < maxVal) dp = maxVal;\n        }\n        // int result = Integer.MIN_VALUE;\n        // for(int res: dp)\n        //     if(result < res) result = res;\n        // return result;\n        return dp;\n    }\n}\n```\n\n### 50. Pow(x, n)\n- [Link](https://leetcode.com/problems/powx-n/)\n- Tags: Math, Binary Search\n- Stars: 2\n\n#### iterative\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(n == 0) return 1;\n        if(x == 0) return 0;\n        if(n == Integer.MIN_VALUE) {\n            if(x > 1 || x<-1) return 0;\n            return 1;\n        }\n        if(n<0) {\n            n = -n;\n            x = 1/x;\n        }\n        HashMap<Integer, Double> map = new HashMap<>();\n        map.put(1, x);\n        int currN = 1;\n        while((currN<<1) > 0 && (currN<<1) < n){\n            double temp = map.get(currN);\n            currN <<= 1;\n            map.put(currN, temp * temp);\n        }\n        double result = 1;\n        while(n>0){\n            while(n < currN) currN >>= 1;\n            result *= map.get(currN);\n            n -= currN;\n        }\n        return result;\n    }\n}\n```\n\n#### recursive\n```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(n == 0) return 1;\n        if(n == Integer.MIN_VALUE){\n            return myPow(x*x, n>>1);\n        } \n        if(n<0) {\n            n = -n;\n            x = 1/x;\n        }\n        return (n%2) == 0 ? myPow(x*x, n>>1) : x * myPow(x*x, n>>1);\n    }\n}\n```\n\n### 3. Longest Substring Without Repeating Characters\n- [Link](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n- Tags: Hash Table, Two Pointers, String\n- Stars: 2\n\n#### two pointers, thinking in a DP way\nNotice that `s` may contain any ASCII character. \n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s == null || s.length() == 0) return 0;\n        boolean[] alphabet = new boolean[256];\n        int head = 0, tail = 1;\n        alphabet[s.charAt(0)] = true;\n        int result = 1;\n        while(tail < s.length()){\n            if(alphabet[s.charAt(tail)]){\n                do {\n                    alphabet[s.charAt(head++)] = false;\n                } while(s.charAt(head-1) != s.charAt(tail));\n            }\n            alphabet[s.charAt(tail++)] = true;\n            if(result < tail-head) result = tail-head;\n        }\n        return result;\n    }\n}\n```\n\n### 138. Copy List with Random Pointer\n- [Link](https://leetcode.com/problems/copy-list-with-random-pointer/)\n- Tags: Hash Table, Linked List\n- Stars: 1\n\n#### 2 pass copy with Hash Mapping, O(n) space and O(n) time\n```java\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if(head == null) return null;\n        Node newHead = new Node(head.val, head.next, head.random);\n        HashMap<Node, Node> map = new HashMap<>();\n        map.put(head, newHead);\n        Node curr = newHead;\n        while(curr.next != null){\n            Node temp = curr.next;\n            curr.next = new Node(temp.val, temp.next, temp.random);\n            map.put(temp, curr.next);\n            curr = curr.next;\n        }\n        curr = newHead;\n        while(curr != null){\n            if(curr.random != null)\n                curr.random = map.get(curr.random);\n            curr = curr.next;\n        }\n        return newHead;\n    }\n}\n```\n\n#### 3 pass O(1) space and O(n) time\nSince the original Linkedlist has to remain unchanged, we need to restore next pointer of the original nodes.  \nNotice that you cannot setup the random pointers while extracting the new Head at the same time. \n```java\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if(head == null) return null;\n        // interleaving copy\n        Node curr = head;\n        while(curr != null){\n            curr.next = new Node(curr.val, curr.next, curr.random);\n            curr = curr.next.next;\n        }\n        Node newHead = head.next;\n        // setup the random pointers\n        curr = head.next;\n        while(true){\n            if(curr.random != null)\n                curr.random = curr.random.next;\n            if(curr.next == null) break;\n            curr = curr.next.next;\n        }\n        // extract the newHead\n        curr = head;\n        Node copy = newHead;\n        while(true) {\n            curr.next = copy.next;\n            curr = curr.next;\n            if(copy.next == null) break;\n            copy.next = curr.next;\n            copy = copy.next;\n        }\n        return newHead;\n    }\n}\n```\n\n### 179. Largest Number\n- [Link](https://leetcode.com/problems/largest-number/)\n- Tags: Sort\n- Stars: 2\n\n#### Arrays.sort Comparator\n1. be careful about these cases: comparing 3456 & 345, 3451 & 345\n2. remember to remove the leading zeroes\n3. `Arrays.sort(xxx, new Comparator<xxx>() {})` can only be applied to object arrays\n```java\nclass Solution {\n    public String largestNumber(int[] nums) {\n        // convert nums to a String Array\n        String[] strs = new String[nums.length];\n        for(int i=0; i<nums.length; i++)\n            strs[i] = Integer.toString(nums[i]);\n        // Self-defined sorting\n        Arrays.sort(strs, new Comparator<String>() {\n            @Override\n            public int compare(String a, String b) {\n                int i=0; \n                while(i<a.length() && i<b.length()){\n                    if(a.charAt(i) != b.charAt(i))\n                        return b.charAt(i) - a.charAt(i);\n                    i++;\n                }\n                if(i == a.length() && i == b.length()) return 0;\n                else if(i == b.length())\n                    return compare(a.substring(i, a.length()) + b, a);\n                else \n                    return compare(b, b.substring(i, b.length()) + a);\n            }\n        });\n        // join the strings\n        String result = String.join(\"\", Arrays.asList(strs));\n        int k = 0;\n        // remove the leading zeros\n        while(k<result.length() && result.charAt(k) == '0') k++;\n        if(k == result.length()) return \"0\";\n        return result.substring(k, result.length());\n    }\n}\n```\n\n#### smarter but much slower idea using concatenation\n```java\nclass Solution {\n    public String largestNumber(int[] nums) {\n        String[] strs = new String[nums.length];\n        for(int i=0; i<nums.length; i++)\n            strs[i] = Integer.toString(nums[i]);\n        Arrays.sort(strs, (String a, String b)->(b+a).compareTo(a+b));\n        String result = String.join(\"\", Arrays.asList(strs));\n        int k = 0;\n        while(k<result.length() && result.charAt(k) == '0') k++;\n        if(k == result.length()) return \"0\";\n        return result.substring(k, result.length());\n    }\n}\n```\n\n### 98. Validate Binary Search Tree\n- [Link](https://leetcode.com/problems/validate-binary-search-tree/)\n- Tags: Tree, BFS\n- Stars: 1\n\n#### recursive\nAttention that you need to take care of cases like `root.val == Integer.MIN_VALUE` and `root.val == Integer.MAX_VALUE`, because under these circumstances, the boundaries might overflow.\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n    public boolean isValidBST(TreeNode root, int l, int r){\n        if(root == null) return true;\n        if(root.val > r || root.val < l) return false;\n        if(root.val == Integer.MIN_VALUE && root.left != null) return false;\n        if(root.val == Integer.MAX_VALUE && root.right != null) return false;\n        return isValidBST(root.left, l, root.val-1) && isValidBST(root.right, root.val+1, r);\n    }\n}\n```\n\n### 127. Word Ladder\n- [Link](https://leetcode.com/problems/word-ladder/)\n- Tags: BFS\n- Stars: 1\n\n#### My BFS\n1. You need to mark all the words that has been visited. \n2. You can initiate a boolean array for marking, but removing elements from wordList directly seems faster. \n```java\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Queue<String> qu = new LinkedList<>();\n        qu.add(beginWord);\n        // boolean[] mark = new boolean[wordList.size()];\n        int count = 1, level = 0;\n        while(!qu.isEmpty()){\n            String curr = qu.poll();\n            count--;\n            if(curr.equals(endWord)) return level+1;\n            for(int i=0; i<wordList.size(); i++){\n                String word = wordList.get(i);\n                // if(!mark[i] && isSimilar(curr, word)) {qu.add(word); mark[i] = true;}\n                if(isSimilar(curr, word)) {\n                    qu.add(word); \n                    wordList.remove(i--);\n                }\n            }\n            if(count == 0){\n                count = qu.size();\n                level++;\n            }\n        }\n        return 0;\n    }\n    private boolean isSimilar(String a, String b){\n        // if(a.length() != b.length()) return false;\n        int count = 0;\n        for(int i=0; i<a.length(); i++){\n            if(a.charAt(i) != b.charAt(i)) count++;\n            if(count == 2) return false;\n        }\n        return true;\n    }\n}\n```\n\n#### A faster BFS\n```java\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> set = new HashSet<>(wordList);\n        Queue<String> qu = new LinkedList<>();\n        qu.add(beginWord);\n        int count = 1, level = 0;\n        while(!qu.isEmpty()){\n            String curr = qu.poll();\n            count--;\n            if(curr.equals(endWord)) return level+1;\n            char[] chrs = curr.toCharArray();\n            for(int i=0; i<chrs.length; i++){\n                char temp = chrs[i];\n                for(char c='a'; c<='z'; c++){\n                    if(c == temp) continue;\n                    chrs[i] = c;\n                    String word = new String(chrs);\n                    if(set.contains(word)) {\n                        qu.add(word);\n                        set.remove(word);\n                    }\n                }\n                chrs[i] = temp;\n            }\n            if(count == 0){\n                count = qu.size();\n                level++;\n            }\n        }\n        return 0;\n    }\n}\n```\n\n### 130. Surrounded Regions\n- [Link](https://leetcode.com/problems/surrounded-regions/)\n- Tags: DFS, BFS, Union Find\n- Stars: 1\n\n#### My BFS\n```java\nclass Solution {\n    int[][] map;\n    public void solve(char[][] board) {\n        if(board.length == 0 || board[0].length == 0) return ;\n        map = new int[board.length][board[0].length];\n        for(int i=0; i<board.length; i++)\n            for(int j=0; j<board[0].length; j++){\n                if(isSurrounded(board, i, j)) flip(board, i, j, 'M', 'X');\n                else flip(board, i, j, 'M', 'O');\n            }\n    }\n    private boolean isSurrounded(char[][] board, int i, int j){\n        if(board[i][j] == 'X' || board[i][j] == 'M') return true;\n        if(i==0 || i==board.length-1 || j==0 || j==board[0].length-1) return false;\n        if(map[i][j] == 1) return true;\n        else if(map[i][j] == -1) return false;\n        board[i][j] = 'M';\n        boolean temp = isSurrounded(board, i-1, j) && isSurrounded(board, i+1, j) && isSurrounded(board, i, j-1) && isSurrounded(board, i, j+1);\n        map[i][j] = temp ? 1 : -1;\n        return temp;\n    }\n    private void flip(char[][] board, int i, int j, char src, char dst){\n        if(board[i][j] == src) {\n            board[i][j] = dst;\n            flip(board, i+1, j, src, dst);\n            flip(board, i-1, j, src, dst);\n            flip(board, i, j+1, src, dst);\n            flip(board, i, j-1, src, dst);\n        }\n    }\n}\n```\n\n#### My faster BFS, in an outside-in way\nFlip all the un-surrounded 'O's into 'M' in an outside-in way. Then, iterate the board and flip the remaining 'O's into 'X'. Finally, flip all the 'M's into 'O'. \n```java\nclass Solution {\n    int m, n;\n    public void solve(char[][] board) {\n        if(board.length == 0 || board[0].length == 0) return ;\n        m = board.length;\n        n = board[0].length;\n        // Flip all the un-surrounded 'O's into 'M' in an outside-in way.\n        for(int i=0; i<m; i++){\n            if(board[i][0] == 'O') flip(board, i, 0, 'O', 'M');\n            if(board[i][n-1] == 'O') flip(board, i, n-1, 'O', 'M');\n        }\n        for(int j=1; j<n-1; j++){\n            if(board[0][j] == 'O') flip(board, 0, j, 'O', 'M');\n            if(board[m-1][j] == 'O') flip(board, m-1, j, 'O', 'M');\n        }\n        // flip the remaining 'O's into 'X'.\n        for(int i=0; i<m; i++)\n            for(int j=0; j<n; j++)\n                if(board[i][j] == 'O') flip(board, i, j, 'O', 'X');\n        // flip all the 'M's into 'O'. \n        for(int i=0; i<m; i++)\n            for(int j=0; j<n; j++)\n                if(board[i][j] == 'M') flip(board, i, j, 'M', 'O');\n    }\n    private void flip(char[][] board, int i, int j, char src, char dst){\n        if(i>=0 && j>=0 && i<m && j<n && board[i][j] == src){\n            board[i][j] = dst;\n            flip(board, i+1, j, src, dst);\n            flip(board, i-1, j, src, dst);\n            flip(board, i, j+1, src, dst);\n            flip(board, i, j-1, src, dst);\n        }\n    }\n}\n```\n\n### 91. Decode Ways\n- [Link](https://leetcode.com/problems/decode-ways/)\n- Tags: String, Dynamic Programming\n- Stars: 1\n\n#### DP, space optimized\n`s.charAt(i) == 0` is a special case. \n```java\nclass Solution {\n    public int numDecodings(String s) {\n        if(s.length() == 0 || s.charAt(0) == '0') return 0;\n        // int[] dp = new int[s.length()];\n        // dp[0] = 1;\n        int dp1 = 1, dp2 = 1;\n        for(int i=1; i<s.length(); i++){\n            int dp=0;\n            if(s.charAt(i) == '0'){\n                if(s.charAt(i-1) == '1' || s.charAt(i-1) == '2') dp = dp2;\n                else return 0;\n            }\n            else {\n                dp = dp1;\n                if(s.charAt(i-1) == '1' || \n                   (s.charAt(i-1) == '2' && s.charAt(i) < '7'))\n                    dp += dp2;\n            }\n            dp2 = dp1;\n            dp1 = dp;\n        }\n        return dp1;\n    }\n}\n```\n\n### 29. Divide Two Integers\n- [Link](https://leetcode.com/problems/divide-two-integers/)\n- Tags: Math, Binary Search\n- Stars: 2\n\n#### subtract and double\n```java\nclass Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend == 0) return 0;\n        int sign = (dividend<0 && divisor<0) || (dividend>0 && divisor>0) ? 1 : -1;\n        //convert to positive and avoid overflow\n        if(divisor == Integer.MIN_VALUE) return dividend == Integer.MIN_VALUE ? 1 : 0;\n        if(divisor < 0) divisor = -divisor;\n        int result = 0;\n        if(dividend == Integer.MIN_VALUE) {\n            if(divisor == 1 && sign == 1) return Integer.MAX_VALUE;\n            dividend += divisor;\n            result++;\n        }\n        if(dividend < 0) dividend = -dividend;\n        //use map to record\n        HashMap<Integer, Integer> map = new HashMap<>();\n        map.put(1, divisor);\n        int curr = 1;\n        while(dividend >= map.get(curr)){\n            // experiment shows that adding the following two lines will makes it faster, though not necessary. \n            dividend -= map.get(curr);\n            result += curr;\n            // avoid overflow\n            if((map.get(curr)<<1) < 0) break;\n            map.put(curr<<1, map.get(curr)<<1);\n            curr <<= 1;\n        }\n        while(dividend >= map.get(1)){\n            while(dividend < map.get(curr)) curr>>=1;\n            dividend -= map.get(curr);\n            result += curr;\n        }\n        return sign * result;\n    }\n}\n```\n\n### 8. String to Integer (atoi)\n- [Link](https://leetcode.com/problems/string-to-integer-atoi/)\n- Tags: Math, String\n- Stars: 1\n\n#### boundary check\n```java\nclass Solution {\n    public int myAtoi(String str) {\n        if(str.length() == 0) return 0;\n        int i=0;\n        // remove leading white space\n        while(i<str.length() && str.charAt(i) == ' ') i++;\n        // detect plus/minus sign\n        int sign = 1;\n        if(i<str.length() && str.charAt(i) == '-') {sign = -1; i++;}\n        else if(i<str.length() && str.charAt(i) == '+') {sign = 1; i++;}\n        // remove leading zeros\n        while(i<str.length() && str.charAt(i) == '0') i++;\n        // parse Integer\n        long result = 0;\n        int start = i;\n        for(; i<str.length() && i-start < 11; i++){\n            if(!Character.isDigit(str.charAt(i))) break;\n            result *= 10;\n            result += str.charAt(i) - '0';\n        }\n        result *= sign;\n        if(result < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n        else if (result > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        return (int)result;\n    }\n}\n```\n\n### 222. Count Complete Tree Nodes\n- [Link](https://leetcode.com/problems/count-complete-tree-nodes/)\n- Tags: Binary Search, Tree\n- Stars: 2\n\n#### Binary Search in a tree\nCompute the left height `h` in each iteration. \nif #nodes of right subtree > #perfect complete tree with height `h-2`, we can conclude that the left subtree must be a perfect complete tree with height `h-1`.\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null) return 0;\n        int height = getLeftHeight(root);\n        if(height == 0) return 1;\n        if(height == 1) return root.right == null ? 2 : 3;\n        int rightNum = countNodes(root.right);\n        if(rightNum > computeTotalNodes(height-2))\n            return computeTotalNodes(height-1) + rightNum + 1;\n        return countNodes(root.left) + rightNum + 1;\n    }\n    private int computeTotalNodes(int height){\n        return (1<<(height+1))-1;\n    }\n    private int getLeftHeight(TreeNode root){\n        int count = 0;\n        while(root.left != null){\n            count++;\n            root = root.left;\n        }\n        return count;\n    }\n}\n```\n\n#### concise version\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        int height = getHeight(root);\n        if(height == 0) return 0;\n        if(getHeight(root.right) == height-1)\n            return (1<<height-1) + countNodes(root.right);\n        return countNodes(root.left) + (1<<(height-2));\n    }\n    private int getHeight(TreeNode root){\n        int count = 0;\n        while(root != null){\n            count++;\n            root = root.left;\n        }\n        return count;\n    }\n}\n```\n\n### 53. Maximum Subarray\n- [Link](https://leetcode.com/problems/maximum-subarray/)\n- Tags: Array, Divide and Conquer, Dynamic Programming\n- Stars: 1\n\n#### DP\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums.length == 0) return 0;\n        int dp = nums[0], result = nums[0];\n        for(int i=1; i<nums.length; i++){\n            if(dp < 0) dp = nums[i];\n            else dp += nums[i];\n            if(result < dp) result = dp;\n        }\n        return result;\n    }\n}\n```\n\n#### Divide and Conquer\n```java\n// not implemented yet\n```\n\n### 343. Integer Break\n- [Link](https://leetcode.com/problems/integer-break/)\n- Tags: Math, Dynamic Programming\n- Stars: 3\n\n#### Math solution\n```java\nclass Solution {\n    public int integerBreak(int n) {\n        if(n == 2) return 1;\n        if(n == 3) return 2;\n        int result = 1;\n        while(n>4){\n            result *= 3;\n            n -= 3;\n        }\n        result *= n;\n        return result;\n    }\n}\n```\n\n### 415. Add Strings\n- [Link](https://leetcode.com/problems/add-strings/)\n- Tags: Math\n- Stars: 1\n\n#### while loop with StringBuilder.insert(0, xxx)\n```java\nclass Solution {\n    public String addStrings(String num1, String num2) {\n        StringBuilder sb = new StringBuilder();\n        int i=num1.length()-1, j=num2.length()-1;\n        int cin = 0;\n        while(i>=0 || j>=0){\n            int temp = cin;\n            if(i>=0) temp += num1.charAt(i--)-'0';\n            if(j>=0) temp += num2.charAt(j--)-'0';\n            if(temp > 9){\n                cin = 1;\n                temp %= 10;\n            }\n            else cin = 0;\n            sb.insert(0, temp);\n        }\n        if(cin > 0) sb.insert(0, cin);\n        return sb.toString();\n    }\n}\n```\n\n### 43. Multiply Strings\n- [Link](https://leetcode.com/problems/multiply-strings/)\n- Tags: Math, String\n- Stars: 2\n\n#### StringBuilder.insert\n```java\nclass Solution {\n    public String multiply(String num1, String num2) {\n        StringBuilder sb = new StringBuilder();\n        int base = 0, carry = 0;\n        while(++base <= num1.length() + num2.length()){\n            for(int i=0; i<base && i<num1.length(); i++){\n                int j = base-1-i;\n                if(j >= num2.length()) continue;\n                carry += (num1.charAt(num1.length()-1-i)-'0') * (num2.charAt(num2.length()-1-j)-'0');\n            }\n            sb.insert(0, carry%10);\n            carry /= 10;\n        }\n        if(carry > 0) sb.insert(0, carry);\n        for(int i=0; i<sb.length(); i++){\n            if(sb.charAt(i) != '0') return sb.substring(i, sb.length());\n        }\n        return \"0\";\n    }\n}\n```\n\n### 349. Intersection of Two Arrays\n- [Link](https://leetcode.com/problems/intersection-of-two-arrays/)\n- Tags: Hash Table, Two Pointers, Binary Search, Sort\n- Stars: 1\n\n#### Hash Set 2ms\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        for(int num: nums1) set.add(num);\n        for(int num: nums2) {\n            if(set.contains(num)){\n                list.add(num);\n                set.remove(num);\n            }\n        }\n        int[] result = new int[list.size()];\n        for(int i=0; i<list.size(); i++)\n            result[i] = list.get(i);\n        return result;\n    }\n}\n```\n\n#### Two pointers 2ms\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i=0, j=0;\n        while(i<nums1.length && j<nums2.length){\n            if(nums1[i] == nums2[j]){\n                list.add(nums1[i]);\n                i++; j++;\n                while(i<nums1.length && nums1[i] == nums1[i-1]) i++;\n                while(j<nums2.length && nums2[j] == nums2[j-1]) j++;\n            }\n            else if(nums1[i] > nums2[j]) {\n                j++;\n                while(j<nums2.length && nums2[j] == nums2[j-1]) j++;\n            }\n            else {\n                i++;\n                while(i<nums1.length && nums1[i] == nums1[i-1]) i++;\n            }\n        }\n        int[] result = new int[list.size()];\n        for(int k=0; k<list.size(); k++)\n            result[k] = list.get(k);\n        return result;\n    }\n}\n```\n\n### 350. Intersection of Two Arrays II\n- [Link](https://leetcode.com/problems/intersection-of-two-arrays-ii/)\n- Tags: Hash Table, Two Pointers, Binary Search, Sort\n- Stars: 2\n\n#### Hash Table O(n)time, O(n)space  2ms\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int num: nums1)\n            map.put(num, map.getOrDefault(num, 0)+1);\n        for(int num : nums2){\n            int temp = map.getOrDefault(num, 0);\n            if(temp > 0){\n                map.put(num, temp-1);\n                list.add(num);\n            }\n        }\n        int[] result = new int[list.size()];\n        for(int i=0; i<list.size(); i++)\n            result[i] = list.get(i);\n        return result;\n    }\n}\n```\n\n#### Two pointers O(nlogn)time O(1) space, 1ms\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i=0, j=0;\n        while(i<nums1.length && j<nums2.length){\n            if(nums1[i] < nums2[j]) i++;\n            else if(nums1[i] > nums2[j]) j++;\n            else {\n                list.add(nums1[i]);\n                i++; j++;\n            }\n        }\n        int[] result = new int[list.size()];\n        for(int k=0; k<list.size(); k++)\n            result[k] = list.get(k);\n        return result;\n    }\n}\n```\n\n### 101. Symmetric Tree\n- [Link](https://leetcode.com/problems/symmetric-tree/)\n- Tags: Tree, DFS, BFS\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root == null) return true;\n        return isSymmetric(root.left, root.right);\n    }\n    private boolean isSymmetric(TreeNode a, TreeNode b){\n        if(a==null) return b==null;\n        if(b==null) return false;\n        if(a.val != b.val) return false;\n        return isSymmetric(a.right, b.left) && isSymmetric(a.left, b.right);\n    }\n}\n```\n\n### 69. Sqrt(x)\n- [Link](https://leetcode.com/problems/sqrtx/)\n- Tags: Math, Binary Search\n- Stars: 1\n\n#### binary search\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = 46340;\n        while(l+1<r) {\n            int mid = l + ((r-l)>>1);\n            if(mid*mid == x) return mid;\n            else if(mid*mid > x) r = mid-1;\n            else l = mid;\n        }\n        if(r*r <= x) return r;\n        return l;\n    }\n}\n```\n\n### 674. Longest Continuous Increasing Subsequence\n- [Link](https://leetcode.com/problems/longest-continuous-increasing-subsequence/)\n- Tags: Array\n- Stars: 1\n\n#### DP\n```java\nclass Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        if(nums.length == 0) return 0;\n        int maxLen = 1, result = 1;\n        for(int i=1; i<nums.length; i++){\n            if(nums[i] > nums[i-1]) maxLen++;\n            else {\n                if(result < maxLen) result = maxLen;\n                maxLen = 1;\n            }\n        }\n        if(result < maxLen) result = maxLen;\n        return result;\n    }\n}\n```\n\n### 673. Number of Longest Increasing Subsequence\n- [Link](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)\n- Tags: Dynamic Programming\n- Stars: 3\n\n#### DP O(n^2)time\n```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] len = new int[nums.length]; // the longest length of Increasing Subsequence that ends with nums[i]\n        int[] count = new int[nums.length];// the number of longest Increasing Subsequence that ends with nums[i]\n        len[0] = 1;\n        count[0] = 1;\n        int maxLen = 1, result = 1;\n        for(int i=1; i<nums.length; i++){\n            len[i] = count[i] = 1;\n            for(int j=0; j<i; j++){\n                if(nums[i] > nums[j]){\n                    if(len[i] == len[j]+1) count[i] += count[j];\n                    else if(len[i] < len[j]+1) {\n                        len[i] = len[j]+1;\n                        count[i] = count[j];\n                    }\n                }\n            }\n            if(maxLen == len[i]) result += count[i];\n            else if(maxLen < len[i]) {\n                maxLen = len[i];\n                result = count[i];\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 324. Wiggle Sort II\n- [Link](https://leetcode.com/problems/wiggle-sort-ii/)\n- Tags: Sort\n- Stars: 3\n\n#### sort and reverse, O(nlogn) time \nThis solution can be optimized by virtual indexing! \n\n[Explanation/Proof for the correctness](https://leetcode.com/problems/wiggle-sort-ii/discuss/77678/3-lines-Python-with-Explanation-Proof)\n```java\nclass Solution {\n    public void wiggleSort(int[] nums) {\n        if(nums.length == 0) return ;\n        int[] copy = nums.clone();\n        Arrays.sort(copy);\n        int l = (nums.length-1)/2, r = nums.length-1;\n        int i=0;\n        while(i<nums.length){\n            nums[i++] = copy[l--];\n            if(r==(nums.length-1)/2) break;\n            nums[i++] = copy[r--];\n        }\n    }\n}\n```\n\n### 42. Trapping Rain Water\n- [Link](https://leetcode.com/problems/trapping-rain-water/)\n- Tags: Array, Two Pointers, Stack\n- Stars: 3\n\n#### My Solution, O(n) time, O(1) space\n1. Iterate `height` from left to right: each iteration, check if height[i] is the highest height (higher than `currHeight`). If true, count the volume of water between `currIdx`(i.e. the index of the currHeight position) and `i`. \n2. The iterations above fail to account for water after the last highest height. Therefore, do the same thing from right to left again. \n```java\nclass Solution {\n    public int trap(int[] height) {\n        if(height.length < 2) return 0;\n        int currHeight = 0, currIdx = 0, result = 0;\n        // Iterate from left to right\n        for(int i=0; i<height.length; i++){\n            if(height[i] >= currHeight){\n                for(int j=currIdx+1; j<i; j++)\n                    result += currHeight-height[j];\n                currHeight = height[i];\n                currIdx = i;\n            }\n        }\n        int midIdx = currIdx, midHeight=currHeight;\n        currHeight = 0; currIdx = height.length-1;\n        // Iterate from right to left\n        for(int i=height.length-1; i>=midIdx; i--){\n            if(height[i] >= currHeight){\n                for(int j=i+1; j<currIdx; j++)\n                    result += currHeight-height[j];\n                currHeight = height[i];\n                currIdx = i;\n            }\n            if(height[i] == midHeight) break;\n        }\n        return result;\n    }\n}\n```\n\n#### one-pass solution, O(n) time, O(1) space\nTwo pointers!  \nIf height[i] <= height[j], there are only two situations:  \n1) height[i] is the highest in subarray from 0 to i. For this situation, the `result` remains unchanged.  \n2) height[i] is not the highest from left, there must be water above it, and the height of water above height[i] should be `maxLeftHeight - height[i]`. \n```java\nclass Solution {\n    public int trap(int[] height) {\n        if(height.length < 2) return 0;\n        int i=0, j=height.length-1;\n        int result = 0, maxLeftHeight = 0, maxRightHeight = 0;\n        while(i<=j){\n            if(height[i] <= height[j]){\n                if(maxLeftHeight < height[i]) maxLeftHeight = height[i];\n                result += maxLeftHeight-height[i];\n                i++;\n            }\n            else {\n                if(maxRightHeight < height[j]) maxRightHeight = height[j];\n                result += maxRightHeight-height[j];\n                j--;\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 128. Longest Consecutive Sequence\n- [Link](https://leetcode.com/problems/longest-consecutive-sequence/)\n- Tags: Array, Union Find\n- Stars: 3\n\n#### union find based on HashMap, only beats 27.49% in time and 34.14% in space\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length == 0) return 0;\n        HashMap<Integer, Integer> uf = new HashMap<>();\n        HashMap<Integer, Integer> lens = new HashMap<>();\n        for(int num: nums){\n            if(uf.containsKey(num)) continue;\n            uf.put(num, num);\n            lens.put(num, 1);\n            if(uf.get(num-1)!=null) union(uf, lens, num, num-1);\n            if(uf.get(num+1)!=null) union(uf, lens, num, num+1);\n        }\n        int result = 0;\n        for(int num: nums)\n            if(uf.get(num) == num && result < lens.get(num)) result = lens.get(num);\n        return result;\n    }\n    private void union(HashMap<Integer, Integer> uf, HashMap<Integer, Integer> lens,\n                       int a, int b){\n        int roota = find(uf, a), rootb = find(uf, b);\n        if(roota==rootb) return ;\n        if(lens.get(roota) <= lens.get(rootb)){\n            uf.put(roota, rootb);\n            lens.put(rootb, lens.get(roota)+lens.get(rootb));\n        }\n        else {\n            uf.put(rootb, roota);\n            lens.put(roota, lens.get(roota)+lens.get(rootb));\n        }\n    }\n    private int find(HashMap<Integer, Integer> uf, int a){\n        while(uf.get(a) != a){\n            int b = uf.get(a);\n            uf.put(a, uf.get(b));\n            a = b;\n        }\n        return a;\n    }\n}\n```\n\n#### only the boundaries, real O(n) time, beats 90.75% in time\nThe tricky part was to understand why only the boundaries need to be updated and not the entire sequence with the new sum.\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length == 0) return 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int result = 0;\n        for(int num: nums){\n            if(map.containsKey(num)) continue;\n            // get left and right sequence length\n            int leftLen = map.getOrDefault(num-1, 0);\n            int rightLen = map.getOrDefault(num+1, 0);\n            map.put(num, leftLen+rightLen+1);\n            // update the return value `result`\n            result = Math.max(result, leftLen+rightLen+1);\n            // we only need to udpate the ends of a sequence\n            if(leftLen>0) map.put(num-leftLen, leftLen+rightLen+1);\n            if(rightLen>0) map.put(num+rightLen, leftLen+rightLen+1);\n        }\n        return result;\n    }\n}\n```\n\n#### GENIUS!!\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        HashSet<Integer> set = new HashSet<>();\n        for(int num : nums) set.add(num);\n        int result = 0;\n        for(int num: set){\n            if(set.contains(num-1)) continue;\n            int idx = num+1, count = 1;\n            while(set.contains(idx)){\n                count++;\n                idx++;\n            }\n            if(result < count) result = count;\n        }\n        return result;\n    }\n}\n```\n\n### 329. Longest Increasing Path in a Matrix\n- [Link](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)\n- Tags: DFS, Topological Sort, Memoization\n- Stars: 3\n\n#### My solution, DFS+Memoization, only beats 18% in time\n1. borrowed idea from 128#GENIUS!! where only starts from the smaller side to avoid bi-direction checks. That's why I use `isMin` instead of `isMinMax`. `isMin` is a function to check whether an element in `matrix` is the minimum compared to its surrounding neighbors. \n2. Use DFS to get the longest increasing path starting from a local minimum. \n3. Need to record all the intermediate outcomes to avoid waste of computation. (Memoization) \n```java\nclass Solution {\n    int[][] record;\n    public int longestIncreasingPath(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0) return 0;\n        record = new int[matrix.length][matrix[0].length];\n        boolean[][] mark = new boolean[matrix.length][matrix[0].length];\n        int result = 0;\n        for(int i=0; i<matrix.length; i++)\n            for(int j=0; j<matrix[0].length; j++){\n                if(!isMin(matrix, i, j)) continue;\n                int temp = DFS(matrix, mark, i, j);\n                if(result < temp) result = temp;\n            }\n        return result;\n    }\n    private int DFS(int[][] matrix, boolean[][] mark, int i, int j){\n        if(i<0 || j<0 || i>= matrix.length || j>= matrix[0].length) return 0;\n        if(record[i][j] > 0) return record[i][j];\n        mark[i][j] = true;\n        int result = 1;\n        if(i-1>=0 && matrix[i-1][j] > matrix[i][j]) \n            result = Math.max(result, 1+DFS(matrix, mark, i-1, j));\n        if(i+1<matrix.length && matrix[i+1][j] > matrix[i][j]) \n            result = Math.max(result, 1+DFS(matrix, mark, i+1, j));\n        if(j-1>=0 && matrix[i][j-1] > matrix[i][j]) \n            result = Math.max(result, 1+DFS(matrix, mark, i, j-1));\n        if(j+1<matrix[0].length && matrix[i][j+1] > matrix[i][j]) \n            result = Math.max(result, 1+DFS(matrix, mark, i, j+1));\n        mark[i][j] = false;\n        record[i][j] = result;\n        return result;\n    }\n    private boolean isMin(int[][] matrix, int i, int j){\n        boolean result = true;\n        if(i-1>=0 && matrix[i-1][j] < matrix[i][j]) return false;\n        if(i+1<matrix.length && matrix[i+1][j] < matrix[i][j]) return false;\n        if(j-1>=0 && matrix[i][j-1] < matrix[i][j]) return false;\n        if(j+1<matrix[0].length && matrix[i][j+1] < matrix[i][j]) return false;\n        return true;\n    }\n}\n```\n\n#### optimized DFS, beats 98% in time\n1. compared with the first solution, I find that don't actually need `isMin` method. \n2. I can use a static final `directions` to indicate all the possible four directions, instead of hard coding the four directions like the solution above. \n3. the `mark` boolean array can be discarded, as the `record` has already contains the information. \n```java\nclass Solution {\n    public int[][] record;\n    public final static int[][] directions = {{0,1},{0,-1},{1,0},{-1,0}};\n    public int longestIncreasingPath(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0) return 0;\n        record = new int[matrix.length][matrix[0].length];\n        int result = 0;\n        for(int i=0; i<matrix.length; i++)\n            for(int j=0; j<matrix[0].length; j++){\n                int temp = DFS(matrix, i, j);\n                if(result < temp) result = temp;\n            }\n        return result;\n    }\n    private int DFS(final int[][] matrix, final int i, final int j){\n        // if(i<0 || j<0 || i>= matrix.length || j>= matrix[0].length) return 0;\n        if(record[i][j] != 0) return record[i][j];\n        int result = 1;\n        for(int[] direction : directions){\n            int x = i+direction[0], y = j+direction[1];\n            if(x>=0 && y>=0 && x<matrix.length && y<matrix[0].length \n               && matrix[x][y] > matrix[i][j])\n                result = Math.max(result, 1+DFS(matrix, x, y));\n        }\n        record[i][j] = result;\n        return result;\n    }\n}\n```\n\n#### Topological Sort\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/78336/Graph-theory-Java-solution-O(v2)-no-DFS\n\n### 315. Count of Smaller Numbers After Self\n- [Link](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)\n- Tags: Divide and Conquer, Binary Indexed Tree, Segment Tree, Binary Search Tree\n- Stars: 3\n\n#### lower bound binary search insertion, O(nlogn) time and O(n) space. \ninsert the elements of `nums` into `order` one by one from tail to head. \n```java\nclass Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        if(nums.length == 0) return result;\n        List<Integer> order = new ArrayList<>();\n        result.add(0);\n        order.add(nums[nums.length-1]);\n        for(int i=nums.length-2; i>=0; i--){\n            int idx = binarySearch(order, nums[i]);\n            if(idx<0) idx = -(idx+1);\n            result.add(0, idx);\n            order.add(idx, nums[i]);\n        }\n        return result;\n    }\n    private int binarySearch(List<Integer> list, int target){\n        int l=0, r=list.size()-1;\n        while(l+1 < r){\n            int mid = l+((r-l)>>1);\n            if(list.get(mid) >= target) r = mid;\n            else l = mid;\n        }\n        if(list.get(l) >= target) return l;\n        if(list.get(r) >= target) return r;\n        return r+1;\n    }\n}\n```\n\n### 239. Sliding Window Maximum\n- [Link](https://leetcode.com/problems/sliding-window-maximum/)\n- Tags: Heap, Sliding Window\n- Stars: 3\n\n#### My solution, MaxQueue\nMaxQueue is implemented by two MaxStack.\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length == 0) return new int[0];\n        MaxQueue qu = new MaxQueue();\n        int[] result = new int[nums.length-k+1];\n        int p = 0;\n        for(int i=0; i<nums.length; i++){\n            qu.add(nums[i]);\n            if(qu.size() == k){\n                result[p++] = qu.getMax();\n                qu.pop();\n            }\n        }\n        return result;\n    }\n}\nclass MaxQueue {\n    public MaxStack st1 = new MaxStack(), st2 = new MaxStack();\n    public void add(int x){\n        st1.add(x);\n    }\n    public int size(){\n        return st1.size() + st2.size();\n    }\n    public int pop(){\n        if(st2.isEmpty()){\n            assert !st1.isEmpty();\n            while(!st1.isEmpty()){\n                st2.add(st1.pop());\n            }\n        }\n        return st2.pop();\n    }\n    public int getMax(){\n        return Math.max(st1.getMax(), st2.getMax());\n    }\n}\nclass MaxStack {\n    public Stack<Integer> st = new Stack(), maxSt = new Stack();\n    public int maxVal = Integer.MIN_VALUE;\n    public void add(int x){\n        if(maxVal < x) maxVal = x;\n        maxSt.add(maxVal);\n        st.add(x);\n    }\n    public int size(){\n        return st.size();\n    }\n    public boolean isEmpty(){\n        return st.isEmpty();\n    }\n    public int pop(){\n        maxSt.pop();\n        maxVal = maxSt.size() == 0 ? Integer.MIN_VALUE : maxSt.peek();\n        return st.pop();\n    }\n    public int getMax(){\n        return maxVal;\n    }\n}\n```\n\n### 295. Find Median from Data Stream\n- [Link](https://leetcode.com/problems/find-median-from-data-stream/)\n- Tags: Heap, Design\n- Stars: 2\n\n#### lower bound binary search insertion\n```java\nclass MedianFinder {\n    List<Integer> list;\n    public MedianFinder() {\n        list = new ArrayList<>();\n    }\n    public void addNum(int num) {\n        int idx = binarySearch(list, num);\n        list.add(idx, num);\n    }\n    public double findMedian() {\n        if(list.size()%2 == 1) return (double)list.get(list.size()/2);\n        return (list.get(list.size()/2)+list.get(list.size()/2-1))/2.0;\n    }\n    private int binarySearch(List<Integer> list, int target){\n        if(list.size() == 0) return 0;\n        int l=0, r=list.size()-1;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            if(list.get(mid) >= target) r = mid-1;\n            else l = mid + 1;\n        }\n        if(list.get(l) >=target) return l;\n        return l+1;\n    }\n}\n```\n\n#### minHeap and maxHeap\n```java\nclass MedianFinder {\n    PriorityQueue<Integer> maxHeap;\n    PriorityQueue<Integer> minHeap;\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\n        minHeap = new PriorityQueue<>();\n    }\n    public void addNum(int num) {\n        if(maxHeap.isEmpty() || maxHeap.peek() >= num) maxHeap.add(num);\n        else minHeap.add(num);\n        while(maxHeap.size() < minHeap.size())\n            maxHeap.add(minHeap.poll());\n        while(maxHeap.size()-1 > minHeap.size())\n            minHeap.add(maxHeap.poll());\n    }\n    public double findMedian() {\n        if(maxHeap.size() == minHeap.size()) return (maxHeap.peek()+minHeap.peek())/2.0;\n        return (double)maxHeap.peek();\n    }\n}\n```\n\n### 23. Merge k Sorted Lists\n- [Link](https://leetcode.com/problems/merge-k-sorted-lists/)\n- Tags: Linked List, Divide and Conquer, Heap\n- Stars: 2\n\n#### minHeap, 41ms\n```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        ListNode head = new ListNode(0), curr = head;\n        PriorityQueue<Tuple> qu = new PriorityQueue<>(\n            (tup1, tup2) -> (tup1.node.val-tup2.node.val));\n        for(int i=0; i<lists.length; i++){\n            if(lists[i] != null){\n                qu.add(new Tuple(i, lists[i]));\n                lists[i] = lists[i].next;\n            }\n        }\n        while(!qu.isEmpty()){\n            Tuple tup = qu.poll();\n            curr.next = tup.node;\n            curr = curr.next;\n            if(lists[tup.idx] != null){\n                qu.add(new Tuple(tup.idx, lists[tup.idx]));\n                lists[tup.idx] = lists[tup.idx].next;\n            }\n        }\n        return head.next;\n    }\n}\nclass Tuple {\n    int idx;\n    ListNode node;\n    public Tuple(int i, ListNode n){\n        idx = i;\n        node = n;\n    }\n}\n```\n\n#### minHeap, simplified version, 9ms\n```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        ListNode head = new ListNode(0), curr = head;\n        PriorityQueue<ListNode> qu = new PriorityQueue<>(new Comparator<ListNode>(){\n            public int compare(ListNode a, ListNode b){\n                return a.val - b.val;\n            }\n        });\n        for(ListNode node : lists)\n            if(node != null) qu.add(node);\n        while(!qu.isEmpty()){\n            curr.next = qu.poll();\n            curr = curr.next;\n            if(curr.next != null) qu.add(curr.next);\n        }\n        return head.next;\n    }\n}\n```\n\n#### divide and conquer, use merge 2 linkedlist, 5ms beats 100% in time\n```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        return mergeKLists(lists, 0, lists.length-1);\n    }\n    public ListNode mergeKLists(ListNode[] lists, int start, int end){\n        if(start == end) return lists[start];\n        int mid = start + ((end-start)>>1);\n        ListNode l1 = mergeKLists(lists, start, mid);\n        ListNode l2 = mergeKLists(lists, mid+1, end);\n        return merge(l1, l2);\n    }\n    private ListNode merge(ListNode l1, ListNode l2){\n        if(l1 == null) return l2;\n        if(l2 == null) return l1;\n        if(l1.val < l2.val){\n            l1.next = merge(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = merge(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n### 124. Binary Tree Maximum Path Sum\n- [Link](https://leetcode.com/problems/binary-tree-maximum-path-sum/)\n- Tags: Tree, DFS\n- Stars: 2\n\n#### DFS, (tree-like) maximum subarray\n```java\nclass Solution {\n    int result = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        if(root == null) return 0;\n        DFS(root);\n        return result;\n    }\n    private int DFS(TreeNode root){\n        if(root == null) return 0;\n        int left = Math.max(0, DFS(root.left)), right = Math.max(0, DFS(root.right));\n        result = Math.max(result, left+right+root.val);\n        return Math.max(left, right)+root.val;\n    }\n}\n```\n\n### 41. First Missing Positive\n- [Link](https://leetcode.com/problems/first-missing-positive/)\n- Tags: Array\n- Stars: 3\n\n#### establish val2index and index2val mapping, O(n) time and O(1) space\n1. ignore all elements that are <= 0 or > nums.length\n2. establish val2index and index2val mapping for the remaining elements. i.e. `val2index[i] = i-1` and `index2val[i] = i+1`. \n3. iterate `nums`. For each num, swap this num to the index that it is supposed to be. \n4. the condition `nums[nums[i]-1] != nums[i]` in the while loop is used to avoid infinite loop caused by duplicates. \n```java\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        if(nums.length == 0) return 1;\n        for(int i=0; i<nums.length; i++){\n            while(nums[i]>0 && nums[i] <= nums.length && \n                  nums[i] != i+1 && nums[nums[i]-1] != nums[i])\n                swap(nums, nums[i]-1, i);\n        }\n        for(int i=0; i<nums.length; i++)\n            if(nums[i] != i+1) return i+1;\n        return nums.length+1;\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n#### O(n) time and O(n) space\nWe only need to mark numbers in [1, nums.length]. \n```java\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        if(nums.length == 0) return 1;\n        boolean[] mark = new boolean[nums.length];\n        for(int num: nums)\n            if(num>0 && num<=nums.length) mark[num-1] = true;\n        for(int i=0; i<mark.length; i++)\n            if(!mark[i]) return i+1;\n        return nums.length+1;\n    }\n}\n```\n\n### 4. Median of Two Sorted Arrays\n- [Link](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n- Tags: Array, Binary Search, Divide and Conquer\n- Stars: 3\n\n#### binary search\nTo avoid boundary check, use \n```\nl1 = mid1 == 0 ? Integer.MIN_VALUE : nums1[mid1-1];\nr1 = mid1 == nums1.length ? Integer.MAX_VALUE : nums1[mid1];\nl2 = mid2 == 0 ? Integer.MIN_VALUE : nums2[mid2-1];\nr2 = mid2 == nums2.length ? Integer.MAX_VALUE : nums2[mid2];\n```\n.\n\n```java\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        // make sure nums1.length >= nums2.length\n        if(nums1.length < nums2.length) return findMedianSortedArrays(nums2, nums1);\n        int l = 0, r = nums1.length;\n        // mid: the index to divide the nums into two parts. range [0, nums.length], (nums.length+1) possible values in total\n        // l1: the value just before mid1 \n        // r1: the value just after mid1 \n        int mid1 = 0, mid2 = 0, l1=0, r1=0, l2=0,  r2=0;\n        while(l<r){\n            mid1 = l + ((r-l)>>1);\n            mid2 = (nums1.length+nums2.length+1)/2 - mid1;\n            if(mid2 > nums2.length) {\n                l = mid1+1;\n                continue;\n            }\n            else if(mid2 < 0){\n                r = mid1-1;\n                continue;\n            }\n            l1 = mid1 == 0 ? Integer.MIN_VALUE : nums1[mid1-1];\n            r1 = mid1 == nums1.length ? Integer.MAX_VALUE : nums1[mid1];\n            l2 = mid2 == 0 ? Integer.MIN_VALUE : nums2[mid2-1];\n            r2 = mid2 == nums2.length ? Integer.MAX_VALUE : nums2[mid2];\n            if(l1 <= r2 && l2<=r1) break;\n            if(l1 > r2) r = mid1 - 1;\n            if(l2 > r1) l = mid1 + 1;\n        }\n        mid1 = l + ((r-l)>>1);\n        mid2 = (nums1.length+nums2.length+1)/2 - mid1;\n        l1 = mid1 == 0 ? Integer.MIN_VALUE : nums1[mid1-1];\n        r1 = mid1 == nums1.length ? Integer.MAX_VALUE : nums1[mid1];\n        l2 = mid2 == 0 ? Integer.MIN_VALUE : nums2[mid2-1];\n        r2 = mid2 == nums2.length ? Integer.MAX_VALUE : nums2[mid2];\n        if((nums1.length+nums2.length)%2==1) return Math.max(l1, l2);\n        return (Math.max(l1, l2) + Math.min(r1, r2))/2.0;\n    }\n}\n```\n\n## Top 100 Liked Questions\n\n### 461. Hamming Distance\n- [Link](https://leetcode.com/problems/hamming-distance/)\n- Tags: Bit Manipulation\n- Stars: 3\n\n#### Java Built-in Function\n```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        return Integer.bitCount(x ^ y);\n    }\n}\n```\n\n#### bit counting by groups\n1. `x = (x&0x55555555) + ((x>>>1)&0x55555555)` can also be written as `x = x - ((x >>> 1) & 0x55555555)`. \n2. The following solution can be further simplified to `i = (i + (i >>> 4)) & 0x0f0f0f0f; i = i + (i >>> 8); i = i + (i >>> 16); return i & 0x3f;`\n```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        x ^= y;\n        x = (x&0x55555555) + ((x>>>1)&0x55555555);\n        x = (x&0x33333333) + ((x>>>2)&0x33333333);\n        x = (x&0x0f0f0f0f) + ((x>>>4)&0x0f0f0f0f);\n        x = (x&0x00ff00ff) + ((x>>>8)&0x00ff00ff);\n        x = (x&0x0000ffff) + ((x>>>16)&0x0000ffff);\n        return x;\n    }\n}\n```\n\n### 448. Find All Numbers Disappeared in an Array\n- [Link](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)\n- Tags: Array\n- Stars: 2\n\n#### O(n) time and O(1) space\nGiven an element, we can calculate the expected index. \n```java\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        for(int i=0; i<nums.length; i++){\n            while(i != nums[i]-1){\n                if(nums[nums[i]-1] == nums[i]) break;\n                swap(nums, i, nums[i]-1);\n            }\n        }\n        for(int i=0; i<nums.length; i++)\n            if(i != nums[i]-1) \n                result.add(i+1);\n        return result;\n    }\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n#### in-place marking, another O(n) time and O(1) space\n```java\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        if(nums.length == 0) return result;\n        // mark the existing numbers: use the existing numbers as index and set it to its opposite number\n        for(int i=0; i<nums.length; i++){\n            int num = Math.abs(nums[i])-1;\n            if(nums[num] > 0) nums[num] = -nums[num];\n        }\n        // iterate through nums array and find all still-positive numbers\n        for(int i=0; i<nums.length; i++)\n            if(nums[i] > 0) result.add(i+1);\n        return result;\n    }\n}\n```\n\n### 538. Convert BST to Greater Tree\n- [Link](https://leetcode.com/problems/convert-bst-to-greater-tree/)\n- Tags: Tree\n- Stars: 1\n\n#### recursive\n```java\nclass Solution {\n    int accu = 0;\n    public TreeNode convertBST(TreeNode root) {\n        if(root == null) return null;\n        convertBST(root.right);\n        accu += root.val;\n        root.val = accu;\n        convertBST(root.left);\n        return root;\n    }\n}\n```\n\n### 543. Diameter of Binary Tree\n- [Link](https://leetcode.com/problems/diameter-of-binary-tree/)\n- Tags: Tree\n- Stars: 1\n\n#### recursive\n1. Found that the two ends of the longest path must be leaf nodes, unless one of the leaf nodes is root. \n2. Given two leaf nodes, the path between them contains their highest-level common parent. \n```java\nclass Solution {\n    int maxLen = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        if(root == null) return 0;\n        DFTraversal(root);\n        return maxLen-1;\n    }\n    private int DFTraversal(TreeNode root) {\n        if(root == null) return 0;\n        int leftLen = DFTraversal(root.left), rightLen = DFTraversal(root.right);\n        int len = 1 + leftLen + rightLen;\n        if(maxLen < len) maxLen = len;\n        return 1 + Math.max(leftLen, rightLen);\n    }\n}\n```\n\n### 437. Path Sum III\n- [Link](https://leetcode.com/problems/path-sum-iii/)\n- Tags: Tree\n- Stars: 3\n\n#### backtracking\n```java\nclass Solution {\n    int result = 0;\n    public int pathSum(TreeNode root, int sum) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        map.put(0, 1);\n        backtrack(root, map, 0, sum);\n        return result;\n    }\n    private void backtrack(TreeNode root, HashMap<Integer, Integer> map, int curr, int sum){\n        if(root == null) return ;\n        curr += root.val;\n        result += map.getOrDefault(curr-sum, 0);\n        map.put(curr, map.getOrDefault(curr, 0)+1);\n        backtrack(root.left, map, curr, sum);\n        backtrack(root.right, map, curr, sum);\n        map.put(curr, map.get(curr)-1);\n    }\n}\n```\n\n### 572. Subtree of Another Tree\n- [Link](https://leetcode.com/problems/subtree-of-another-tree/)\n- Tags: Tree\n- Stars: 2\n\n#### recursive\nATTENTION: `isSubtree` and `isEqual` are different DFS process. Do not try to integrate into a single function.\n```java\nclass Solution {\n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        if(s == null) return false;\n        if(isEqual(s, t)) return true;\n        return isSubtree(s.left, t) || isSubtree(s.right, t);\n    }\n    private boolean isEqual(TreeNode a, TreeNode b){\n        if(a == null || b==null){\n            if(a==null && b==null) return true;\n            return false;\n        }\n        if(a.val != b.val) return false;\n        return isEqual(a.left, b.left) && isEqual(a.right, b.right);\n    }\n}\n```\n\n### 96. Unique Binary Search Trees\n- [Link](https://leetcode.com/problems/unique-binary-search-trees/)\n- Tags: Dynamic Programming, Tree\n- Stars: 2\n\n#### DP, double 100%\nAn additional node n only has two directions available for connection:\n```\n(subtree a)\n        \\\n         (node n)\n        /\n(subtree b)\n```\nSubtree a and b together contains all the nodes from 1 to n-1, and all the nodes in subtree a must be smaller than any node of subtree b. \nFor each possible combination of subtree a and b, the additional node n brings about `f(#nodes of a) * f(#nodes of b)` additional unique BSTs. \nTherefore, the DP formula is `f(n) = sum([f(i) * f(n-1-i) for i in range(0, n)])`\n\n```java\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<=i; j++) {\n                dp[i+1] += dp[j] * dp[i-j];\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n### 438. Find All Anagrams in a String\n- [Link](https://leetcode.com/problems/find-all-anagrams-in-a-string/)\n- Tags: Hash Table\n- Stars: 1\n\n#### sliding window\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        if(s.length() < p.length()) return result;\n        int[] pattern = getPattern(p, 0, p.length());\n        int[] stat = getPattern(s, 0, p.length()-1);\n        int i=0;\n        while(true){\n            if(i + p.length() - 1 == s.length()) break;\n            stat[s.charAt(i + p.length()-1)-'a']++;\n            if(isSame(stat, pattern)) result.add(i);\n            stat[s.charAt(i)-'a']--;\n            i++;\n        }\n        return result;\n    }\n    private int[] getPattern(String s, int start, int end){\n        int[] pattern = new int[26];\n        for(int i=start; i<end; i++)\n            pattern[s.charAt(i)-'a']++;\n        return pattern;\n    }\n    private boolean isSame(int[] a, int[] b){\n        for(int i=0; i<26; i++)\n            if(a[i] != b[i]) return false;\n        return true;\n    }\n}\n```\n\n### 20. Valid Parentheses\n- [Link](https://leetcode.com/problems/valid-parentheses/)\n- Tags: String, Stack\n- Stars: 1\n\n#### stack\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        if(s.length() == 0) return true;\n        Stack<Character> st = new Stack<>();\n        for(int i=0; i<s.length(); i++){\n            if(s.charAt(i) == '(') st.add(')');\n            else if(s.charAt(i) == '[') st.add(']');\n            else if(s.charAt(i) == '{') st.add('}');\n            else {\n                if(st.isEmpty() || (char)(st.pop()) != s.charAt(i)) return false;\n            }\n        }\n        return st.size() == 0;\n    }\n}\n```\n\n### 581. Shortest Unsorted Continuous Subarray\n- [Link](https://leetcode.com/problems/shortest-unsorted-continuous-subarray/)\n- Tags: Array\n- Stars: 3\n\n#### my solution, sort and compare, O(nlogn) time and O(n) space, suboptimal\n```java\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] copy = Arrays.copyOfRange(nums, 0, nums.length);\n        Arrays.sort(copy);\n        int i=0, j=nums.length-1;\n        while(i<j && nums[i] == copy[i]) i++;\n        while(i<j && nums[j] == copy[j]) j--;\n        if(i == j) return 0;\n        return j-i+1;\n    }\n}\n```\n\n#### my solution, binary search\n```java\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        if(nums.length == 0) return 0;\n        int i=0, j=nums.length-1;\n        // skip the ordered subarray started from head. \n        while(i<j && nums[i] <= nums[i+1]) i++;\n        // go left to ensure all duplicates of nums[i] has an index >= i. \n        if(i == j) return 0;\n        else while(i>0 && nums[i-1] == nums[i]) i--;\n        // skip the ordered subarray ended with tail. \n        while(i<j && nums[j-1] <= nums[j]) j--;\n        // go right to ensure all duplicates of nums[j] has an index <= j. \n        if(i == j) return 0;\n        else while(j<nums.length-1 && nums[j+1] == nums[j]) j++;\n        // get the minVal and maxVal of subarray between i and j\n        int minVal = nums[i], maxVal = nums[j];\n        for(int k=i; k<=j; k++){\n            if(minVal > nums[k]) minVal = nums[k];\n            if(maxVal < nums[k]) maxVal = nums[k];\n        }\n        // find idx s.t. all elements in nums[0:idx] are < minVal\n        // notice we set target of binary search to minVal+1 instead of minVal\n        int minIdx = Arrays.binarySearch(nums, 0, i, minVal+1);\n        if(minIdx < 0) minIdx = -(minIdx+1);\n        // find idx s.t. all elements in nums[idx:] are >= maxVal\n        int maxIdx = Arrays.binarySearch(nums, j+1, nums.length, maxVal);\n        if(maxIdx < 0) maxIdx = -(maxIdx+1);\n        return maxIdx - minIdx;\n    }\n}\n```\n\n#### GENIUS!!\n```java\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        if(nums.length == 0) return 0;\n        int start=-1, end=-2, currMax = nums[0], currMin = nums[nums.length-1];\n        for(int i=0; i<nums.length; i++){\n            currMax = Math.max(currMax, nums[i]);\n            if(currMax > nums[i]) end = i;\n            currMin = Math.min(currMin, nums[nums.length-i-1]);\n            if(currMin < nums[nums.length-i-1]) start = nums.length-i-1;\n        }\n        return end-start+1;\n    }\n}\n```\n\n## Others\n\n### 129. Sum Root to Leaf Numbers\n- [Link](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\n- Tags: Tree, DFS\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    int result = 0;\n    public int sumNumbers(TreeNode root) {\n        if(root == null) return 0;\n        DFS(root, 0);\n        return result;\n    }\n    public void DFS(TreeNode root, int curr){\n        curr *= 10;\n        curr += root.val;\n        if(root.left == null && root.right == null){\n            result += curr;\n            return ;\n        }\n        if(root.left != null) DFS(root.left, curr);\n        if(root.right != null) DFS(root.right, curr);\n    }\n}\n```\n\n## First 300 Questions\n\n### 292. Nim Game\n- [Link](https://leetcode.com/problems/nim-game/)\n- Tags: Brainteaser, Minimax\n- Stars: 2\n\n#### Math solution\n1. n might be very big. Thus, DP solutions doesn't work (for the reason that O(n) time is too slow). \n2. try to write down several answers for small n:  \n`  n = 1 2 3 4 5 6 7 8 9 ...`  \n`ans = t t t f t t t f t ...`  \nWe can see that the answers repeated in a `t t t f` pattern. Actually, the DP formula is  \n`dp[i] = !dp[i-1] || !dp[i-2] || !dp[i-3]`. \n\n```java\nclass Solution {\n    public boolean canWinNim(int n) {\n        return n%4!=0;\n    }\n}\n```\n\n### 258. Add Digits\n- [Link](https://leetcode.com/problems/add-digits/)\n- Tags: Math\n- Stars: 3\n\n#### Math Solution\nFor num > 0, the possible answer is 1,2,3,4,5,6,7,8,9. These answers occur periodically as num increases. \n\n**For this kinds of questions, if you don't have any idea at first glance, try to write several answers for simple input cases to see if you can find something useful.** \n\n```java\nclass Solution {\n    public int addDigits(int num) {\n        if(num == 0) return 0;\n        return num%9 == 0 ? 9 : num%9;\n    }\n}\n```\n\n### 171. Excel Sheet Column Number\n- [Link](https://leetcode.com/problems/excel-sheet-column-number/)\n- Tags: Math\n- Stars: 1\n\n#### O(n) time\n```java\nclass Solution {\n    public int titleToNumber(String s) {\n        int result = 0;\n        for(char c : s.toCharArray()){\n            result *= 26;\n            result += c - 'A' + 1;\n        }\n        return result;\n    }\n}\n```\n\n### 108. Convert Sorted Array to Binary Search Tree\n- [Link](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\n- Tags: Tree, DFS\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return sortedArrayToBST(nums, 0, nums.length-1);\n    }\n    public TreeNode sortedArrayToBST(int[] nums, int l, int r) {\n        if(l > r) return null;\n        int mid = l + ((r-l)>>1);\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = sortedArrayToBST(nums, l, mid-1);\n        root.right = sortedArrayToBST(nums, mid+1, r);\n        return root;\n    }\n}\n```\n\n### 107. Binary Tree Level Order Traversal II\n- [Link](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)\n- Tags: Tree, BFS\n- Stars: 1\n\n#### BFS + level-count\n```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        Queue<TreeNode> qu = new LinkedList<>();\n        qu.add(root);\n        int count = 1;\n        List<Integer> layer = new ArrayList<>();\n        while(!qu.isEmpty()){\n            TreeNode node = qu.poll();\n            count--;\n            if(node.left != null) qu.add(node.left);\n            if(node.right != null) qu.add(node.right);\n            layer.add(node.val);\n            if(count == 0){\n                count = qu.size();\n                result.add(layer);\n                layer = new ArrayList<>();\n            }\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n```\n\n#### BFS\n```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        DFS(result, root, 0);\n        Collections.reverse(result);\n        return result;\n    }\n    public void DFS(List<List<Integer>> result, TreeNode root, int level) {\n        if(result.size() < level+1) result.add(new ArrayList<>());\n        result.get(level).add(root.val);\n        if(root.left != null) DFS(result, root.left, level+1);\n        if(root.right != null) DFS(result, root.right, level+1);\n    }\n}\n```\n\n### 257. Binary Tree Paths\n- [Link](https://leetcode.com/problems/binary-tree-paths/)\n- Tags: Tree, DFS\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        if(root == null) return result;\n        backtrack(result, root, \"\");\n        return result;\n    }\n    private void backtrack(List<String> result, TreeNode root, String curr){\n        curr += curr.length() == 0 ? root.val : \"->\"+root.val;\n        if(root.left == null && root.right == null){\n            result.add(curr);\n            return ;\n        }\n        if(root.left != null) backtrack(result, root.left, curr);\n        if(root.right != null) backtrack(result, root.right, curr);\n    }\n}\n```\n\n#### DFS + StringBuilder\n```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        if(root == null) return result;\n        backtrack(result, root, new StringBuilder());\n        return result;\n    }\n    private void backtrack(List<String> result, TreeNode root, StringBuilder sb){\n        int start = sb.length();\n        sb.append(sb.length() == 0? root.val : \"->\" + root.val);\n        if(root.left == null && root.right == null){\n            result.add(sb.toString());\n        }\n        else {\n            if(root.left != null) backtrack(result, root.left, sb);\n            if(root.right != null) backtrack(result, root.right, sb);\n        }\n        sb.delete(start, sb.length());\n    }\n}\n```\n\n### 118. Pascal's Triangle\n- [Link](https://leetcode.com/problems/pascals-triangle/)\n- Tags: Array\n- Stars: 1\n\n#### iterative adding row by row, beats 100% 100%!\n```java\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(numRows == 0) return result;\n        List<Integer> layer = new ArrayList<>();\n        layer.add(1);\n        result.add(layer);\n        for(int level = 2; level <= numRows; level++){\n            List<Integer> newLayer = new ArrayList<>();\n            newLayer.add(1);\n            for(int i=0; i<layer.size()-1; i++)\n                newLayer.add(layer.get(i) + layer.get(i+1));\n            newLayer.add(1);\n            result.add(newLayer);\n            layer = newLayer;\n        }\n        return result;\n    }\n}\n```\n\n### 27. Remove Element\n- [Link](https://leetcode.com/problems/remove-element/)\n- Tags: Array, Two Pointers\n- Stars: 1\n\n#### remove and swap with the last element, beats 100% in time\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        if(nums.length == 0) return 0;\n        int i=0, j = nums.length-1;\n        while(i<=j){\n            if(nums[i] != val) i++;\n            else swap(nums, i, j--);\n        }\n        return j+1;\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n\n#### similar to [283. Move Zeroes](#283. Move Zeroes), keeps nums in order\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int p = 0;\n        for(int i=0; i<nums.length; i++)\n            if(nums[i] != val) nums[p++] = nums[i];\n        return p;\n    }\n}\n```\n\n### 119. Pascal's Triangle II\n- [Link](https://leetcode.com/problems/pascals-triangle-ii/)\n- Tags: Array\n- Stars: 2\n\n#### ArrayList insert\n```java\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> result = new ArrayList<>();\n        result.add(1);\n        for(int i=1; i<=rowIndex; i++){\n            result.add(0, 0);\n            for(int j=0; j<result.size()-1; j++)\n                result.set(j, result.get(j) + result.get(j+1));\n        }\n        return result;\n    }\n}\n```\n\n#### Faster solution\nAvoid inserting elements into the head during iteration. \n```java\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        Integer[] result = new Integer[rowIndex+1];\n        result[rowIndex] = 1;\n        for(int i=rowIndex-1; i>=0; i--){\n            for(int j=i; j<rowIndex; j++)\n                result[j] = result[j] == null? result[j+1] : result[j] + result[j+1];\n        }\n        return Arrays.asList(result);\n    }\n}\n```\n\n### 232. Implement Queue using Stacks\n- [Link](https://leetcode.com/problems/implement-queue-using-stacks/)\n- Tags: Stack, Design\n- Stars: 1\n\n#### two stacks\n```java\nimport java.util.EmptyStackException;\nclass MyQueue {\n    Stack<Integer> st1, st2;\n    public MyQueue() {\n        st1 = new Stack<>();\n        st2 = new Stack<>();\n    }    \n    public void push(int x) {\n        st1.add(x);\n    }\n    public int pop() {\n        if(st2.isEmpty()){\n            if(st1.isEmpty()) throw new EmptyStackException();\n            while(!st1.isEmpty()) st2.add(st1.pop());\n        }\n        return st2.pop();\n    }\n    public int peek() {\n        if(st2.isEmpty()){\n            if(st1.isEmpty()) throw new EmptyStackException();\n            while(!st1.isEmpty()) st2.add(st1.pop());\n        }\n        return st2.peek();\n    }\n    public boolean empty() {\n        return st1.isEmpty() && st2.isEmpty();\n    }\n}\n ```\n\n### 191. Number of 1 Bits\n- [Link](https://leetcode.com/problems/number-of-1-bits/)\n- Tags: Bit Manipulation\n- Stars: 1\n\n#### bit manipulation, beats 100% time and 100% space\n```java\npublic class Solution {\n    public int hammingWeight(int n) {\n        n = (n&0x55555555) + ((n&0xAAAAAAAA)>>>1);\n        n = (n&0x33333333) + ((n&0xCCCCCCCC)>>>2);\n        n = (n&0x0F0F0F0F) + ((n&0xF0F0F0F0)>>>4);\n        n = (n&0x00FF00FF) + ((n&0xFF00FF00)>>>8);\n        n = (n&0x0000FFFF) + ((n&0xFFFF0000)>>>16);\n        return n;\n    }\n}\n```\n\n### 83. Remove Duplicates from Sorted List\n- [Link](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\n- Tags: Linked List\n- Stars: 1\n\n#### O(n) time\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head == null) return null;\n        ListNode curr = head;\n        while(curr.next != null){\n            if(curr.next.val == curr.val) curr.next = curr.next.next;\n            else curr = curr.next;\n        }\n        return head;\n    }\n}\n```\n\n### 231. Power of Two\n- [Link](https://leetcode.com/problems/power-of-two/)\n- Tags: Math, Bit Manipulation\n- Stars: 1\n- References: https://leetcode.com/problems/power-of-two/discuss/63966/4-different-ways-to-solve-Iterative-Recursive-Bit-operation-Math\n\n#### math\nRefer to [Power of Three](#326-power-of-three)\n```java\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        return (n > 0) && (1073741824%n == 0);\n    }\n}\n```\n\n#### bit manipulation\n```java\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        return (n>0) && (n&(n-1)) == 0;\n    }\n}\n```\n\n### 35. Search Insert Position\n- [Link](https://leetcode.com/problems/search-insert-position/)\n- Tags: Array, Binary Search\n- Stars: 1\n\n#### lower bound binary search insertion\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0, r = nums.length;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            if(nums[mid] == target) return mid;\n            else if(nums[mid] < target) l = mid+1;\n            else r = mid;\n        }\n        return l;\n    }\n}\n```\n\n### 110. Balanced Binary Tree\n- [Link](https://leetcode.com/problems/balanced-binary-tree/)\n- Tags: Tree, DFS\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    boolean result = true;\n    public boolean isBalanced(TreeNode root) {\n        DFS(root);\n        return result;\n    }\n    private int DFS(TreeNode root){\n        if(root == null) return 0;\n        int left = DFS(root.left), right = DFS(root.right);\n        if(Math.abs(left-right) > 1) result = false;\n        return 1 + Math.max(left, right);\n    }\n}\n```\n\n#### another DFS (without environmental variable)\n```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return DFS(root) != -1;\n    }\n    private int DFS(TreeNode root){\n        if(root == null) return 0;\n        int left = DFS(root.left);\n        if(left == -1) return -1;\n        int right = DFS(root.right);\n        if(right == -1) return -1;\n        if(Math.abs(left-right) > 1) return -1;\n        return 1 + Math.max(left, right);\n    }\n}\n```\n\n### 263. Ugly Number\n- [Link](https://leetcode.com/problems/ugly-number/)\n- Tags: Math\n- Stars: 1\n\n#### divide\n```java\nclass Solution {\n    public boolean isUgly(int num) {\n        if(num == 0) return false;\n        while(num != 0 && num % 2 == 0) num /= 2;\n        while(num != 0 && num % 3 == 0) num /= 3;\n        while(num != 0 && num % 5 == 0) num /= 5;\n        return num == 1 || num == 0;\n    }\n}\n```\n\n### 26. Remove Duplicates from Sorted Array\n- [Link](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n- Tags: Array, Two Pointers\n- Stars: 1\n\n#### two pointers\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int i=0;\n        for(int num: nums){\n            if(i>0 && nums[i-1] == num) continue;\n            nums[i++] = num;\n        }\n        return i;\n    }\n}\n```\n\n### 38. Count and Say\n- [Link](https://leetcode.com/problems/count-and-say/)\n- Tags: String\n- Stars: 1\n\n#### iterative\n```java\nclass Solution {\n    public String countAndSay(int n) {\n        String s = \"1\";\n        if(n == 1) return s;\n        for(int i=2; i<=n; i++)\n            s = getNextString(s);\n        return s;\n    }\n    private String getNextString(String s){\n        StringBuilder sb = new StringBuilder();\n        int i=0, j=0;\n        for(; j<s.length(); j++){\n            if(j == i || s.charAt(i) == s.charAt(j)) continue;\n            sb.append(j-i);\n            sb.append(s.charAt(i));\n            i = j;\n        }\n        sb.append(j-i);\n        sb.append(s.charAt(i));\n        return sb.toString();\n    }\n}\n```\n\n### 225. Implement Stack using Queues\n- [Link](https://leetcode.com/problems/implement-stack-using-queues/)\n- Tags: Stack, Design\n- Stars: 1\n\n#### one queue\n```java\nclass MyStack {\n    Queue<Integer> qu;\n    public MyStack() {\n        qu = new LinkedList<>();\n    }\n    public void push(int x) {\n        qu.add(x);\n    }\n    public int pop() {\n        Queue<Integer> temp = new LinkedList<>();\n        while(qu.size() > 1) temp.add(qu.poll());\n        int result = qu.poll();\n        qu = temp;\n        return result;\n    }\n    public int top() {\n        int temp = pop();\n        qu.add(temp);\n        return temp;\n    }\n    public boolean empty() {\n        return qu.isEmpty();\n    }\n}\n```\n\n#### another one queue solution\n```java\nclass MyStack {\n    Queue<Integer> qu;\n    public MyStack() {\n        qu = new LinkedList<>();\n    }\n    public void push(int x) {\n        qu.add(x);\n        for(int i=0; i<qu.size()-1; i++)\n            qu.add(qu.poll());\n    }\n    public int pop() {\n        return qu.poll();\n    }\n    public int top() {\n        return qu.peek();\n    }\n    public boolean empty() {\n        return qu.isEmpty();\n    }\n}\n```\n\n### 67. Add Binary\n- [Link](https://leetcode.com/problems/add-binary/)\n- Tags: Math, String\n- Stars: 1\n\n#### StringBuilder\n```java\nclass Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder sb = new StringBuilder();\n        int i = a.length()-1, j = b.length()-1, carry = 0;\n        while(i>=0 || j>=0){\n            if(i>=0) carry += a.charAt(i--)-'0';\n            if(j>=0) carry += b.charAt(j--)-'0';\n            sb.insert(0, carry&1);\n            carry >>= 1;\n        }\n        while(carry > 0) {\n            sb.insert(0, carry&1);\n            carry >>= 1;\n        }\n        return sb.toString();\n    }\n}\n```\n\n### 112. Path Sum\n- [Link](https://leetcode.com/problems/path-sum/)\n- Tags: Tree, DFS\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null) return false;\n        if(root.left == null && root.right == null && root.val == sum) return true;\n        sum -= root.val;\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n    }\n}\n```\n\n### 205. Isomorphic Strings\n- [Link](https://leetcode.com/problems/isomorphic-strings/)\n- Tags: Hash Table\n- Stars: 1\n\n#### HashMap, only beats 36.92% in time\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        HashMap<Character, Character> map1 = new HashMap<>(), map2 = new HashMap<>();\n        for(int i=0; i<s.length(); i++){\n            char c1 = s.charAt(i), c2 = t.charAt(i);\n            if(map1.containsKey(c1) && map2.containsKey(c2)){\n                if(map1.get(c1) != c2 || map2.get(c2) != c1) return false;\n                continue;\n            }\n            if(map1.containsKey(c1) || map2.containsKey(c2)) return false;\n            map1.put(c1, c2);\n            map2.put(c2, c1);\n        }\n        return true;\n    }\n}\n\n// Similar Idea Using HashMap + HashSet\n// class Solution {\n//     public boolean isIsomorphic(String s, String t) {\n//         HashMap<Character, Character> map = new HashMap<>();\n//         HashSet<Character> set = new HashSet<>();\n//         for(int i=0; i<s.length(); i++){\n//             char c1 = s.charAt(i), c2 = t.charAt(i);\n//             if(map.containsKey(c1)){\n//                 if(!set.contains(c2) || map.get(c1) != c2) return false;\n//                 continue;\n//             }\n//             if(set.contains(c2)) return false;\n//             map.put(c1, c2);\n//             set.add(c2);\n//         }\n//         return true;\n//     }\n// }\n```\n\n#### Great solution! beats 96.69% in time\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        int[] m = new int[256], n = new int[256];\n        for(int i=0; i<s.length(); i++){\n            char c1 = s.charAt(i), c2 = t.charAt(i);\n            if(m[c1] != n[c2]) return false;\n            m[c1] = n[c2] = i+1;\n        }\n        return true;\n    }\n}\n```\n\n### 203. Remove Linked List Elements\n- [Link](https://leetcode.com/problems/remove-linked-list-elements/)\n- Tags: Linked List\n- Stars: 2\n\n#### partial recursive solution, beats 100% in time\n```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if(head == null) return null;\n        if(head.val == val) return removeElements(head.next, val);\n        ListNode curr = head;\n        while(curr.next != null) {\n            ListNode next = curr.next;\n            if(next.val == val) curr.next = next.next;\n            else curr = curr.next;\n        }\n        return head;\n    }\n}\n```\n\n#### recursive solution, beats 99.94% in time\n```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if(head == null) return null;\n        head.next = removeElements(head.next, val);\n        return head.val == val ? head.next : head;\n    }\n}\n```\n\n#### iterative solution, beats 99.94% in time\n```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode fakeHead = new ListNode(0);\n        fakeHead.next = head;\n        ListNode curr = fakeHead;\n        while(curr.next != null) {\n            ListNode next = curr.next;\n            if(next.val == val) curr.next = next.next;\n            else curr = curr.next;\n        }\n        return fakeHead.next;\n    }\n}\n```\n\n### 88. Merge Sorted Array\n- [Link](https://leetcode.com/problems/merge-sorted-array/)\n- Tags: Array, Two Pointers\n- Stars: 1\n\n#### two pointers\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i=m-1, j=n-1, k=m+n-1;\n        while(i>=0 && j>=0) {\n            if(nums2[j] > nums1[i]) nums1[k--] = nums2[j--];\n            else nums1[k--] = nums1[i--];\n        }\n        while(j >= 0) nums1[k--] = nums2[j--];\n    }\n}\n```\n\n### 111. Minimum Depth of Binary Tree\n- [Link](https://leetcode.com/problems/minimum-depth-of-binary-tree/)\n- Tags: Tree, BFS, DFS\n- Stars: 2\n\n#### DFS\n```java\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        if(root.left == null && root.right == null) return 1;\n        int result = Integer.MAX_VALUE;\n        if(root.left != null) result = minDepth(root.left);\n        if(root.right != null) result = Math.min(minDepth(root.right), result);\n        return result + 1;\n    }\n}\n```\n\n### 219. Contains Duplicate II\n- [Link](https://leetcode.com/problems/contains-duplicate-ii/)\n- Tags: Array, Hash Table\n- Stars: 1\n\n#### HashSet\n```java\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        HashSet<Integer> set = new HashSet<>();\n        for(int i=0; i<nums.length; i++) {\n            if(!set.add(nums[i])) return true;\n            if(set.size() > k) set.remove(nums[i-k]);\n        }\n        return false;\n    }\n}\n```\n\n### 290. Word Pattern\n- [Link](https://leetcode.com/problems/word-pattern/)\n- Tags: Hash Table\n- Stars: 1\n\n#### HashMap mapping\n```java\nclass Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] char2word = new String[26];\n        HashMap<String, Integer> word2char = new HashMap<>();\n        String[] words = str.split(\" \");\n        if(pattern.length() != words.length) return false;\n        for(int i=0; i<words.length; i++) {\n            if(char2word[pattern.charAt(i)-'a'] == null && \n               !word2char.containsKey(words[i])) {\n                char2word[pattern.charAt(i)-'a'] = words[i];\n                word2char.put(words[i], pattern.charAt(i)-'a');\n            }\n            else if(char2word[pattern.charAt(i)-'a'] == null || \n                    !word2char.containsKey(words[i])) \n                return false;\n            else if(!char2word[pattern.charAt(i)-'a'].equals(words[i]) ||\n                    word2char.get(words[i]) != pattern.charAt(i)-'a')\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n### 58. Length of Last Word\n- [Link](https://leetcode.com/problems/length-of-last-word/)\n- Tags: String\n- Stars: 1\n\n#### beats 100% in time\n```java\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        int i = s.length() - 1;\n        while(i>=0 && s.charAt(i) == ' ') i--;\n        if(i<0) return 0;\n        int j = i-1;\n        while(j>=0 && s.charAt(j) != ' ') j--;\n        return i-j;\n    }\n}\n```\n\n#### String.split()\n```java\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        String[] list = s.split(\" \");\n        for(int i=list.length-1; i>=0; i--) \n            if(list[i].length() != 0) return list[i].length();\n        return 0;\n    }\n}\n```\n\n### 168. Excel Sheet Column Title\n- [Link](https://leetcode.com/problems/excel-sheet-column-title/)\n- Tags: Math\n- Stars: 2\n\n#### shifted divide\n```java\nclass Solution {\n    public String convertToTitle(int n) {\n        StringBuilder sb = new StringBuilder();\n        while(true) {\n            if(n == 0) break;\n            n--;\n            sb.insert(0, (char)(n%26 + 'A'));\n            n /= 26;\n        }\n        return sb.toString();\n    }\n}\n```\n\n#### recursive shifted divide\n```java\nclass Solution {\n    public String convertToTitle(int n) {\n        return n == 0 ? \"\" : convertToTitle(--n/26) + (char)(n%26 + 'A');\n    }\n}\n```\n\n### 204. Count Primes\n- [Link](https://leetcode.com/problems/count-primes/)\n- Tags: Hash Table, Math\n- Stars: 1\n\n#### O(n) time\n```java\nclass Solution {\n    public int countPrimes(int n) {\n        if(n<2) return 0;\n        boolean[] arr = new boolean[n];\n        Arrays.fill(arr, true);\n        int result = 0;\n        for(int i=2; i<arr.length; i++) {\n            if(arr[i]){\n                result++;\n                for(int j=i*2; j<arr.length; j+=i) arr[j] = false;\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 7. Reverse Integer\n- [Link](https://leetcode.com/problems/reverse-integer/)\n- Tags: Math\n- Stars: 1\n\n#### convert to long integer\n```java\nclass Solution {\n    public int reverse(int x) {\n        long result = 0, num = (long)x;\n        int sign = x < 0 ? -1 : 1;\n        num *= sign;\n        while(num > 0) {\n            result *= 10;\n            result += num%10;\n            num /= 10;\n        }\n        result *= sign;\n        if(result < Integer.MIN_VALUE || result > Integer.MAX_VALUE)\n            return 0;\n        return (int)result;\n    }\n}\n```\n\n#### Great Solution! no Long, no sign, check overflow in each iteration\n```java\nclass Solution {\n    public int reverse(int x) {\n        int result = 0;\n        while(x != 0) {\n            int newResult = result*10 + x%10;\n            if((newResult - x%10)/10 != result) return 0;\n            result = newResult;\n            x /= 10;\n        }\n        return result;\n    }\n}\n```\n\n### 260. Single Number III\n- [Link](https://leetcode.com/problems/single-number-iii/)\n- Tags: Bit Manipulation\n- Stars: 3\n\n#### XOR\nTo find n one-appearance elements based on XOR result, divide nums into n groupd s.t. each group only contains one one-appearance element. \n```java\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int res = 0;\n        for(int num: nums) res ^= num;\n        int diff = res&(-res);\n        int a = 0, b = 0;\n        for(int num: nums) {\n            if((num&diff) > 0) a ^= num;\n            else b ^= num;\n        }\n        int[] result = { a, b };\n        return result;\n    }\n}\n```\n\n### 216. Combination Sum III\n- [Link](https://leetcode.com/problems/combination-sum-iii/)\n- Tags: Array, Backtracking\n- Stars: 1\n\n#### backtrack\nNotice that the numbers from 1 to 9 cannot be selected twice\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        backtrack(new ArrayList<>(), 0, 1, k, n);\n        return result;\n    }\n    private void backtrack(List<Integer> list, int curr, int start, int k, int n) {\n        if(k == 0) {\n            if(curr == n) result.add(new ArrayList<>(list));\n            return ;\n        }\n        for(int i=start; i<=9; i++) {\n            if(curr + i > n) break;\n            list.add(i);\n            backtrack(list, curr+i, i+1, k-1, n);\n            list.remove(list.size()-1);\n        }\n    }\n}\n```\n\n### 230. Kth Smallest Element in a BST\n- [Link](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)\n- Tags: Binary Search, Tree\n- Stars: 1\n\n#### recursive DFS\n```java\nclass Solution {\n    TreeNode result = null;\n    int count;\n    public int kthSmallest(TreeNode root, int k) {\n        count = k;\n        inOrderTraversal(root);\n        return result.val;\n    }\n    public void inOrderTraversal(TreeNode root) {\n        if(root == null) return ;\n        inOrderTraversal(root.left);\n        count--;\n        if(count == 0) result = root;\n        else inOrderTraversal(root.right);\n    }\n}\n```\n\n#### non-recursive DFS\n```java\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> st = new Stack<>();\n        while(root.left != null) {\n            st.add(root);\n            root = root.left;\n        }\n        while(true) {\n            k--;\n            if(k == 0) return root.val;\n            root = root.right;\n            while(root != null) {\n                st.add(root);\n                root = root.left;\n            }\n            root = st.pop();\n        }\n    }\n}\n```\n\n### 12. Integer to Roman\n- [Link](https://leetcode.com/problems/integer-to-roman/)\n- Tags: Math, String\n- Stars: 2\n\n#### divide from high digit to low\n```java\nclass Solution {\n    public String intToRoman(int num) {\n        HashMap<Integer, Character> map = new HashMap<>();\n        map.put(1, 'I');\n        map.put(5, 'V');\n        map.put(10, 'X');\n        map.put(50, 'L');\n        map.put(100, 'C');\n        map.put(500, 'D');\n        map.put(1000, 'M');\n        StringBuilder result = new StringBuilder();\n        int base = 1000;\n        while(num > 0) {\n            int div = num / base;\n            num %= base;\n            if(div == 0) {\n                base /= 10;\n                continue;\n            }\n            if(div == 4 || div == 9) {\n                result.append(map.get(base));\n                result.append(map.get((div+1)*base));\n                continue;\n            }\n            if(div >= 5) {\n                result.append(map.get(5*base));\n                div -= 5;\n            }\n            for(int i=0; i<div; i++) result.append(map.get(base));\n        }\n        return result.toString();\n    }\n}\n```\n\n#### map every digit into a string with direct concat\n```java\nclass Solution {\n    public String intToRoman(int num) {\n        String[][] table = {\n            {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\n            {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\n            {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\n            {\"\", \"M\", \"MM\", \"MMM\"},\n        };\n        int count = 0;\n        StringBuilder sb = new StringBuilder();\n        while(num > 0) {\n            int digit = num % 10;\n            num /= 10;\n            sb.insert(0, table[count++][digit]);\n        }\n        return sb.toString();\n    }\n}\n```\n\n#### interview solution!! Simple and clear!! beats 100% and 100%!!\n```java\nclass Solution {\n    public String intToRoman(int num) {\n        int[] values = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n        String[] strs = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n        StringBuilder result = new StringBuilder();\n        for(int i=0; i<values.length; i++) {\n            while(num >= values[i]) {\n                result.append(strs[i]);\n                num -= values[i];\n            }\n        }\n        return result.toString();\n    }\n}\n```\n\n### 241. Different Ways to Add Parentheses\n- [Link](https://leetcode.com/problems/different-ways-to-add-parentheses/)\n- Tags: Divide and Conquer\n- Stars: 2\n\n#### recursive divide and conquer, beats 80% in time\n```java\nclass Solution {\n    public List<Integer> diffWaysToCompute(String input) {\n        return diffWaysToCompute(input, 0, input.length()-1);\n    }\n    public List<Integer> diffWaysToCompute(String input, int l, int r) {\n        List<Integer> result = new ArrayList<>();\n        if(l > r) return result;\n        for(int i=l; i<=r; i++) {\n            char c = input.charAt(i);\n            if(Character.isDigit(c)) continue;\n            List<Integer> leftList = diffWaysToCompute(input, l, i-1);\n            List<Integer> rightList = diffWaysToCompute(input, i+1, r);\n            for(int a : leftList)\n                for(int b : rightList)\n                    result.add(compute(a, b, c));\n        }\n        if(result.size() == 0)\n            result.add(Integer.parseInt(input.substring(l, r+1)));\n        return result;\n    }\n    private int compute(int a, int b, char op) {\n        if(op == '+') return a+b;\n        if(op == '-') return a-b;\n        return a*b;\n    }\n}\n```\n\n### 173. Binary Search Tree Iterator\n- [Link](https://leetcode.com/problems/binary-search-tree-iterator/)\n- Tags: Stack, Tree, Design\n- Stars: 1\n\n#### non-recursive DFS\n```java\nclass BSTIterator {\n    Stack<TreeNode> st = new Stack<>();\n    public BSTIterator(TreeNode root) {\n        pushUntilLeftMost(root);\n    }\n    public int next() {\n        TreeNode temp = st.pop();\n        pushUntilLeftMost(temp.right);\n        return temp.val;\n    }\n    public boolean hasNext() {\n        return !st.isEmpty();\n    }\n    private void pushUntilLeftMost(TreeNode node) {\n        while(node != null) {\n            st.add(node);\n            node = node.left;\n        }\n    }\n}\n```\n\n### 199. Binary Tree Right Side View\n- [Link](https://leetcode.com/problems/binary-tree-right-side-view/)\n- Tags: Tree, DFS, BFS\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    List<Integer> result = new ArrayList<>();\n    public List<Integer> rightSideView(TreeNode root) {\n        DFS(root, 1);\n        return result;\n    }\n    private void DFS(TreeNode root, int h) {\n        if(root == null) return ;\n        if(h > result.size()) result.add(root.val);\n        DFS(root.right, h+1);\n        DFS(root.left, h+1);\n    }\n}\n```\n\n### 77. Combinations\n- [Link](https://leetcode.com/problems/combinations/)\n- Tags: Backtracking\n- Stars: 1\n\n#### backtrack, double 100%\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combine(int n, int k) {\n        backtrack(new ArrayList<>(), 1, n, k);\n        return result;\n    }\n    private void backtrack(List<Integer> currList, int start, int n, int k) {\n        if(k == 0) {\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int i=start; i<=n-k+1; i++) {\n            currList.add(i);\n            backtrack(currList, i+1, n, k-1);\n            currList.remove(currList.size()-1);\n        }\n    }\n}\n```\n\n### 64. Minimum Path Sum\n- [Link](https://leetcode.com/problems/minimum-path-sum/)\n- Tags: Array, Dynamic Programming\n- Stars: 1\n\n#### DP\n```java\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        if(grid.length == 0 || grid[0].length == 0) return 0;\n        int m = grid.length, n = grid[0].length;\n        int[] dp = grid[0];\n        for(int i=1; i<n; i++) dp[i] += dp[i-1];\n        for(int i=1; i<m; i++) {\n            dp[0] += grid[i][0];\n            for(int j=1; j<n; j++) \n                dp[j] = Math.min(dp[j-1], dp[j]) + grid[i][j];\n        }\n        return dp[dp.length-1];\n    }\n}\n```\n\n### 59. Spiral Matrix II\n- [Link](https://leetcode.com/problems/spiral-matrix-ii/)\n- Tags: Array\n- Stars: 2\n\n#### recursive onion, double 100%\n```java\nclass Solution {\n    int[][] result;\n    int n;\n    public int[][] generateMatrix(int n) {\n        this.n = n;\n        result = new int[n][n];\n        onion(0, 1);\n        if(n%2 == 1) result[n/2][n/2] = n*n;\n        return result;\n    }\n    private void onion(int k, int start) {\n        if(2*k >= n) return ;\n        for(int j=k; j<n-k-1; j++) result[k][j] = start++;\n        for(int i=k; i<n-k-1; i++) result[i][n-k-1] = start++;\n        for(int j=n-k-1; j>k; j--) result[n-k-1][j] = start++;\n        for(int i=n-k-1; i>k; i--) result[i][k] = start++;\n        onion(k+1, start);\n    }\n}\n```\n\n# Topics\n\n## String\n\n### 557. Reverse Words in a String III\n- [Link](https://leetcode.com/problems/reverse-words-in-a-string-iii/)\n- Tags: String\n- Stars: 1\n\n#### two pointers reverse word by word\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        int i=0;\n        StringBuilder sb = new StringBuilder(s);\n        while(i<sb.length()){\n            while(i<sb.length() && sb.charAt(i) == ' ') i++;\n            int j = i;\n            while(j<sb.length() && sb.charAt(j) != ' ') j++;\n            reverse(sb, i, j-1);\n            i = j+1;\n        }\n        return sb.toString();\n    }\n    private void reverse(StringBuilder sb, int i, int j){\n        while(i<j) swap(sb, i++, j--);\n    }\n    private void swap(StringBuilder sb, int i, int j){\n        char c = sb.charAt(i);\n        sb.setCharAt(i, sb.charAt(j));\n        sb.setCharAt(j, c);\n    }\n}\n```\n\n#### Built-in functions\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] strs = s.split(\" \");\n        for(int i=0; i<strs.length; i++){\n            strs[i] = (new StringBuilder(strs[i])).reverse().toString();\n        }\n        return String.join(\" \", Arrays.asList(strs));\n    }\n}\n```\n\n### 893. Groups of Special-Equivalent Strings\n- [Link](https://leetcode.com/problems/groups-of-special-equivalent-strings/)\n- Tags: String\n- Stars: 1\n\n#### HashArray\nThe key is to encode the string into something hashable and put it all into a HashSet.\n\nCount number of characters for odd and even indices separately.  \nOdd-indexed characters are counted in chars[:26], while even-indexed characters are counted in chars[26:]. \n```java\nclass Solution {\n    public int numSpecialEquivGroups(String[] A) {\n        HashSet<HashArray> set = new HashSet<>();\n        for(String s : A){\n            HashArray harr = new HashArray(s);\n            set.add(harr);\n        }\n        return set.size();\n    }\n}\nclass HashArray {\n    int[] chars = new int[52];\n    public HashArray(String s){\n        for(int i=0; i<s.length(); i+=2)\n            chars[s.charAt(i)-'a']++;\n        for(int i=1; i<s.length(); i+=2)\n            chars[s.charAt(i)-'a'+26]++;\n    }\n    public boolean equals(Object o){\n        for(int i=0; i<52; i++)\n            if(this.chars[i] != ((HashArray)o).chars[i]) return false;\n        return true;\n    }\n    public int hashCode(){\n        return Arrays.hashCode(chars);\n    }\n}\n```\n\n### 824. Goat Latin\n- [Link](https://leetcode.com/problems/goat-latin/)\n- Tags: String\n- Stars: 1\n\n#### StringBuilder modify, no split\n```java\nclass Solution {\n    HashSet<Character> set = new HashSet<>(\n        Arrays.asList(new Character[] {'a', 'e', 'i','o','u','A','E','I','O','U'}));\n    public String toGoatLatin(String s) {\n        StringBuilder sb = new StringBuilder(s);\n        int i = 0, count = 0;\n        while(true){\n            while(i<sb.length() && sb.charAt(i) == ' ') i++;\n            if(i == sb.length()) break;\n            int j = i;\n            while(j<sb.length() && sb.charAt(j) != ' ') j++;\n            count++;\n            \n            if(beginsWithVowels(sb, i, j)) {\n                sb.insert(j, \"ma\");\n                j += 2;\n            }\n            else{\n                char c = sb.charAt(i);\n                sb.delete(i, i+1);\n                sb.insert(j-1, c);\n                sb.insert(j, \"ma\");\n                j+=2;\n            }\n            for(int k=0; k<count; k++) sb.insert(j++, 'a');\n            \n            i = j;\n        }\n        return sb.toString();\n    }\n    private boolean beginsWithVowels(StringBuilder sb, int start, int end){\n        return set.contains(sb.charAt(start));\n    }\n}\n```\n\n### 521. Longest Uncommon Subsequence I\n- [Link](https://leetcode.com/problems/longest-uncommon-subsequence-i/)\n- Tags: String\n- Stars: 1\n\n#### April Fool's Question\n```java\nclass Solution {\n    public int findLUSlength(String a, String b) {\n        return a.equals(b) ? -1 : Math.max(a.length(), b.length());\n    }\n}\n```\n\n### 917. Reverse Only Letters\n- [Link](https://leetcode.com/problems/reverse-only-letters/)\n- Tags: String\n- Stars: 1\n\n#### skipping two pointers swap\n```java\nclass Solution {\n    public String reverseOnlyLetters(String S) {\n        StringBuilder s = new StringBuilder(S);\n        int i = 0, j = s.length()-1;\n        while(true){\n            while(i<j && !Character.isLetter(s.charAt(i))) i++;\n            while(i<j && !Character.isLetter(s.charAt(j))) j--;\n            if(i >= j) break;\n            char c = s.charAt(i);\n            s.setCharAt(i, s.charAt(j));\n            s.setCharAt(j, c);\n            i++; j--;\n        }\n        return s.toString();\n    }\n}\n```\n\n## Linked List\n\n### 876. Middle of the Linked List\n- [Link](https://leetcode.com/problems/middle-of-the-linked-list/)\n- Tags: Linked List\n- Stars: 1\n\n#### slow-fast\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if(head == null) return null;\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n\n## Backtracking Questions\n[Reference](https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning))\n\n**Backtrack == \u53d1\u6563\u5f0fDFS**\n\n### 78. Subsets\n- [Link](https://leetcode.com/problems/subsets/)\n- Tags: Array, Backtracking, Bit Manipulation\n- Stars: 1\n\n#### General Approach\n```java\nclass Solution {\n    List<List<Integer>> result;\n    public List<List<Integer>> subsets(int[] nums) {\n        result = new ArrayList<>();\n        backtrack(new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    \n    private void backtrack(List<Integer> currList, int[] nums, int start){\n        result.add(new ArrayList<>(currList));\n        for(int i=start; i<nums.length; i++){\n            currList.add(nums[i]);\n            backtrack(currList, nums, i+1);\n            currList.remove(currList.size()-1);\n        }\n    }\n}\n```\n\n#### My solution (Faster!)\n```java\nclass Solution {\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> subsets(int[] nums) {\n        result = new ArrayList<>();\n        DFS(nums, 0, new ArrayList<Integer>());\n        return result;\n    }\n    private void DFS(int[] nums, int k, List<Integer> currList){\n        if(k==nums.length){\n            result.add(currList);\n            return ;\n        }\n        DFS(nums, k+1, new ArrayList<>(currList));\n        currList.add(nums[k]);\n        DFS(nums, k+1, currList);\n    }\n}\n```\n\n### 90. Subsets II\n- [Link](https://leetcode.com/problems/subsets-ii/)\n- Tags: Array, Backtracking\n- Stars: 1\n\n#### General Approach\n```java\nclass Solution {\n    List<List<Integer>> result;\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        result = new ArrayList<>();\n        Arrays.sort(nums);\n        backtrack(new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    private void backtrack(List<Integer> currList, int[] nums, int start){\n        result.add(new ArrayList<>(currList));\n        for(int i=start; i<nums.length; i++){\n            if(i==start || nums[i-1] != nums[i]){\n                currList.add(nums[i]);\n                backtrack(currList, nums, i+1);\n                currList.remove(currList.size()-1);\n            }\n        }\n    }\n}\n```\n\n#### My Solution\n```java\nclass Solution {\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        result = new ArrayList<>();\n        Arrays.sort(nums);\n        backtrack(new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    \n    private void backtrack(List<Integer> currList, int[] nums, int start){\n        if(start==nums.length) {\n            result.add(currList);\n            return ;\n        }\n        int end = start;\n        while(end<nums.length && nums[end] == nums[start])\n            end++;\n        for(int i = start+1; i<=end; i++){\n            List<Integer> temp = new ArrayList<>(currList);\n            for(int j=start; j<i; j++)\n                temp.add(nums[j]);\n            backtrack(temp, nums, end);\n        }\n        backtrack(currList, nums, end);\n    }\n}\n```\n\n### 46. Permutations\n- [Link](https://leetcode.com/problems/permutations/)\n- Tags: Backtracking\n- Stars: 1\n\n#### My Backtracking Solution (not general but faster)\n<span id=\"46-DP\" />\nThis is a DP-like solution. \nFor each iteration, you only consider the additional permutations that the k-th element brings about. \n\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> permute(int[] nums) {\n        if(nums.length == 0) return result;\n        result.add(new ArrayList<>());\n        for(int i=0; i<nums.length; i++)\n            backtrack(nums, i);\n        return result;\n    }\n    private void backtrack(int[] nums, int start) {\n        if(start == nums.length) return ;\n        int len = result.size(), num = nums[start];\n        for(int i=0; i<len; i++) {\n            List<Integer> row = result.get(i);\n            for(int j=0; j<row.size(); j++) {\n                List<Integer> newRow = new ArrayList<>(row);\n                newRow.add(j, num);\n                result.add(newRow);\n            }\n            row.add(num);\n        }\n    }\n}\n```\n\n#### Marking along the backtracking paths (general solution)\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> permute(int[] nums) {\n        backtrack(nums, new HashSet<>(), new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] nums, HashSet<Integer> mark, List<Integer> currList){\n        if(currList.size() == nums.length){\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int i=0; i<nums.length; i++)\n            if(!mark.contains(i)){\n                mark.add(i);\n                currList.add(nums[i]);\n                backtrack(nums, mark, currList);\n                currList.remove(currList.size()-1);\n                mark.remove(i);\n            }\n    }\n    \n}\n```\n\n### 47. Permutations II\n- [Link](https://leetcode.com/problems/permutations-ii/)\n- Tags: Backtracking\n- Stars: 2\n\n#### Marking along the backtracking paths (general solution)\nNotice that the DP-like solution in [46. Permutations](#46-DP) does not work here because of the presence of duplicates. \ne.g. If both `[1,3,3]` and `[3,1,3]` are in the result and you are going to insert a `1` in them, they can both get the same array `[1,3,1,3]`, which is not allowed. \n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    HashSet<Integer> unique = new HashSet<>();\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int num: nums) {\n            unique.add(num);\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        backtrack(nums, map, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] nums, HashMap<Integer, Integer> map, List<Integer> currList){\n        if(currList.size() == nums.length) {\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int num : unique){\n            if(map.get(num)>0){\n                map.put(num, map.get(num)-1);\n                currList.add(num);\n                backtrack(nums, map, currList);\n                currList.remove(currList.size()-1);\n                map.put(num, map.get(num)+1);\n            }\n        }\n    }\n}\n```\n\n#### Marking again! (faster general solution)\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        backtrack(nums, new boolean[nums.length], new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] nums, boolean[] used, List<Integer> currList){\n        if(currList.size() == nums.length){\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int i=0; i<nums.length; i++){\n            if(used[i] || i>0 && nums[i-1] == nums[i] && !used[i-1]) continue;\n            used[i] = true;\n            currList.add(nums[i]);\n            backtrack(nums, used, currList);\n            currList.remove(currList.size()-1);\n            used[i] = false;\n        }\n    }\n}\n```\n\n### 22. Generate Parentheses\n- [Link](https://leetcode.com/problems/generate-parentheses/)\n- Tags: String, Backtracking\n- Stars: 1\n\n[YouTube Video](https://www.youtube.com/watch?v=sz1qaKt0KGQ)\n\n#### My Backtracking Solution\n```java\nclass Solution {\n    List<String> result;\n    public List<String> generateParenthesis(int n) {\n        result = new ArrayList<>();\n        backtrack(new StringBuilder(), n, 0);\n        return result;\n    }\n    private void backtrack(StringBuilder sb, int left, int right){\n        if(left == 0 && right == 0){\n            result.add(sb.toString());\n            return ;\n        }\n        if(left>0){\n            sb.append('(');\n            backtrack(sb, left-1, right+1);\n            sb.delete(sb.length()-1, sb.length());\n        }\n        if(right>0){\n            sb.append(')');\n            backtrack(sb, left, right-1);\n            sb.delete(sb.length()-1, sb.length());\n        }\n    }\n}\n```\n\n### 17. Letter Combinations of a Phone Number\n- [Link](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n- Tags: String, Backtracking\n- Stars: 1\n\n#### simple backtracking\n```java\nclass Solution {\n    List<String> result = new ArrayList<>();\n    HashMap<Character, String> map = new HashMap<>();\n    public List<String> letterCombinations(String digits) {\n        if(digits == null || digits.length() == 0) return result;\n        map.put('2', \"abc\");\n        map.put('3', \"def\");\n        map.put('4', \"ghi\");\n        map.put('5', \"jkl\");\n        map.put('6', \"mno\");\n        map.put('7', \"pqrs\");\n        map.put('8', \"tuv\");\n        map.put('9', \"wxyz\");\n        backtrack(digits, 0, new StringBuilder());\n        return result;\n    }\n    private void backtrack(String digits, int start, StringBuilder currsb){\n        if(start == digits.length()){\n            result.add(currsb.toString());\n            return ;\n        }\n        for(char c: map.get(digits.charAt(start)).toCharArray()){\n            currsb.append(c);\n            backtrack(digits, start+1, currsb);\n            currsb.delete(currsb.length()-1, currsb.length());\n        }\n    }\n}\n```\n\n### 200. Number of Islands\n- [Link](https://leetcode.com/problems/number-of-islands/)\n- Tags: DFS, BFS, Union Find\n- Stars: 1\n\n#### DFS\n```java\nclass Solution {\n    public int numIslands(char[][] grid) {\n        if(grid.length==0 || grid[0].length==0) return 0;\n        int result = 0;\n        for(int i=0; i<grid.length; i++)\n            for(int j=0; j<grid[0].length; j++){\n                if(grid[i][j] == '1'){\n                    DFS(grid, i, j);\n                    result++;\n                }\n            }\n        return result;\n    }\n    private void DFS(char[][] grid, int i, int j){\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] != '1')\n            return;\n        grid[i][j] = 'x';\n        DFS(grid, i-1, j);\n        DFS(grid, i+1, j);\n        DFS(grid, i, j+1);\n        DFS(grid, i, j-1);\n    }\n}\n```\n\n### 131. Palindrome Partitioning\n- [Link](https://leetcode.com/problems/palindrome-partitioning/)\n- Tags: Backtracking\n- Stars: 2\n\n#### sub-optimal palindrome method\n```java\nclass Solution {\n    List<List<String>> result = new ArrayList<>();\n    public List<List<String>> partition(String s) {\n        backtrack(s, 0, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(String s, int start, List<String> list){\n        if(start == s.length()){\n            result.add(list);\n            return ;\n        }\n        for(int i=start; i<s.length(); i++){\n            if(isPalindrome(s, start, i)){\n                List<String> newList = new ArrayList<>(list);\n                newList.add(s.substring(start, i+1));\n                backtrack(s, i+1, newList);\n            }\n        }\n    }\n    private boolean isPalindrome(String s, int i, int j){\n        while(i<j){\n            if(s.charAt(i++)!=s.charAt(j--))\n                return false;\n        }\n        return true;\n    }\n}\n```\n\n#### Manacher's Algorithm \nThe Manacher method is copied from [a CSDN blog](https://blog.csdn.net/u014771464/article/details/79120964)\n```java\nclass Solution {\n    List<List<String>> result = new ArrayList<>();\n    public List<List<String>> partition(String s) {\n        int[] p = ManacherArray(s);\n        backtrack(s, 0, p, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(String s, int start, int[] p, List<String> list){\n        if(start == s.length()){\n            result.add(list);\n            return ;\n        }\n        int idx = 2*(start+1);\n        for(int i=idx; i<p.length; i++){\n            int len = p[i]-1;\n            int left = i - len + 1;\n            int diff = start - (left/2 - 1);\n            if(diff >= 0){\n                List<String> newList = new ArrayList<>(list);\n                newList.add(s.substring(start, start+len-diff*2));\n                backtrack(s, start+len-diff*2, p, newList);\n            }\n        }\n    } \n    public int[] ManacherArray(String s) {\n        // Insert '#'\n        String t = \"$#\";\n        for (int i = 0; i < s.length(); ++i) {\n            t += s.charAt(i);\n            t += \"#\";\n        }\n        t += \"@\";\n        // Process t\n        int[] p = new int[t.length()];;\n        int mx = 0, id = 0, resLen = 0, resCenter = 0;\n        for (int i = 1; i < t.length()-1; ++i) {\n            p[i] = mx > i ? Math.min(p[2 * id - i], mx - i) : 1;\n            while (((i - p[i])>=0) && \n                   ((i + p[i])<t.length()-1) && \n                   (t.charAt(i + p[i]) == t.charAt(i - p[i])))\n                ++p[i];\n            if (mx < i + p[i]) {\n                mx = i + p[i];\n                id = i;\n            }\n            if (resLen < p[i]) {\n                resLen = p[i];\n                resCenter = i;\n            }\n        }\n        return p;\n    }\n}\n```\n\n### 39. Combination Sum\n- [Link](https://leetcode.com/problems/combination-sum/)\n- Tags: Array, Backtracking\n- Stars: 2\n\n#### general backtracking solution\n```java\nclass Solution {\n    int[] candidates;\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        this.candidates = candidates;\n        backtrack(new ArrayList<>(), 0, target);\n        return result;\n    }\n    private void backtrack(List<Integer> currList, int start, int target) {\n        if(target == 0) {\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int i=start; i<candidates.length; i++) {\n            if(candidates[i] > target) return ;\n            currList.add(candidates[i]);\n            backtrack(currList, i, target-candidates[i]);\n            currList.remove(currList.size()-1);\n        }\n    }\n}\n```\n\n### 40. Combination Sum II\n- [Link](https://leetcode.com/problems/combination-sum-ii/)\n- Tags: Array, Backtracking\n- Stars: 2\n\n#### general backtracking solution\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        backtrack(candidates, 0, target, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] candidates, int start, int target, List<Integer> currList){\n        if(target == 0){\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        if(start == candidates.length || target < candidates[start]) return ;\n        int idx = start+1, num = candidates[start];\n        while(idx < candidates.length && candidates[idx] == num) idx++; // get the index of the next distinct candidate\n        // case 1: do not use `num`\n        backtrack(candidates, idx, target, currList);\n        // case 2: use `num`\n        for(int i=start; i<idx; i++){\n            currList.add(candidates[i]);\n            target -= num;\n            backtrack(candidates, idx, target, currList);\n        }\n        for(int i=0; i<idx-start; i++) currList.remove(currList.size()-1);\n    }\n}\n```\n\n#### genenral backtracking solution in a better way\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        backtrack(candidates, 0, target, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] candidates, int start, int target, List<Integer> currList){\n        if(target == 0){\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        if(start == candidates.length || target < candidates[start]) return ;\n        for(int i=start; i<candidates.length; i++){\n            if(i>start && candidates[i] == candidates[i-1]) continue;\n            currList.add(candidates[i]);\n            backtrack(candidates, i+1, target-candidates[i], currList);\n            currList.remove(currList.size()-1);\n        }\n    }\n}\n```\n\n### 79. Word Search\n- [Link](https://leetcode.com/problems/word-search/)\n- Tags: Array, Backtracking\n- Stars: 1\n\n#### simple backtracking solution beats 99.56% in time and 75.11% in space\n```java\nclass Solution {\n    char[][] board;\n    String word;\n    boolean[][] used;\n    public boolean exist(char[][] board, String word) {\n        if(word.length() == 0) return true;\n        if(board.length == 0 || board[0].length == 0) return false;\n        this.board = board;\n        this.word = word;\n        this.used = new boolean[board.length][board[0].length];\n        for(int i=0; i<board.length; i++)\n            for(int j=0; j<board[0].length; j++)\n                if(recurr(i, j, 0)) return true;\n        return false;\n    }\n    private boolean recurr(int i, int j, int start){\n        if(start == word.length()) return true;\n        if(i<0 || j<0 || i>=board.length || j>=board[0].length || used[i][j] || board[i][j] != word.charAt(start)) return false;\n        used[i][j] = true;\n        if(recurr(i+1, j, start+1) || recurr(i-1, j, start+1) || recurr(i, j+1, start+1) || recurr(i, j-1, start+1)) return true;\n        used[i][j] = false;\n        return false;\n    }\n}\n```\n\n## N Sums Questions\n\n### 1. Two Sum\n- [Link](https://leetcode.com/problems/two-sum/)\n- Tags: Array, Hash Table\n- Stars: 1\n\n#### HashMap\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i<nums.length; i++){\n            if(map.containsKey(target-nums[i]))\n                return new int[] {map.get(target-nums[i]), i};\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```\n\n### 454. 4Sum II\n- [Link](https://leetcode.com/problems/4sum-ii/)\n- Tags: Hash Table, Binary Search\n- Stars: 2\n\n#### HashMap + two sum\n```java\nclass Solution {\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n        int result = 0;\n        HashMap<Integer, Integer> map1 = twoSum(A, B);\n        HashMap<Integer, Integer> map2 = twoSum(C, D);\n        for(Map.Entry<Integer, Integer> e1: map1.entrySet()){\n            if(map2.containsKey(-e1.getKey())){\n                result += e1.getValue() * map2.get(-e1.getKey());\n            }\n        }\n        return result;\n    }\n    private HashMap<Integer, Integer> twoSum(int[] A, int[] B){\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int a: A)\n            for(int b: B)\n                map.put(a+b, map.getOrDefault(a+b, 0) + 1);\n        return map;\n    }\n}\n```\n\n### 15. 3Sum\n- [Link](https://leetcode.com/problems/3sum/)\n- Tags: Array, Two Pointers\n- Stars: 2\n\n#### HashSet, clear but slow\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> threeSum(int[] nums) {\n        if(nums.length == 0) return result;\n        HashSet<Integer> set = new HashSet<>();\n        for(int num: nums) set.add(num);\n        Arrays.sort(nums);\n        for(int i=0; i<nums.length-2; i++){\n            if(i>0 && nums[i] == nums[i-1]) continue;\n            for(int j=i+1; j<nums.length-1; j++){\n                if(j>i+1 && nums[j] == nums[j-1]) continue;\n                if(set.contains(-(nums[i]+nums[j])) && -(nums[i]+nums[j]) >= nums[j+1])\n                    result.add(Arrays.asList((Integer)nums[i], (Integer)nums[j], (Integer)(-(nums[i]+nums[j]))));\n            }\n        }\n        return result;\n    }\n}\n```\n\n#### jumping iteration + Two Sum two pointers\n```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        Arrays.sort(nums);\n        for(int i=0; i<nums.length-2; i++){\n            if(i>0 && nums[i] == nums[i-1]) continue;\n            int j=i+1, k=nums.length-1;\n            while(j<k){\n                if(nums[i]+nums[j]+nums[k] == 0) {\n                    result.add(Arrays.asList((Integer)nums[i], (Integer)nums[j++], (Integer)nums[k--]));\n                    while(j<k && nums[j] == nums[j-1]) j++;\n                    while(j<k && nums[k] == nums[k+1]) k--;\n                }\n                else if(nums[i]+nums[j]+nums[k]>0) k--;\n                else j++;\n            }\n        }\n        return result;\n    }\n}\n```\n\n# Weekly Contests\n\n## No. 96\n### 881. Boats to Save People\n- [Link](https://leetcode.com/problems/boats-to-save-people/)\n- Tags: Two Pointers, Greedy\n- Stars: 1\n\n#### two pointers\n```java\nclass Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int i=0, j=people.length-1;\n        int result = 0;\n        while(i<=j){\n            if(i==j){\n                result++;\n                break;\n            }\n            if(people[i]+people[j] > limit){\n                j--;\n            }\n            else{\n                i++;\n                j--;\n            }\n            result++;\n        }\n        return result;\n    }\n}\n```\n\n### 880. Decoded String at Index\n- [Link](https://leetcode.com/problems/decoded-string-at-index/)\n- Tags: Stack\n- Stars: 3\n\n#### Iterative\n```java\nclass Solution {\n    public String decodeAtIndex(String S, int K) {\n        List<Tuple> list = getTuples(S);\n        int pos = -1;\n        for(int i=0; i<list.size(); i++)\n            if(list.get(i).accu >= K) pos = i;\n        int curr = K-1;\n        while(pos>0){\n            curr %= list.get(pos).curr;\n            if(curr >= list.get(pos-1).accu) {\n                curr -= list.get(pos-1).accu;\n                return Character.toString(list.get(pos).str.charAt(curr));\n            }\n            pos--;\n        }\n        curr %= list.get(0).curr;\n        return Character.toString(list.get(0).str.charAt(curr));\n    }\n    private List<Tuple> getTuples(String S){\n        S = S + \"1\";\n        List<Tuple> result = new ArrayList<>();\n        int lastIdx = 0;\n        for(int i=0; i<S.length(); i++){\n            char c = S.charAt(i);\n            if(!Character.isLetter(c)){\n                if(lastIdx == i){\n                    result.get(result.size()-1).repeat *= c-'0';\n                    lastIdx = i+1;\n                }\n                else {\n                    Tuple tup = new Tuple(S.substring(lastIdx, i), c-'0', i-lastIdx);\n                    result.add(tup);\n                    lastIdx = i+1;\n                }\n            }\n        }\n        result.get(0).accu = result.get(0).curr * result.get(0).repeat;\n        for(int i=1; i<result.size(); i++){\n            result.get(i).curr = (result.get(i-1).accu + result.get(i).curr);\n            result.get(i).accu = result.get(i).curr * result.get(i).repeat;\n        }\n        return result;\n    }\n}\nclass Tuple{\n    String str;\n    int repeat;\n    long accu; // accumulative length after repeat\n    long curr; // accumulative length before repeat\n    public Tuple(String s, int r, long a){\n        str = s;\n        repeat = r;\n        curr = a;\n    }\n}\n```\n\n#### recursive\nAttention: strLen might OVERFLOW!!!!!!! Thus, we must use long. \n```java\nclass Solution {\n    public String decodeAtIndex(String S, int K) {\n        long strLen = 0;\n        for(int i=0; i<S.length(); i++){\n            char c = S.charAt(i);\n            if(Character.isLetter(c)){\n                if(++strLen == K) return Character.toString(c);\n            }\n            else {\n                int repeat = c-'0';\n                if(strLen * repeat >= K) \n                    return decodeAtIndex(S.substring(0, i), (int)((K-1)%strLen+1));\n                strLen *= repeat;\n            }\n        }\n        return null;\n    }\n}\n```\n\n# TODO List\n\n## skipped problems\n\n- 208 Implement Trie\n- 227 Basic Calculator II\n- 324 Wiggle Sort II -- Explanation/Proof for the correctness, Virtual Indexing\n- 5 Longest Palindromic Substring\n- 53 Maximum Subarray -- divide and conquer\n- 435 Non-overlapping Intervals (\u5df2\u7ecf\u6709###\u4e86)\n- explore more solutions of 43. Multiply Strings\n- explore more solutions of 673. Number of Longest Increasing Subsequence\n- 440 K-th Smallest in Lexicographical Order\n\n## recursive to non-recursive\n\n[101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)  \n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)  \n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)  \n[148. Sort List](https://leetcode.com/problems/sort-list/)  \n[104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)  \n[226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)  \n[230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)  \n[173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)  \n\n\n- [tree questions](https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution))\n\n## Math\n\n- 202. Happy Number\nhttps://leetcode.com/problems/happy-number/discuss/56918/All-you-need-to-know-about-testing-happy-number!\n\n## Bit Manipulation\n\n- (n-1)\u5728\u4f4d\u8fd0\u7b97\u4e2d\u7684\u4f5c\u7528\uff1f\n\n\n\n\n\n\n\n\n", "questions": [{"qid": 136, "title": "Single Number", "link": "https://leetcode.com/problems/single-number/", "tags": ["Bit Manipulation"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "XOR", "text": "```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int temp = 0;\n        for(int num: nums){\n            temp ^= num;\n        }\n        return temp;\n    }\n}\n```"}]}, {"qid": 283, "title": "Move Zeroes", "link": "https://leetcode.com/problems/move-zeroes/", "tags": ["Array", "Two pointers"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Insertion Sort", "text": "Time: O(n^2)\nSpace: O(1)\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        for(int i=1; i<nums.length; i++){\n            int curr = i;\n            while(curr > 0 && nums[curr-1] == 0){\n                int temp = nums[curr];\n                nums[curr] = nums[curr-1];\n                nums[curr-1] = temp;\n                curr--;\n            }\n        }\n    }\n}\n```"}, {"title": "Slow-Fast two pointers", "text": "We only need to care about non-zero elements and fill the remaining array with zeros!\n\nTime: O(n)\nSpace: O(1)\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int i=0, j=0;\n        for(;j<nums.length;j++){\n            if(nums[j]!=0){\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        while(i<nums.length){\n            nums[i] = 0;\n            i++;\n        }\n    }\n}\n```"}]}, {"qid": 206, "title": "Reverse Linked List", "link": "https://leetcode.com/problems/reverse-linked-list/", "tags": ["Linked List"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Iterative", "text": "```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode curr = null;\n        while(head != null){\n            ListNode p = head.next;\n            head.next = curr;\n            curr = head;\n            head = p;\n        }\n        return curr;\n    }\n}\n```"}, {"title": "Recursive", "text": "```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = reverseList(head.next);\n        head.next.next = head;\n        head.next = null;\n        return newHead;\n    }\n}\n```"}]}, {"qid": 371, "title": "Sum of Two Integers", "link": "https://leetcode.com/problems/sum-of-two-integers/", "tags": ["Bit Manipulation"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "\u884c\u6ce2\u8fdb\u4f4d\u52a0\u6cd5\u5668", "text": "```java\nclass Solution {\n    public int getSum(int a, int b) {\n        int c = 0;\n        int result = 0;\n        for(int i=0; i<32; i++){\n            int pos = (1<<i);\n            int m = (a&pos), n = (b&pos);\n            int g = (m&n), p = (m|n);\n            result |= (m^n^c);\n            c = (g | (p & c)) << 1;\n        }\n        return result;\n    }\n}\n```"}, {"title": "recursive \u884c\u6ce2\u8fdb\u4f4d\u52a0\u6cd5\u5668", "text": "```java\nclass Solution {\n    public int getSum(int a, int b) {\n        if(b==0)\n            return a;\n        return getSum((a^b), (a&b)<<1);\n    }\n}\n```"}]}, {"qid": 169, "title": "Majority Element", "link": "https://leetcode.com/problems/majority-element/", "tags": ["Array", "Divide and Conquer", "Bit Manipulation"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Heavy Guardian (Moore Voting)", "text": "```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int result = nums[0], count = 0;\n        for(int num : nums){\n            if(num == result) count++;\n            else {\n                count--;\n                if(count <= 0) {\n                    count = 1;\n                    result = num;\n                }\n            }\n        }\n        return result;\n    }\n}\n```"}, {"title": "Divide and Conquer", "text": "```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        return recurr(nums, 0, nums.length-1);\n    }\n    \n    private int recurr(int[] nums, int l, int r) {\n        if(l==r){\n            return nums[l];\n        }\n        int mid = l + ((r-l)>>1);\n        int a = recurr(nums, l, mid), b = recurr(nums, mid+1, r);\n        if(a==b){\n            return a;\n        }\n        return count(nums, l, r, a) > count(nums, l, r, b) ? a : b;\n    }\n    \n    private int count(int[] nums, int l, int r, int target){\n        int n = 0;\n        for(int i=l; i<=r; i++){\n            if(target == nums[i])\n                n++;\n        }\n        return n;\n    }\n}\n```"}, {"title": "binary search", "text": "Attention that you `r-l` might overflow, so you have to use long integer.\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        // iterate to get max and min element\n        long l=nums[0], r=nums[0];\n        for(int num : nums){\n            if(l > num) l = num;\n            if(r < num) r = num;\n        }\n        // binary search by value\n        while(l<r){\n            int mid = (int)(l+((r-l)>>1));\n            int count = getLTECount(nums, mid);\n            if(count > (nums.length>>1)) r = mid;\n            else l = mid+1;\n        }\n        return (int)l;\n    }\n    private int getLTECount(int[] nums, int target){\n        int count = 0;\n        for(int num : nums)\n            if(num <= target) count++;\n        return count;\n    }\n}\n```"}, {"title": "Bit Manipulation", "text": "majority\u7684\u6bcf\u4e00bit\u90fd\u5e94\u8be5\u662fmajority\uff01\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int result = 0;\n        for(int i=0, mask=1; i<32; i++, mask<<=1){\n            int bitCount = 0;\n            for(int j=0; j<nums.length; j++){\n                if((nums[j]&mask)!=0) bitCount++;\n                if(bitCount>nums.length/2) {\n                    result |= mask;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\nOther Sub-optimal methods: Hash Table, Sorting (must appear at n/2 position), Randomization (random pick one and check if it is majority)"}, {"title": "Quick Selection to find the median", "text": "```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int k = ((nums.length-1)>>1);\n        int l=0, r=nums.length-1;\n        while(l<r){\n            int j = partition(nums, l, r);\n            if(j == k) return nums[k];\n            else if(j>k) r = j-1;\n            else l = j+1;\n        }\n        return nums[k];\n    }\n    private int partition(int[] nums, int l, int r){\n        int i=l, j=r+1;\n        while(true){\n            while(nums[++i] < nums[l] && i<r);\n            while(nums[l] < nums[--j] && j>l);\n            if(i>=j) break;\n            swap(nums, i, j);\n        }\n        swap(nums, l, j);\n        return j;\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```"}]}, {"qid": 242, "title": "Valid Anagram", "link": "https://leetcode.com/problems/valid-anagram/", "tags": ["Hash Table", "Sort"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "alphabet counting", "text": "1. You don't need 2 alphabet!\n2. Arrays automatically got initialized with zero values!\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        int[] alphabet = new int[26];\n        for(int i=0; i<s.length(); i++) alphabet[s.charAt(i)-'a']++;\n        for(int i=0; i<t.length(); i++) alphabet[t.charAt(i)-'a']--;\n        for(int num : alphabet) if(num!=0) return false;\n        return true;\n    }\n}\n```"}]}, {"qid": 268, "title": "Missing Number", "link": "https://leetcode.com/problems/missing-number/", "tags": ["Array", "Math", "Bit Manipulation"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "sum (math)", "text": "This method might overflow when we have large amount of large numbers in `nums`!\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int sum = ((n*(n+1))>>1);\n        for(int num: nums)\n            sum -= num;\n        return sum;\n    }\n}\n```"}, {"title": "XOR with both index and array element", "text": "```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int result = nums.length;\n        for(int i=0; i<nums.length; i++){\n            result ^= (i ^ nums[i]);\n        }\n        return result;\n    }\n}\n```"}, {"title": "swap sort", "text": "Given a num in `nums`, one can easily know the postion that this num is supposed to be in. \n\nO(n) sort:  \n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int last = -1;\n        for(int i=0; i<nums.length; i++){\n            while(nums[i] != i){\n                if(nums[i] == -1) break;\n                if(nums[i] == nums.length){\n                    last = nums[i];\n                    nums[i] = -1;\n                }\n                else swap(nums, i, nums[i]);\n            }\n        }\n        for(int i=0; i<nums.length; i++){\n            if(i != nums[i]) return i;\n        }\n        return nums.length;\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```"}]}, {"qid": 121, "title": "Best Time to Buy and Sell Stock", "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/", "tags": ["Array", "Dynamic Programming"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "my original solution 20190201", "text": "\u4e0d\u9700\u8981\u6570\u7ec4\uff0c\u4fdd\u5b58\u5f53\u524d\u7684maxProfit\u548cminPrice\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices == null || prices.length == 0)\n            return 0;\n        int minPrice = prices[0];\n        int maxProfit = 0;\n        for(int i=1; i<prices.length; i++){\n            if(minPrice > prices[i])\n                minPrice = prices[i];\n            maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n        }\n        return maxProfit;\n    }\n}\n```"}, {"title": "DP", "text": "max subarray problem, using Kadane's Algorithm.\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0)\n            return 0;\n        int[] dp = new int[prices.length];\n        // dp[i] means maxProfit we can get in the contiguous subarray ended up with prices[i]\n        for(int i=1; i<prices.length; i++){\n            dp[i] = Math.max(0, dp[i-1] + prices[i] - prices[i-1]);\n        }\n        int maxProfit = 0;\n        for(int i=0; i<dp.length; i++)\n            if(maxProfit < dp[i])\n                maxProfit = dp[i];\n        return maxProfit;\n    }\n}\n```\nThe space of the algorithm above can be further optimized:\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if(prices.length == 0)\n            return 0;\n        int maxProfit = 0, dp = 0;\n        for(int i=1; i<prices.length; i++){\n            dp = Math.max(0, dp + prices[i] - prices[i-1]);\n            maxProfit = Math.max(maxProfit, dp);\n        }\n        return maxProfit;\n    }\n}\n```\nNotice that we only care about differences of the prices array."}]}, {"qid": 21, "title": "Merge Two Sorted Lists", "link": "https://leetcode.com/problems/merge-two-sorted-lists/", "tags": ["Linked List"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "iterative (my soluton)", "text": "```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode root = new ListNode(0), curr = root;\n        while(l1 != null && l2 != null){\n            if(l1.val < l2.val){\n                curr.next = l1;\n                l1 = l1.next;\n            }\n            else {\n                curr.next = l2;\n                l2 = l2.next;\n            }\n            curr = curr.next;\n        }\n        curr.next = l1!=null ? l1 : l2;\n        return root.next;\n    }\n}\n```"}, {"title": "recursive", "text": "```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1 == null) return l2;\n        if(l2 == null) return l1;\n        ListNode root;\n        if(l1.val < l2.val){\n            root = l1;\n            root.next = mergeTwoLists(l1.next, l2);\n        }\n        else {\n            root = l2;\n            root.next = mergeTwoLists(l1, l2.next);\n        }\n        return root;\n    }\n}\n```"}]}, {"qid": 202, "title": "Happy Number", "link": "https://leetcode.com/problems/happy-number/", "tags": ["Hash Table", "Math"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashSet", "text": "```java\nclass Solution {\n    public boolean isHappy(int n) {\n        HashSet<Integer> st = new HashSet<Integer>();\n        while(!st.contains(n)){\n            if(n == 1)\n                return true;\n            st.add(n);\n            String str = Integer.toString(n);\n            n = 0;\n            for(int i=0; i<str.length(); i++){\n                int a = str.charAt(i) - '0';\n                n += a*a;\n            }\n        }\n        return false;\n    }\n}\n```"}, {"title": "Floyd Cycle detection algorithm", "text": "The best video to learn about Floyd Cycle detection : [https://www.youtube.com/watch?v=LUm2ABqAs1w](https://www.youtube.com/watch?v=LUm2ABqAs1w)\n\n```java\nclass Solution {\n    public boolean isHappy(int n) {\n        int slow=n, fast=n;\n        do {\n            slow = digitsSquareSum(slow);\n            fast = digitsSquareSum(fast);\n            fast = digitsSquareSum(fast);\n        }\n        while(slow != fast);\n        if(slow == 1) return true;\n        return false;\n    }\n    \n    private int digitsSquareSum(int n){\n        int result = 0;\n        while(n>0){\n            int digit = (n%10);\n            result += digit * digit;\n            n /= 10;\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 326, "title": "Power of Three", "link": "https://leetcode.com/problems/power-of-three/", "tags": ["Math"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Math", "text": "```java\nclass Solution {\n    public boolean isPowerOfThree(int n) {\n        // 1162261467 = 3**19 < 2**31-1 < 3**20\n        return (n>0 && 1162261467%n == 0);\n    }\n}\n```"}, {"title": "binary search", "text": "```java\nclass Solution {\n    public boolean isPowerOfThree(int n) {\n        int l=0, r=19;\n        while(l<=r){\n            int mid = l + ((r-l)>>1);\n            int power = (int)Math.pow(3, mid);\n            if(power == n) return true;\n            else if(power > n) r = mid-1;\n            else l = mid+1;\n        }\n        return false;\n    }\n}\n```"}]}, {"qid": 198, "title": "House Robber", "link": "https://leetcode.com/problems/house-robber/", "tags": ["Dynamic Programming"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP iterative memo", "text": "```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        for(int i=1; i<nums.length; i++){\n            dp[i] = nums[i];\n            if(i-2>=0) dp[i] += dp[i-2];\n            if(i-3>=0) dp[i] = Math.max(dp[i], dp[i-3]+nums[i]);\n        }\n        int result = dp[nums.length-1];\n        if(nums.length-2 >=0 && dp[nums.length-2] > result) result = dp[nums.length-2];\n        return result;\n        // dp[i] = Math.max(dp[i-2]+nums[i], dp[i-3]+nums[i]);\n    }\n}\n```"}, {"title": "DP iterative + 2 variables", "text": "```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0)\n            return 0;\n        if(nums.length == 1)\n            return nums[0];\n        int a = nums[0], b = nums[1];\n        if(nums.length == 2)\n            return Math.max(a, b);\n        int c = a + nums[2];\n        for(int i=3; i<nums.length; i++){\n            int temp = Math.max(a+nums[i], b+nums[i]);\n            a = b;\n            b = c;\n            c = temp;\n        }\n        return Math.max(b, c);\n    }\n}\n```"}, {"title": "DP recursive", "text": "```java\nclass Solution {\n    private HashMap<Integer, Integer> map;\n    public Solution() {\n        map = new HashMap<Integer, Integer>();\n    }\n    public int rob(int[] nums) {\n        return rob(nums, nums.length-1);\n    }\n    public int rob(int[] nums, int i){\n        if(i < 0)\n            return 0;\n        if(i == 0)\n            return nums[0];\n        if(i == 1)\n            return Math.max(nums[0], nums[1]);\n        if(map.containsKey(i))\n            return map.get(i);\n        map.put(i, Math.max(rob(nums, i-1), rob(nums, i-2) + nums[i]));\n        return map.get(i);\n    }\n}\n```"}]}, {"qid": 213, "title": "House Robber II", "link": "https://leetcode.com/problems/house-robber-ii/", "tags": ["Dynamic Programming"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "2 pass House Robber I", "text": "```java\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n        return Math.max(rob(nums, 0, nums.length-1), rob(nums, 1, nums.length));\n    }\n    public int rob(int[] nums, int start, int end){\n        if(start >= end) return 0;\n        int[] dp = new int[end-start];\n        dp[0] = nums[start];\n        for(int i=start+1; i<end; i++){\n            dp[i-start] = nums[i];\n            if(i-2>=start) dp[i-start]+=dp[i-2-start];\n            if(i-3>=start) dp[i-start] = Math.max(dp[i-start], dp[i-3-start]+nums[i]);\n        }\n        int result = dp[end-1-start];\n        if(end-2>=start) result = Math.max(result, dp[end-2-start]);\n        return result;\n    }\n}\n```"}]}, {"qid": 337, "title": "House Robber III", "link": "https://leetcode.com/problems/house-robber-iii/", "tags": ["Tree", "DFS"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    public int rob(TreeNode root) {\n        return rob(root, false);\n    }\n    public int rob(TreeNode root, boolean parentRobbed){\n        if(root == null) return 0;\n        if(parentRobbed) return rob(root.left, false) + rob(root.right, false);\n        return Math.max(rob(root.left, false) + rob(root.right, false), \n                        rob(root.left, true) + rob(root.right, true) + root.val);\n    }\n}\n```"}, {"title": "DFS optimized (memo)", "text": "```java\nclass Solution {\n    public int rob(TreeNode root) {\n        Tuple tup = DFS(root);\n        return Math.max(tup.robRoot, tup.notRobRoot);\n    }\n    private Tuple DFS(TreeNode root) {\n        if(root == null) return new Tuple(0,0);\n        Tuple l = DFS(root.left);\n        Tuple r = DFS(root.right);\n        int robRoot = root.val + l.notRobRoot + r.notRobRoot;\n        int notRobRoot = Math.max(l.notRobRoot + r.notRobRoot, \n                                  Math.max(l.notRobRoot + r.robRoot, \n                                           Math.max(l.robRoot + r.notRobRoot, \n                                                    l.robRoot + r.robRoot)));\n        return new Tuple(robRoot, notRobRoot);\n    }\n}\npublic class Tuple {\n    int robRoot, notRobRoot;\n    Tuple(int a, int b){\n        robRoot = a;\n        notRobRoot = b;\n    }\n}\n```"}]}, {"qid": 66, "title": "Plus One", "link": "https://leetcode.com/problems/plus-one/", "tags": ["Array", "Math"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "\u6570\u7ec4\u521d\u59cb\u5316", "text": "\u6ce8\u610f\uff1a\u9ed8\u8ba4\u521d\u59cb\u5316\uff0c\u6570\u7ec4\u5143\u7d20\u76f8\u5f53\u4e8e\u5bf9\u8c61\u7684\u6210\u5458\u53d8\u91cf\uff0c\u9ed8\u8ba4\u503c\u8ddf\u6210\u5458\u53d8\u91cf\u7684\u89c4\u5219\u4e00\u6837\u3002**\u6570\u5b570**\uff0c\u5e03\u5c14false\uff0cchar\\u0000\uff0c\u5f15\u7528\uff1anull\n\n\u672c\u9898\u4e0d\u9002\u5408\u628a`Arrays.asList()`\u8f6c\u5316\u4e3aList, `.asList`\u65b9\u6cd5\u4e0d\u9002\u7528\u4e8e\u57fa\u672c\u6570\u636e\u7c7b\u578b\uff08byte, short, int, long, float, double, boolean\uff09\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        for(int i=digits.length-1; i>=0; i--){\n            if(digits[i]<9){\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        int[] ret = new int[digits.length+1];\n        ret[0] = 1;\n        return ret;\n    }\n}\n```"}]}, {"qid": 172, "title": "Factorial Trailing Zeroes", "link": "https://leetcode.com/problems/factorial-trailing-zeroes/", "tags": ["Math"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Increment (Time Limit Exceeded)", "text": "Time: O(n)\n```java\nclass Solution {\n    public int trailingZeroes(int n) {\n        int count = 0;\n        for(int i=1; i<=n; i++){\n            int temp = i;\n            while(temp%5 == 0 && temp>0){\n                count++;\n                temp /= 5;\n            }\n        }\n        return count;\n    }\n}\n```"}, {"title": "Recursive", "text": "1\\*2\\*3 --multiply by three 5-> 1\\*2\\*3\\*4\\***5**\\*6\\*7\\*8\\*9\\***10**\\*11\\*12\\*13\\*14\\***15**\n\nTime: O(logn)\n```java\nclass Solution {\n    public int trailingZeroes(int n) {\n        if(n<5)\n            return 0;\n        return trailingZeroes(n/5) + n/5;\n    }\n}\n```"}, {"title": "Iterative", "text": "Similar to the Recursive method\n```java\nclass Solution {\n    public int trailingZeroes(int n) {\n        int count = 0;\n        while(n>4){\n            n /= 5;\n            count += n;\n        }\n        return count;\n    }\n}\n```"}]}, {"qid": 155, "title": "Min Stack", "link": "https://leetcode.com/problems/min-stack/", "tags": ["Stack", "Design"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Use two stacks", "text": "Store series of minValue into another stack to obtain O(1) time!\n```java\nclass MinStack {\n    Stack<Integer> minst, numst;\n\n    public MinStack() {\n        minst = new Stack<Integer>();\n        numst = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        numst.push(x);\n        if(minst.empty()) minst.push(x);\n        else{\n            minst.push(Math.min(minst.peek(), x));\n        }\n    }\n    \n    public void pop() {\n        minst.pop();\n        numst.pop();\n    }\n    \n    public int top() {\n        return numst.peek();\n    }\n    \n    public int getMin() {\n        return minst.peek();\n    }\n}\n```"}, {"title": "only use one Stack", "text": "1. Use only one stack by storing the gap between min value and current value in it. \n2. Since we store differences of integers, we need to convert it into `Long`. \n```java\nclass MinStack {\n    long min;\n    Stack<Long> st;\n\n    public MinStack() {\n        st = new Stack<Long>();\n        min = Integer.MAX_VALUE;\n    }\n    \n    public void push(int x) {\n        st.push(x-min);\n        if(x<min)\n            min = x;\n    }\n    \n    public void pop() {\n        long temp = st.pop();\n        if(temp<0)\n            min -= temp;\n    }\n    \n    public int top() {\n        long temp = st.peek();\n        if(temp<0)\n            return (int)min;\n        return (int)(temp + min);\n    }\n    \n    public int getMin() {\n        return (int)min;\n    }\n}\n```"}]}, {"qid": 234, "title": "Palindrome Linked List", "link": "https://leetcode.com/problems/palindrome-linked-list/", "tags": ["Linked List", "Two Pointers"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "halve and reverse", "text": "```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if(head == null) return true;\n        \n        int count = countListNode(head);\n        ListNode mid = moveToMid(head, count);\n        if(count%2==0){\n            ListNode temp = mid.next;\n            mid.next = null;\n            mid = temp;\n        }\n        ListNode reverse = getReversedList(mid);\n        while(reverse!=null && head!=null){\n            if(reverse.val != head.val)\n                return false;\n            reverse = reverse.next;\n            head = head.next;\n        }\n        return true;\n    }\n    private int countListNode(ListNode head){\n        int count = 0;\n        while(head!=null){\n            count++;\n            head = head.next;\n        }\n        return count;\n    }\n    private ListNode moveToMid(ListNode head, int count){\n        ListNode p = head;\n        for(int i=0; i<count/2-1; i++){\n            p = p.next;\n        }\n        if(count%2==1) p = p.next;\n        return p;\n    }\n    private ListNode getReversedList(ListNode head){\n        ListNode newhead = null;\n        while(head!=null){\n            ListNode temp = head.next;\n            head.next = newhead;\n            newhead = head;\n            head = temp;\n        }\n        return newhead;\n    }\n}\n```"}]}, {"qid": 14, "title": "Longest Common Prefix", "link": "https://leetcode.com/problems/longest-common-prefix/", "tags": ["String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "compare chars in each position", "text": "```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0) return \"\";\n        int count = 0, minLen = Integer.MAX_VALUE;\n        for(String s: strs)\n            if(minLen>s.length())\n                minLen = s.length();\n        while(count<minLen){\n            char c = strs[0].charAt(count);\n            for(int i=1; i<strs.length; i++){\n                if(strs[i].charAt(count)!=c)\n                    return strs[0].substring(0, count);\n            }\n            count++;\n        }\n        return strs[0].substring(0, count);\n    }\n}\n```"}, {"title": "String.indexOf", "text": "```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs == null || strs.length == 0)    return \"\";\n        String pre = strs[0];\n        int i = 1;\n        while(i < strs.length){\n            while(strs[i].indexOf(pre) != 0)\n                pre = pre.substring(0,pre.length()-1);\n            i++;\n        }\n        return pre;\n    }\n}\n```"}, {"title": "sort and compare the first and last String", "text": "```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs == null || strs.length == 0)    return \"\";\n        Arrays.sort(strs);\n        int count = 0;\n        String a=strs[0], b=strs[strs.length-1];\n        for(int i=0; i<a.length(); i++){\n            if(b.length()>i && b.charAt(i)==a.charAt(i))\n                count++;\n            else\n                return a.substring(0, count);\n        }\n        return a.substring(0, count);\n    }\n}\n```"}]}, {"qid": 160, "title": "Intersection of Two Linked Lists", "link": "https://leetcode.com/problems/intersection-of-two-linked-lists/", "tags": ["Linked List"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "turning into a loop", "text": "We don't need to know the length of each lists. We just want to ensure that two pointers reach the intersection point at the same time. \n\nNotice that `a` and `b` will eventually be `null` if the two linked lists have no intersection. Therefore, we have no need to worry about infinite loop problem. \n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA, b = headB;\n        while(a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```"}, {"title": "get lengths and eliminate differences", "text": "```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = getLen(headA), lenB = getLen(headB);\n        while(lenA>lenB){\n            headA = headA.next;\n            lenA--;\n        }\n        while(lenB>lenA){\n            headB = headB.next;\n            lenB--;\n        }\n        while(headA!=headB){\n            headA = headA.next;\n            headB = headB.next;\n        }\n        return headA;\n    }\n    private int getLen(ListNode head){\n        int count = 0;\n        ListNode p = head;\n        while(p!=null){\n            p = p.next;\n            count++;\n        }\n        return count;\n    }\n}\n```"}]}, {"qid": 28, "title": "Implement strStr()", "link": "https://leetcode.com/problems/implement-strstr/", "tags": ["Two Pointers", "String"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "KMP", "text": "[\u539f\u7406\u8bb2\u89e3(\u5ffd\u7565\u4ee3\u7801\u90e8\u5206)](https://m.toutiaocdn.com/group/6578243698759303688/?iid=59744622620&app=news_article&timestamp=1549524948&group_id=6578243698759303688&tt_from=copy_link&utm_source=copy_link&utm_medium=toutiao_ios&utm_campaign=client_share)\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int[] next = getNextArray(needle);\n        int i=0, j=0;\n        while(j<needle.length() && i<haystack.length()){\n            while(haystack.charAt(i)!=needle.charAt(j) && j>0){\n                j = next[j];\n            }\n            if(haystack.charAt(i)==needle.charAt(j))\n                j++;\n            i++;\n        }\n        if(j==needle.length())\n            return i-needle.length();\n        return -1;\n    }\n    private int[] getNextArray(String s){\n        int[] next = new int[s.length()];\n        for(int i=2; i<s.length(); i++){\n            int maxCommonLen = next[i-1];\n            while(maxCommonLen>0 && s.charAt(i-1) != s.charAt(maxCommonLen)){\n                maxCommonLen = next[maxCommonLen];\n            }\n            if(s.charAt(i-1) == s.charAt(maxCommonLen))\n                next[i] = maxCommonLen+1;\n        }\n        return next;\n    }\n}\n```"}]}, {"qid": 190, "title": "Reverse Bits", "link": "https://leetcode.com/problems/reverse-bits/", "tags": ["Bit Manipulation"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "move bit one by one", "text": "```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int result = 0;\n        for(int i=0; i<32; i++){\n            result |= ((n&1)<<(31-i));\n            n = n>>>1;\n        }\n        return result;\n    }\n}\n```"}, {"title": "divide and conquer", "text": "```java\npublic class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        n = (n>>>16) | (n<<16);\n        n = ((n&0xFF00FF00)>>>8) | ((n&0x00FF00FF)<<8);\n        n = ((n&0xF0F0F0F0)>>>4) | ((n&0x0F0F0F0F)<<4);\n        n = ((n&0xCCCCCCCC)>>>2) | ((n&0x33333333)<<2);\n        n = ((n&0xAAAAAAAA)>>>1) | ((n&0x55555555)<<1);\n        return n;\n    }\n}\n```"}]}, {"qid": 189, "title": "Rotate Array", "link": "https://leetcode.com/problems/rotate-array/", "tags": ["Array"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "rotate partially", "text": "Attention that `k` needs to be reduced to [0, nums.length).\n```java\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        rotate(nums, 0, nums.length-k-1);\n        rotate(nums, nums.length-k, nums.length-1);\n        rotate(nums, 0, nums.length-1);\n    }\n    private void rotate(int[] nums, int l, int r){\n        while(l<r)\n            swap(nums, l++, r--);\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```"}]}, {"qid": 238, "title": "Product of Array Except Self", "link": "https://leetcode.com/problems/product-of-array-except-self/", "tags": ["Array"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Use only one array", "text": "```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] left = new int[nums.length];\n        // int[] right = new int[nums.length];\n        left[0] = 1;\n        for(int i=1; i<nums.length; i++)\n            left[i] = left[i-1]*nums[i-1];\n        // right[nums.length-1] = 1;\n        int right = 1;\n        for(int i=nums.length-2; i>=0; i--){\n            // right[i] = right[i+1]*nums[i+1];\n            right *= nums[i+1];\n            left[i] *= right;\n        }\n        // for(int i=0; i<nums.length; i++)\n        //     left[i] *= right[i];\n        return left;\n    }\n}\n```"}]}, {"qid": 347, "title": "Top K Frequent Elements", "link": "https://leetcode.com/problems/top-k-frequent-elements/", "tags": ["Hash Table", "Heap"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashMap", "text": "```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int num: nums)\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        HashMap<Integer, List<Integer>> freq2list = new HashMap<Integer, List<Integer>>();\n        for(int num: map.keySet()){\n            int freq = map.get(num);\n            if(freq2list.get(freq)==null)\n                freq2list.put(freq, new ArrayList<Integer>());\n            freq2list.get(freq).add(num);\n        }\n        List<Integer> result = new ArrayList<Integer>();\n        for(int i=nums.length; i>=1 && k>0; i--){\n            if(freq2list.containsKey(i)){\n                result.addAll(freq2list.get(i));\n                k -= freq2list.get(i).size();\n            }\n        }\n        return result;\n    }\n}\n```"}, {"title": "maxHeap and Map.Entry", "text": "```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int num: nums)\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        PriorityQueue<Map.Entry<Integer, Integer>> maxHeap = new PriorityQueue<>((a,b)->(b.getValue()-a.getValue()));\n        for(Map.Entry<Integer, Integer> entry: map.entrySet()){\n            maxHeap.add(entry);\n        }\n        List<Integer> result = new ArrayList<Integer>();\n        while(k>0){\n            result.add(maxHeap.poll().getKey());\n            k--;\n        }\n        return result;\n    }\n}\n```"}, {"title": "TreeMap", "text": "```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int num: nums)\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        TreeMap<Integer, List<Integer>> freq2list = new TreeMap<>();\n        for(int num: map.keySet()){\n            int freq = map.get(num);\n            if(freq2list.get(freq) == null)\n                freq2list.put(freq, new ArrayList<Integer>());\n            freq2list.get(freq).add(num);\n        }\n        List<Integer> result = new ArrayList<Integer>();\n        while(k>0){\n            Map.Entry<Integer, List<Integer>> entry = freq2list.pollLastEntry();\n            result.addAll(entry.getValue());\n            k -= entry.getValue().size();\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 384, "title": "Shuffle an Array", "link": "https://leetcode.com/problems/shuffle-an-array/", "tags": ["Design"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "swap step by step", "text": "```java\nclass Solution {\n    private int[] arr;\n    public Solution(int[] nums) {\n        arr = nums;\n    }\n    /** Resets the array to its original configuration and return it. */\n    public int[] reset() {\n        return arr;\n    }\n    /** Returns a random shuffling of the array. */\n    public int[] shuffle() {\n        if(arr==null) return null;\n        int[] newArr = arr.clone();\n        Random rand = new Random();\n        for(int i=newArr.length-1; i>=1; i--){\n            int randpos = rand.nextInt(i+1);\n            swap(newArr, i, randpos);\n        }\n        return newArr;\n    }\n    private static void swap(int[] nums,int i,int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```"}]}, {"qid": 378, "title": "Kth Smallest Element in a Sorted Matrix", "link": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/", "tags": ["Binary Search", "Heap"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Max Heap", "text": "```java\npublic class Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        PriorityQueue<Tuple> qu = new PriorityQueue<>();\n        for(int i=0; i<n; i++){\n            qu.add(new Tuple(0, i, matrix[0][i]));\n        }\n        Tuple temp = qu.peek();\n        for(int i=0; i<k; i++){\n            temp = qu.poll();\n            if(temp.row < n-1)\n                qu.add(new Tuple(temp.row+1, temp.col, matrix[temp.row+1][temp.col]));\n        }\n        return temp.val;\n    }\n}\nclass Tuple implements Comparable<Tuple> {\n    int row, col, val;\n    public Tuple(int x, int y, int v){\n        row = x; col = y; val = v;\n    }\n    @Override\n    public int compareTo(Tuple o){\n        return this.val - o.val;\n    }\n}\n```"}, {"title": "Binary Search", "text": "<span id=\"378-binary-search\"></span>\n1. Attention: when `count == k`, `mid` might not exists in `matrix`, so we need to get the largest element that is less than or equal to `mid` in `matrix`. Therefore, we have `getMaxlte`.\n2. There's a situation that might break the while loop, i.e., there are more than one elements that have the same value as the kth smallest. When this happens, r will goes below l, and it breaks the while loop. Therefore, we need to return `l` instead of an arbitrary number outside the while loop. \n3. The whole picture of this algorithm:\n> The key point for any binary search is to figure out the \"Search Space\". For me, I think there are two kind of \"Search Space\" -- index and range(the range from the smallest number to the biggest number). Most usually, when the array is sorted in one direction, we can use index as \"search space\", when the array is unsorted and we are going to find a specific number, we can use \"range\". \n\nSimilar to [287. Find the Duplicate Number](#287-binary-search).\n\n```java\nclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        int l = matrix[0][0], r = matrix[n-1][n-1];\n        while(l<=r){\n            int mid = l + ((r-l)>>1);\n            int count = countlte(matrix, mid);\n            if(count == k)\n                return getMaxlte(matrix, mid);\n            else if(count > k)\n                r = mid - 1;\n            else \n                l = mid + 1;\n        }\n        return l;\n    }\n    private int countlte(int[][] matrix, int target){\n        int n = matrix.length, count = 0;\n        for(int[] row: matrix){\n            int j = n;\n            while(j>0 && row[j-1] > target)\n                j--;\n            count += j;\n        }\n        return count;\n    }\n    private int getMaxlte(int[][] matrix, int target){\n        int maxVal = Integer.MIN_VALUE;\n        int n = matrix.length;\n        for(int[] row: matrix)\n            for(int ele: row)\n                if(ele <= target && maxVal < ele)\n                    maxVal = ele;\n        return maxVal;\n    }\n    \n}\n```"}]}, {"qid": 287, "title": "Find the Duplicate Number", "link": "https://leetcode.com/problems/find-the-duplicate-number/", "tags": ["Array", "Two Pointers", "Binary Search"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Binary Search", "text": "<span id=\"287-binary-search\"></span>\nSimilar to [378. Kth Smallest Element in a Sorted Matrix](#378-binary-search)\n```java\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int n = nums.length - 1;\n        int l = 1, r = n;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            int count = countLTE(nums, mid);\n            if(count > mid)\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n    private int countLTE(int[] nums, int target){\n        int count = 0;\n        for(int num: nums)\n            if(num <= target)\n                count++;\n        return count;\n    }\n}\n```"}, {"title": "slow-fast two pointers", "text": "<span id=\"287-two-pointers\"></span>\nSimilar to [142. Linked List Cycle II](#142-two-pointers)\n```java\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = 0, fast = 0;\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        }\n        while(slow!=fast);\n        fast = 0;\n        while(slow != fast){\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return slow;\n    }\n}\n```"}]}, {"qid": 142, "title": "Linked List Cycle II", "link": "https://leetcode.com/problems/linked-list-cycle-ii/", "tags": ["Linked List", "Two Pointers"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "slow-fast two pointers", "text": "<span id=\"142-two-pointers\"></span>\nSimilar to [287. Find the Duplicate Number](#287-two-pointers)\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode slow = head, fast = head;\n        do{\n            if(fast.next == null || fast.next.next == null)\n                return null;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        while(slow != fast);\n        fast = head;\n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```"}]}, {"qid": 328, "title": "Odd Even Linked List", "link": "https://leetcode.com/problems/odd-even-linked-list/", "tags": ["Linked List"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "two heads", "text": "```java\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if(head == null) return null;\n        ListNode curr = head, odd = head, even = head.next;\n        while(curr.next != null){\n            ListNode temp = curr.next;\n            curr.next = temp.next;\n            curr = temp;\n        }\n        curr = odd;\n        while(curr.next != null)\n            curr = curr.next;\n        curr.next = even;\n        return odd;\n    }\n}\n```"}]}, {"qid": 102, "title": "Binary Tree Level Order Traversal", "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/", "tags": ["Tree", "BFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "BFS", "text": "<span id=\"102-BFS\"></span>\nSimilar to [103. Binary Tree Zigzag Level Order Traversal](#103-BFS)\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        Queue<TreeNode> qu = new LinkedList<>();\n        qu.add(root);\n        List<Integer> row = new ArrayList<>();\n        int count = 1;\n        while(!qu.isEmpty()){\n            TreeNode temp = qu.poll();\n            if(temp.left != null)\n                qu.add(temp.left);\n            if(temp.right != null)\n                qu.add(temp.right);\n            row.add(temp.val);\n            count--;\n            if(count == 0){\n                count = qu.size();\n                result.add(row);\n                row = new ArrayList<>();\n            }\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 341, "title": "Flatten Nested List Iterator", "link": "https://leetcode.com/problems/flatten-nested-list-iterator/", "tags": ["Stack", "Design"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "not real iterator", "text": "```java\npublic class NestedIterator implements Iterator<Integer> {\n    Stack<NestedInteger> st;\n    public NestedIterator(List<NestedInteger> nestedList) {\n        st = new Stack<>();\n        for(int i=nestedList.size()-1; i>=0; i--)\n            st.push(nestedList.get(i));\n    }\n    @Override\n    public Integer next() {\n        if(!hasNext()) return null;\n        return st.pop().getInteger();\n    }\n    @Override\n    public boolean hasNext() {\n        while(!st.empty()){\n            NestedInteger curr = st.peek();\n            if(curr.isInteger()){\n                return true;\n            }\n            else{\n                st.pop();\n                List<NestedInteger> list = curr.getList();\n                for(int i=list.size()-1; i>=0; i--)\n                    st.push(list.get(i));\n            }\n        }\n        return false;\n    }\n}\n```"}, {"title": "real iterator", "text": "```java\npublic class NestedIterator implements Iterator<Integer> {\n    Stack<ListIterator<NestedInteger>> st;\n    public NestedIterator(List<NestedInteger> nestedList) {\n        st = new Stack<>();\n        st.push(nestedList.listIterator());\n    }\n    @Override\n    public Integer next() {\n        if(!hasNext()) return null;\n        return st.peek().next().getInteger();\n    }\n    @Override\n    public boolean hasNext() {\n        while(!st.empty()){\n            if(!st.peek().hasNext()){\n                st.pop();\n            }\n            else{\n                NestedInteger curr = st.peek().next();\n                if(curr.isInteger()) {\n                    st.peek().previous();\n                    return true;\n                }\n                st.push(curr.getList().listIterator());\n            }\n        }\n        return false;\n    }\n}\n```"}]}, {"qid": 48, "title": "Rotate Image", "link": "https://leetcode.com/problems/rotate-image/", "tags": ["Array"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Onion", "text": "```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        // rotate(matrix, 0, matrix.length-1);\n        for(int i=0, j=matrix.length-1; i<j; i++, j--){\n            rotate(matrix, i, j);\n        }\n    }\n    private void rotate(int[][] matrix, int min, int max){\n        if(min >= max) return ;\n        int len = max-min;\n        for(int i=0; i<len; i++){\n            int temp = matrix[min][min+i];\n            matrix[min][min+i] = matrix[max-i][min];\n            matrix[max-i][min] = matrix[max][max-i];\n            matrix[max][max-i] = matrix[min+i][max];\n            matrix[min+i][max] = temp;\n        }\n        // rotate(matrix, min+1, max-1);\n    }\n}\n```"}, {"title": "swap", "text": "```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        reverse(matrix);\n        int n = matrix.length;\n        for(int i=0; i<n; i++)\n            for(int j=i+1; j<n; j++)\n                diagSwap(matrix, i, j);\n    }\n    private void reverse(int[][] matrix){\n        int l=0, r=matrix.length-1;\n        while(l<r)\n            swap(matrix, l++, r--);\n    }\n    private void swap(int[][] matrix, int i, int j){\n        int[] temp = matrix[i];\n        matrix[i] = matrix[j];\n        matrix[j] = temp;\n    }\n    private void diagSwap(int[][] matrix, int i, int j){\n        int temp = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = temp;\n    }\n}\n```"}]}, {"qid": 62, "title": "Unique Paths", "link": "https://leetcode.com/problems/unique-paths/", "tags": ["Array", "Dynamic Programming"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP", "text": "This is a space-optimized DP solution. `dp[i][j] = dp[i-1][j] + dp[i][j-1]`\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] dp = new int[m];\n        Arrays.fill(dp, 1);\n        for(int i=1; i<n; i++)\n            for(int j=1; j<m; j++) \n                dp[j] += dp[j-1];\n        return dp[dp.length-1];\n    }\n}\n```"}, {"title": "Math", "text": "This is a tricky solution. By observing the DP matrix,\n```\n1   1   1   1\n1   2   3   4\n1   3   6   10\n1   4   10  20\n1   5   15  35\n1   6   21  56\n```\nwe can see a Pascal's triangle in the diagonal direction.\nTherefore, we have formula `$C_{m+n-2}^{m-1}$` for the final result.\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        m--; n--;\n        int min = Math.min(m, n);\n        if(min == 0) return 1;\n        long a = factorial(m+n, m+n-min+1);\n        long b = factorial(min, 1);\n        return (int)(a/b);\n    }\n    private long factorial(int max, int min){\n        long result = (long)min;\n        for(int i=min+1; i<=max; i++)\n            result *= i;\n        return result;\n    }\n}\n```"}]}, {"qid": 215, "title": "Kth Largest Element in an Array", "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/", "tags": ["Divide and Conquer", "Heap"], "difficulty": 4, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Quick Selection", "text": "```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int l = 0, r = nums.length-1;\n        while(l<r){\n            int idx = partition(nums, l, r);\n            if(idx+1 == k) return nums[idx];\n            else if(idx+1 > k) r = idx-1; //\n            else l = idx+1; // how can this line deal with duplicates??\n        }\n        return nums[k-1];\n    }\n    private int partition(int[] nums, int l, int r){\n        int i=l, j=r+1;\n        while(true){\n            while(nums[++i] > nums[l] && i<r);\n            while(nums[l] > nums[--j] && j>l);\n            if(i>=j) break;\n            swap(nums, i, j);\n        }\n        swap(nums, l, j); //  It's j!! not i!!\n        return j;  //  It's j!! not i!!\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```"}]}, {"qid": 49, "title": "Group Anagrams", "link": "https://leetcode.com/problems/group-anagrams/", "tags": ["Hash Table", "Sting"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Encoding String into Integer by primes", "text": "```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<Integer, List<String>> map = new HashMap<>();\n        // int[] primes = getPrimes();\n        int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\n        for(String s: strs){\n            int num = getNum(primes, s);\n            if(!map.containsKey(num))\n                map.put(num, new ArrayList<>());\n            map.get(num).add(s);\n        }\n        List<List<String>> result = new ArrayList<>();\n        for(List<String> list : map.values()){\n            result.add(list);\n        }\n        return result;\n    }\n    // private int[] getPrimes(){\n    //     int[] primes = new int[26];\n    //     int k=0;\n    //     int N = 102;\n    //     boolean[] isPrime = new boolean[N];\n    //     for(int i=2; i<N; i++)\n    //         isPrime[i] = true;\n    //     for(int i=2; i<N; i++){\n    //         if(isPrime[i]){\n    //             primes[k++] = i;\n    //             if(k==26)  return primes;\n    //             for(int j=i+i; j<N; j+=i)\n    //                 isPrime[j] = false;\n    //         }\n    //     }\n    //     return null;\n    // }\n    private int getNum(int[] primes, String s){\n        int result = 1;\n        for(int i=0; i<s.length(); i++)\n            result *= primes[s.charAt(i)-'a'];\n        return result;\n    }\n}\n```"}, {"title": "Hashable Array", "text": "1. When implementing `HashArray.equals()`, the parameter `o` must be of type `Object`!!\n2. Pay attention to the usage of `map.computeIfAbsent` and its return value. \n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<HashArray, List<String>> map = new HashMap<>();\n        for(String s: strs){\n            HashArray ha = new HashArray(s);\n            map.computeIfAbsent(ha, key->new ArrayList<>()).add(s);\n        }\n        List<List<String>> result = new ArrayList<>();\n        for(List<String> list: map.values())\n            result.add(list);\n        return result;\n    }\n}\nclass HashArray {\n    int[] arr = new int[26];\n    public HashArray(String s){\n        for(char c: s.toCharArray())\n            arr[c-'a']++;\n    }\n    public boolean equals(Object o) {\n        return Arrays.equals(this.arr, ((HashArray)o).arr);\n    }\n    public int hashCode(){\n        return Arrays.hashCode(arr);\n    }\n}\n```"}]}, {"qid": 289, "title": "Game of Life", "link": "https://leetcode.com/problems/game-of-life/", "tags": ["Array"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Encoding all possible states", "text": "The key idea is to encode all 4 possible transitions:  \n    live -> live,  1  \n    live -> dead,  -1  \n    dead -> live,  2  \n    dead -> dead.  0  \n\nIn this way, we can calculate `num = (Math.abs(board[i][j])&1)`\n```java\nclass Solution {\n    public void gameOfLife(int[][] board) {\n        for(int i=0; i<board.length; i++)\n            for(int j=0; j<board[0].length; j++){\n                int num = countCells(board, i, j);\n                if(board[i][j] == 1)\n                    if(num<2 || num>3) \n                        board[i][j] = -1;\n                else\n                    if(num == 3)\n                        board[i][j] = 2;\n            }\n        for(int i=0; i<board.length; i++)\n            for(int j=0; j<board[0].length; j++){\n                if(board[i][j] == -1) board[i][j] = 0;\n                if(board[i][j] == 2) board[i][j] = 1;\n            }\n    }\n    private int countCells(int[][] board,int x,int y){\n        int count = 0;\n        for(int i=x-1; i<=x+1; i++)\n            for(int j=y-1; j<=y+1; j++){\n                if(i==x && j==y) continue;\n                if(i>=0 && j>=0 && i<board.length && j<board[0].length){\n                    count += (Math.abs(board[i][j])&1);\n                }\n            }\n        return count;\n    }\n}\n```"}]}, {"qid": 11, "title": "Container With Most Water", "link": "https://leetcode.com/problems/container-with-most-water/", "tags": ["Array", "Two Pointers"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Not My Solution", "text": "[Here is an awesome explanation!](https://leetcode.com/problems/container-with-most-water/discuss/6099/Yet-another-way-to-see-what-happens-in-the-O(n)-algorithm)\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int l = 0, r = height.length-1;\n        int area = Integer.MIN_VALUE;\n        while(l<r){\n            area = Math.max(area, Math.min(height[l], height[r])*(r-l));\n            if(height[l] < height[r]) l++;\n            else r--;\n        }\n        return area;\n    }\n}\n```"}]}, {"qid": 380, "title": "Insert Delete GetRandom O(1)", "link": "https://leetcode.com/problems/insert-delete-getrandom-o1/", "tags": ["Array", "Hash Table", "Design"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Tomb", "text": "```java\nclass RandomizedSet {\n    HashMap<Integer, Integer> map;\n    List<Integer> list;\n    Random rand;\n    /** Initialize your data structure here. */\n    public RandomizedSet() {\n        rand = new Random();\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    public boolean insert(int val) {\n        if(map.containsKey(val)) \n            return false;\n        map.put(val, list.size());\n        list.add(val);\n        return true;\n    }\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    public boolean remove(int val) {\n        if(!map.containsKey(val)) \n            return false;\n        int idx = map.get(val);\n        list.set(idx, null);\n        map.remove(val);\n        if(map.size() <= list.size()/2){\n            map = new HashMap<>();\n            List<Integer> newList = new ArrayList<>();\n            for(int i=0; i<list.size(); i++){\n                Integer num = list.get(i);\n                if(num != null){\n                    map.put(num, newList.size());\n                    newList.add(num);\n                }\n            }\n            list = newList;\n        }\n        return true;\n    }\n    /** Get a random element from the set. */\n    public int getRandom() {\n        while(true){\n            int idx = rand.nextInt(list.size());\n            Integer num = list.get(idx);\n            if(num!=null) return num;\n        }\n    }\n}\n```"}, {"title": "swap", "text": "```java\nclass RandomizedSet {\n    HashMap<Integer, Integer> map;\n    List<Integer> list;\n    Random rand;\n    /** Initialize your data structure here. */\n    public RandomizedSet() {\n        rand = new Random();\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    public boolean insert(int val) {\n        if(map.containsKey(val)) \n            return false;\n        map.put(val, list.size());\n        list.add(val);\n        return true;\n    }\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    public boolean remove(int val) {\n        if(!map.containsKey(val))  return false;\n        int idx = map.get(val);\n        if(idx < list.size()-1){\n            int lastone = list.get(list.size()-1);\n            map.put(lastone, idx);\n            list.set(idx, lastone);\n        }\n        list.remove(list.size()-1);\n        map.remove(val);\n        return true;\n    }\n    /** Get a random element from the set. */\n    public int getRandom() {\n        return list.get(rand.nextInt(list.size()));\n    }\n}\n```"}]}, {"qid": 36, "title": "Valid Sudoku", "link": "https://leetcode.com/problems/valid-sudoku/", "tags": ["Hash Table"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Encoding by self-defined Class", "text": "type == 0 --> row  \ntype == 1 --> col  \ntype == 2 --> 3x3 block  \n```java\nclass Solution {\n    public boolean isValidSudoku(char[][] board) {\n        HashSet<Tuple> st = new HashSet<>(3*81);\n        for(int i=0; i<9; i++)\n            for(int j=0; j<9; j++)\n                if(board[i][j] != '.'){\n                    char c = board[i][j];\n                    if(!st.add(new Tuple(0, i, c)) ||\n                       !st.add(new Tuple(1, j, c)) ||\n                       !st.add(new Tuple(2, i/3, j/3 ,c)))\n                        return false;\n                }\n        return true;\n    }\n}\nclass Tuple {\n    int type, i, j;\n    char c;\n    public Tuple(int t, int k, char ch){\n        this(t, k, k, ch);\n    }\n    public Tuple(int t, int x, int y, char ch){\n        c = ch;\n        type = t;\n        i = x;\n        j = y;\n    }\n    public boolean equals(Object o){\n        Tuple obj = (Tuple) o;\n        if(this.type != obj.type || this.c!=obj.c) return false;\n        if(type == 0) return this.i==obj.i;\n        if(type == 1) return this.j==obj.j;\n        else return this.i==obj.i && this.j==obj.j;\n    }\n    public int hashCode(){\n        return (Integer.hashCode(type) +\n            Integer.hashCode(i) +\n            Integer.hashCode(j) +\n            Integer.hashCode(c));\n    }\n}\n```"}, {"title": "Encoding by native String", "text": "\"r%d%c\" --> row  \n\"c%d%c\" --> col  \n\"b%d%d%c\" --> 3x3 block  \n```java\nclass Solution {\n    public boolean isValidSudoku(char[][] board) {\n        HashSet<String> st = new HashSet<>();\n        for(int i=0; i<9; i++)\n            for(int j=0; j<9; j++)\n                if(board[i][j] != '.'){\n                    char ch = board[i][j];\n                    if(!st.add(\"r\"+i+ch) || \n                       !st.add(\"c\"+j+ch) || \n                       !st.add(\"b\"+i/3+j/3+ch))\n                        return false;\n                }\n        return true;\n    }\n}\n```"}]}, {"qid": 75, "title": "Sort Colors", "link": "https://leetcode.com/problems/sort-colors/", "tags": ["Array", "Two Pointers", "Sort"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "one pass solution", "text": "two pointers\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int curr=0, i=0, j=nums.length-1;\n        while(curr<=j){\n            if(nums[curr] == 2) swap(nums, curr, j--);\n            else if(nums[curr] == 1) curr++;\n            else swap(nums, curr++, i++);\n        }\n    }\n    private void swap(int[] nums, int i, int j){\n        if(nums[i] != nums[j]){\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n    }\n}\n```"}, {"title": "two pass solution", "text": "Count\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int zeros=0, ones=0, twos=0;\n        for(int num: nums){\n            if(num==0) zeros++;\n            else if(num==1) ones++;\n            else twos++;\n        }\n        int i=0;\n        while(zeros-->0) nums[i++]=0;\n        while(ones-->0) nums[i++]=1;\n        while(twos-->0) nums[i++]=2;\n    }\n}\n```"}]}, {"qid": 162, "title": "Find Peak Element", "link": "https://leetcode.com/problems/find-peak-element/", "tags": ["Array", "Binary Search"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Binary Search differences of adjacent elements", "text": "```java\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(goesUp(nums, nums.length-1)) return nums.length-1;\n        int l=0, r=nums.length-1;\n        while(true){\n            int mid = l + ((r-l)>>1);\n            if(goesUp(nums, mid)) l = mid;\n            else r = mid;\n            if(l + 1 >= r) break;\n        }\n        return l;\n    }\n    private boolean goesUp(int[] nums, int idx){\n        if(idx == 0) return true;\n        return nums[idx]>nums[idx-1];\n    }\n}\n```"}, {"title": "binary search too", "text": "```java\nclass Solution {\n    public int findPeakElement(int[] nums) {\n        if(nums.length == 1) return 0;\n        // if(nums[0]>nums[1]) return 0;\n        if(nums[nums.length-1] > nums[nums.length-2]) return nums.length-1;\n        int l=0, r=nums.length-1;\n        while(l<r){\n            int mid = l+((r-l)>>1);\n            // if(nums[mid]>nums[mid-1]) l = mid;\n            // else r = mid-1;\n            if(nums[mid]>nums[mid+1]) r = mid;\n            else l = mid+1;\n        }\n        return l;\n    }\n}\n```"}]}, {"qid": 103, "title": "Binary Tree Zigzag Level Order Traversal", "link": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/", "tags": ["Stack", "Tree", "BFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "BFS", "text": "<span id=\"103-BFS\"></span>\nSimilar to [102. Binary Tree Level Order Traversal](#102-BFS)\n```java\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        Queue<TreeNode> qu = new LinkedList<>();\n        qu.add(root);\n        int count = 1;\n        List<Integer> list = new ArrayList<>();\n        while(!qu.isEmpty()){\n            TreeNode temp = qu.poll();\n            count--;\n            if(temp.left != null) qu.add(temp.left);\n            if(temp.right != null) qu.add(temp.right);\n            list.add(temp.val);\n            if(count == 0){\n                count = qu.size();\n                result.add(list);\n                list = new ArrayList<>();\n            }\n        }\n        for(int i=1; i<result.size(); i+=2)\n            reverse(result.get(i));\n        return result;\n    }\n    private void reverse(List<Integer> list){\n        int i=0, j=list.size()-1;\n        while(i<j)\n            Collections.swap(list, i++, j--);\n    }\n}\n```"}]}, {"qid": 279, "title": "Perfect Squares", "link": "https://leetcode.com/problems/perfect-squares/", "tags": ["Math", "Dynamic Programming", "BFS"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "static DP 298ms", "text": "```java\nclass Solution {\n    int maxSq;\n    HashMap<Integer,Integer> map;\n    public int numSquares(int n) {\n        maxSq = getSquares(n);\n        map = new HashMap<>();\n        return getNumSquares(n);\n    }\n    private int getNumSquares(int n){\n        if(n<=0) return 0;\n        if(map.containsKey(n)) return map.get(n);\n        int min = Integer.MAX_VALUE;\n        for(int i=1; i<=maxSq; i++){\n            int sq = i*i;\n            if(sq>n) break;\n            min = Math.min(min, 1 + getNumSquares(n-sq));\n        }\n        map.put(n, min);\n        return min;\n    }\n    private int getSquares(int n){\n        int l=1, r=46340;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            int sq = mid*mid;\n            if(sq == n) return mid;\n            else if(sq > n) r = mid;\n            else l = mid+1;\n        }\n        return l;\n    }\n}\n```"}, {"title": "DP 25ms", "text": "<span id=\"279-DP\" />\n\nSimilar to [322. Coin Change](#322-DP)\n```java\nclass Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n+1];\n        for(int i=2; i<n+1; i++) dp[i] = Integer.MAX_VALUE;\n        dp[1] = 1;\n        for(int i=2; i<=n; i++){\n            for(int j=1; j*j<=i; j++){\n                dp[i] = Math.min(dp[i], 1+dp[i-j*j]);\n            }\n        }\n        return dp[n];\n    }\n}\n```"}, {"title": "BFS 87ms", "text": "```java\nclass Solution {\n    public int numSquares(int n) {\n        Queue<Integer> qu = new LinkedList<>();\n        qu.add(n);\n        int count = 1, level = 0;\n        while(!qu.isEmpty()){\n            int curr = qu.poll();\n            count--;\n            if(curr == 0) return level;\n            for(int i=1; i*i<=curr; i++){\n                int val = curr-i*i;\n                if(val == 0) return level+1;\n                qu.add(val);\n            }\n            if(count == 0){\n                count = qu.size();\n                level++;\n            }\n        }\n        return 0;\n    }\n}\n```"}]}, {"qid": 322, "title": "Coin Change", "link": "https://leetcode.com/problems/coin-change/", "tags": ["Dynamic Programming"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP", "text": "<span id=\"322-DP\" />\n\nSimilar to [279. Perfect Squares](#279-DP)\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(amount == 0) return 0;\n        if(coins.length == 0) return -1;\n        int[] dp = new int[amount+1];\n        Arrays.fill(dp, -1);\n        Arrays.sort(coins);\n        dp[0] = 0;\n        for(int i=0; i<=amount; i++){\n            for(int coin : coins){\n                if(coin > i) break;\n                if(dp[i-coin] == -1) continue;\n                dp[i] = dp[i] == -1 ? dp[i-coin]+1 : Math.min(dp[i], dp[i-coin]+1);\n            }\n        }\n        return dp[amount];\n    }\n}\n```"}, {"title": "still DP, but init with a self-defined maxVal instead of -1", "text": "```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(amount == 0) return 0;\n        if(coins.length == 0) return -1;\n        int[] dp = new int[amount+1];\n        int maxVal = amount+1;\n        Arrays.fill(dp, maxVal);\n        Arrays.sort(coins);\n        dp[0] = 0;\n        for(int i=0; i<=amount; i++){\n            for(int coin : coins){\n                if(coin > i) break;\n                dp[i] = Math.min(dp[i], dp[i-coin]+1);\n            }\n        }\n        return dp[amount] == maxVal ? -1 : dp[amount];\n    }\n}\n```"}]}, {"qid": 240, "title": "Search a 2D Matrix II", "link": "https://leetcode.com/problems/search-a-2d-matrix-ii/", "tags": ["Binary Search", "Divide and Conquer"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "BST", "text": "```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if(matrix.length == 0 || matrix[0].length==0) return false;\n        int m = matrix.length, n = matrix[0].length;\n        int i=0, j=n-1;\n        while(i<m && j>=0){\n            if(matrix[i][j] == target) return true;\n            else if(matrix[i][j] < target) i++;\n            else j--;\n        }\n        return false;\n    }\n}\n```"}]}, {"qid": 300, "title": "Longest Increasing Subsequence", "link": "https://leetcode.com/problems/longest-increasing-subsequence/", "tags": ["Binary Search", "Dynamic Programming"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP O(n^2)", "text": "```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] dp = new int[nums.length];\n        Arrays.fill(dp, 1);\n        for(int i=1; i<nums.length; i++){\n            for(int j=0; j<i; j++){\n                if(nums[j] < nums[i]){\n                    dp[i] = Math.max(dp[i], 1+dp[j]);\n                }\n            }\n        }\n        int result = 0;\n        for(int i=0; i<dp.length; i++){\n            if(result < dp[i]) result = dp[i];\n        }\n        return result;\n    }\n}\n```"}, {"title": "binary search O(nlogn)", "text": "<span id=\"300-binary-search\"></span>\n`tails[i]` = the min value of the last elements of all subsequences with length of i+1. \n\nSimilar to [334. Increasing Triplet Subsequence](#334-binary-search)\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] tails = new int[nums.length];\n        int maxLen = 0;\n        for(int num: nums){\n            int idx = Arrays.binarySearch(tails, 0, maxLen, num);\n            if(idx<0) idx = -(idx+1);\n            tails[idx] = num;\n            if(maxLen == idx) maxLen++;\n        }\n        return maxLen;\n    }\n}\n```"}]}, {"qid": 334, "title": "Increasing Triplet Subsequence", "link": "https://leetcode.com/problems/increasing-triplet-subsequence/", "tags": [""], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "binary search", "text": "<span id=\"334-binary-search\"></span>\nSimilar to [300. Longest Increasing Subsequence](#300-binary-search)\n```java\nclass Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int[] tails = new int[3];\n        int maxLen = 0;\n        for(int num: nums){\n            int idx = getIdx(tails, maxLen, num);\n            tails[idx] = num;\n            if(idx == maxLen) maxLen++;\n            if(maxLen == 3) return true;\n        }\n        return false;\n    }\n    private int getIdx(int[] tails, int maxLen, int num){\n        for(int i=0; i<maxLen; i++){\n            if(num <= tails[i]) return i;\n        }\n        return maxLen;\n    }\n}\n```"}, {"title": "another binary search", "text": "```java\nclass Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int a=Integer.MAX_VALUE, b=Integer.MAX_VALUE;\n        for(int num: nums){\n            if(num<=a) a = num;\n            else if(num<=b) b = num;\n            else return true;\n        }\n        return false;\n    }\n}\n```"}]}, {"qid": 105, "title": "Construct Binary Tree from Preorder and Inorder Traversal", "link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/", "tags": ["Array", "Tree", "DFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return buildTree(preorder, 0, inorder, 0, inorder.length);\n    }\n    private TreeNode buildTree(int[] preorder, int m, \n                               int[] inorder, int n, int len){\n        if(len == 0) return null;\n        TreeNode root = new TreeNode(preorder[m]);\n        int mid = indexOf(inorder, n, len, root.val);\n        root.left = buildTree(preorder, m+1, inorder, n, mid-n);\n        root.right = buildTree(preorder, m+(mid-n+1), inorder, mid+1, len-(mid-n+1));\n        return root;\n    }\n    private int indexOf(int[] nums, int start, int len, int target){\n        for(int i=start; i<start+len; i++)\n            if(nums[i]==target)\n                return i;\n        return -1;\n    }\n}\n```"}]}, {"qid": 73, "title": "Set Matrix Zeroes", "link": "https://leetcode.com/problems/set-matrix-zeroes/", "tags": ["Array"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "O(mn) time and O(1) space", "text": "```java\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        if(matrix.length==0 || matrix[0].length==0) return ;\n        // check whether the first row has zero;\n        boolean firstRowZero = false;\n        for(int j=0; j<matrix[0].length; j++)\n            if(matrix[0][j]==0){\n                firstRowZero = true;\n                break;\n            }\n        // Set all rows that have zero to zeros, and mark the zero column in the first row\n        for(int i=1; i<matrix.length; i++){\n            boolean rowZero = false;\n            for(int j=0; j<matrix[0].length; j++){\n                if(matrix[i][j]==0){\n                    rowZero = true;\n                    matrix[0][j] = 0;\n                }\n            }\n            if(rowZero) Arrays.fill(matrix[i], 0);\n        }\n        // Set all the zero columns to zeros\n        for(int j=0; j<matrix[0].length; j++)\n            if(matrix[0][j]==0)\n                for(int i=1; i<matrix.length; i++)\n                    matrix[i][j] = 0;\n        // deal with the first row\n        if(firstRowZero) Arrays.fill(matrix[0], 0);\n    }\n}\n```"}]}, {"qid": 395, "title": "Longest Substring with At Least K Repeating Characters", "link": "https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/", "tags": [""], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "two pointers", "text": "```java\nclass Solution {\n    public int longestSubstring(String s, int k) {\n        return longestSubstring(s, 0, s.length()-1, k);\n    }\n    public int longestSubstring(String s, int l, int r, int k){\n        if(r-l+1 < k) return 0;\n        int[] stat = new int[26];\n        for(int i=l; i<=r; i++) stat[s.charAt(i)-'a']++;\n        int charIdx = getCharIdx(stat, k);\n        while(l<=r && charIdx != -1){\n            if(s.charAt(r)-'a' == charIdx){\n                stat[charIdx]--;\n                r--;\n            }\n            else if (s.charAt(l)-'a' == charIdx){\n                stat[charIdx]--;\n                l++;\n            }\n            else {\n                for(int i=l; i<=r; i++)\n                    if(s.charAt(i)-'a' == charIdx){\n                        return Math.max(longestSubstring(s, l, i-1, k), \n                                        longestSubstring(s, i+1, r, k));\n                    }\n            }\n            if(stat[charIdx] == 0) charIdx = getCharIdx(stat, k);\n        }\n        if(l>r) return 0;\n        return r-l+1;\n    }\n    private int getCharIdx(int[] stat, int k){\n        for(int j=0; j<26; j++)\n            if(stat[j]>0 && stat[j]<k)\n                return j;\n        return -1;\n    }\n}\n```"}]}, {"qid": 207, "title": "Course Schedule", "link": "https://leetcode.com/problems/course-schedule/", "tags": ["BFS", "DFS", "Graph", "Topological Sort"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Topological Sort", "text": "<span id=\"207-topo-sort\"></span>\nSimilar to [210. Course Schedule II](#210-topo-sort)\n```java\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] degrees = new int[numCourses];\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        for(int[] edge: prerequisites)\n            graph.computeIfAbsent(edge[1], key->new ArrayList<>()).add(edge[0]);\n        for(int[] edge: prerequisites) \n            degrees[edge[0]]++;\n        Queue<Integer> qu = new LinkedList<>();\n        for(int i=0; i<numCourses; i++)\n            if(degrees[i] == 0) qu.add(i);\n        while(!qu.isEmpty()){\n            int course = qu.poll();\n            if(graph.containsKey(course))\n                for(int subCourse: graph.get(course))\n                    if(--degrees[subCourse] == 0) qu.add(subCourse);\n        }\n        for(int degree: degrees)\n            if(degree>0) return false;\n        return true;\n    }\n}\n```"}, {"title": "DFS", "text": "1. Use `visiting` array to trace along the DFS path. Just like what backtracking usually does, you set visiting[i] to true before DFS, and reset it to false after DFS. \n2. The `visited` array is just used to remember the DFS result of each node to avoid recomputation. \n```java\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        for(int[] edge: prerequisites)\n            graph.computeIfAbsent(edge[1], key->new ArrayList<>()).add(edge[0]);\n        for(int i=0; i<numCourses; i++)\n            if(!DFS(graph, new boolean[numCourses], new boolean[numCourses], i)) return false;\n        return true;\n        \n    }\n    private boolean DFS(HashMap<Integer, List<Integer>> graph, boolean[] visited, boolean[] visiting, int course){\n        if(visited[course]) return true;\n        \n        if(visiting[course]) return false;\n        visiting[course] = true;\n        if(graph.containsKey(course))\n            for(Integer subCourse: graph.get(course)){\n                if(!DFS(graph, visited, visiting, subCourse)) return false;\n            }\n        visiting[course] = false;\n        \n        visited[course] = true;\n        return true;\n    }\n}\n```"}]}, {"qid": 210, "title": "Course Schedule II", "link": "https://leetcode.com/problems/course-schedule-ii/", "tags": ["BFS", "DFS", "Graph", "Topological Sort"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Topological Sort", "text": "<span id=\"210-topo-sort\"></span>\nSimilar to [207. Course Schedule](#210-topo-sort)\n```java\nclass Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        int[] degrees = new int[numCourses];\n        for(int[] edge: prerequisites){\n            graph.computeIfAbsent(edge[1], key-> new ArrayList<>()).add(edge[0]);\n            degrees[edge[0]]++;\n        }\n        Queue<Integer> qu = new LinkedList<>();\n        for(int i=0; i<numCourses; i++) \n            if(degrees[i] == 0) qu.add(i);\n        int[] result = new int[numCourses];\n        int i=0;\n        while(!qu.isEmpty()){\n            int course = qu.poll();\n            if(graph.containsKey(course))\n                for(int subcourse : graph.get(course)) \n                    if(--degrees[subcourse] == 0) qu.add(subcourse);\n            result[i++] = course;\n        }\n        if(i != numCourses) return new int[0];\n        return result;\n    }\n    \n}\n```"}]}, {"qid": 34, "title": "Find First and Last Position of Element in Sorted Array", "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/", "tags": ["Array", "Binary Search"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Binary Search Lower Bound", "text": "This question needs careful consideration of the boundaries!\n\n1. To ensure the output of lowerBound is still in the range of [0, nums.length-1], `int b = lowerBound(nums, a, nums.length-1, target+1);` cannot be `int b = lowerBound(nums, a+1, nums.length-1, target+1);` in order to adapt to the case where `a==b`\n2. We still need `arr[1] = nums[b] == target ? b : b-1;` because b might be the last element and thus nums[b] might be smaller than `target+1`\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] arr = {-1,-1};\n        if(nums.length == 0) return arr;\n        int a = lowerBound(nums, 0, nums.length-1, target);\n        if(nums[a]!=target) return arr;\n        int b = lowerBound(nums, a, nums.length-1, target+1);\n        arr[0] = a; \n        arr[1] = nums[b] == target ? b : b-1;\n        return arr;\n    }\n    private int lowerBound(int[] nums, int i, int j, int target){\n        int l=i, r=j;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            if(nums[mid] == target) r = mid;\n            else if(nums[mid] > target) r = mid-1;\n            else l = mid+1;\n        }\n        return l;\n    }\n}\n```"}]}, {"qid": 236, "title": "Lowest Common Ancestor of a Binary Tree", "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/", "tags": ["Tree"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    TreeNode node;\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        helper(root, p, q);\n        return node;\n    }\n    private int helper(TreeNode root, TreeNode p, TreeNode q){\n        if(root == null) return 0;\n        int a = helper(root.left, p, q);\n        if(a == 2) return 2;\n        int b = helper(root.right, p, q);\n        if(b == 2) return 2;\n        int result = a + b;\n        if(root == p || root == q) result++;\n        if(result == 2) node = root;\n        return result;\n    }\n}\n```"}, {"title": "DFS without helper counting function", "text": "```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null) return null;\n        if(root == p || root == q) return root;\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\n        if(l == null) return r;\n        if(r == null) return l;\n        return root;\n    }\n}\n```"}]}, {"qid": 235, "title": "Lowest Common Ancestor of a Binary Search Tree", "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/", "tags": ["Tree"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "BST, beats 100%", "text": "Please refer to **236**.\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null) return null;\n        if(p.val > q.val) return lowestCommonAncestor(root, q, p);\n        if(root.val < p.val) return lowestCommonAncestor(root.right, p, q);\n        if(root.val > q.val) return lowestCommonAncestor(root.left, p, q);\n        return root;\n    }\n}\n```"}]}, {"qid": 139, "title": "Word Break", "link": "https://leetcode.com/problems/word-break/", "tags": ["Dynamic Programming"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP", "text": "```java\nclass Solution {\n    HashMap<Character, List<String>> map = new HashMap<>();\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str: wordDict)\n            map.computeIfAbsent(str.charAt(str.length()-1), key->new ArrayList<>()).add(str);\n        boolean[] dp = new boolean[s.length()];\n        for(int i=0; i<s.length(); i++){\n            char c = s.charAt(i);\n            String subs = s.substring(0, i+1);\n            if(map.containsKey(c))\n               for(String word: map.get(c)){\n                   if(subs.endsWith(word) && (i<word.length() || dp[i-word.length()])) dp[i] = true;\n               }\n        }\n        return dp[s.length()-1];\n    }\n}\n```"}]}, {"qid": 19, "title": "Remove Nth Node From End of List", "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/", "tags": ["Linked List", "Two Pointers"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "one pass solution", "text": "```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if(head == null) return null;\n        ListNode fast = head, slow = head;\n        for(int i=0; i<n; i++) fast = fast.next;\n        if(fast == null) return head.next;\n        while(fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}\n```"}]}, {"qid": 56, "title": "Merge Intervals", "link": "https://leetcode.com/problems/merge-intervals/", "tags": ["Array", "Sort"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "sort", "text": "The way of writting a sort function can be simplified to `intervals.sort((o1, o2)->o1.start-o2.start);`.\n\nTake a look at [435. Non-overlapping Intervals](#435. Non-overlapping Intervals) \n```java\nclass Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        if(intervals.size() == 0) return intervals;\n        Collections.sort(intervals, new Comparator<Interval>() {\n            @Override\n            public int compare(Interval o1, Interval o2){\n                return o1.start - o2.start;\n            }\n        });\n        int start = intervals.get(0).start, end = intervals.get(0).end;\n        int i=1;\n        List<Interval> result = new ArrayList<>();\n        for(; i<intervals.size(); i++){\n            if(intervals.get(i).start > end){\n                result.add(new Interval(start, end));\n                start = intervals.get(i).start; end = intervals.get(i).end;\n            }\n            else {\n                end = Math.max(end, intervals.get(i).end);\n            }\n        }\n        result.add(new Interval(start, end));\n        return result;\n    }\n}\n```"}]}, {"qid": 435, "title": "Non-overlapping Intervals", "link": "https://leetcode.com/problems/non-overlapping-intervals/description/", "tags": ["Greedy"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": []}, {"qid": 134, "title": "Gas Station", "link": "https://leetcode.com/problems/gas-station/", "tags": ["Greedy"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "pseudo two pointers", "text": "1. `while(slow < len && gas[slow]<0) slow++;` cannot be written as `while(slow < len && gas[slow]<=0) slow++;`. Consider cases like `gas[i] == cost[i]` for all possible i. \n2. Let's assume `remain[i] = gas[i]-cost[i]`. When `sum(remain, slow, fast) < 0`, all the stations between slow and fast cannot satisfy the demand.  \nThis idea comes from the fact that the array is an non-decreasing array.  \nWe know that when we have `slow` fixed and start considering `fast`, any station i between slow and fast should hold `sum(remain, slow, i) >= 0`. \nLet's assume there is an station k between slow and fast, which satisfy `sum(remain, k, fast) > 0`.\nFrom this, we can easily get `sum(remain, slow, k-1) < 0`, which is contradicted to the assumption. \nTherefore, as long as `sum(remain, slow, fast) < 0`, we can skip all the stations between slow and fast, and set `slow = fast + 1`. \n3. If `sum(gas) >= sum(cost)`, there must be a solution. Otherwise, no solution. \n```java\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        for(int i=0; i<gas.length; i++) gas[i] -= cost[i];\n        int slow = 0, len = gas.length;\n        while(slow < len && gas[slow]<0) slow++;\n        if(slow == len) return -1;\n        int fast = slow, result = 0;\n        while(true){\n            result += gas[fast];\n            fast = (fast+1)%len;\n            if(result < 0){\n                if(fast > slow) {\n                    slow = fast;\n                    while(slow < len && gas[slow]<0) slow++;\n                    if(slow == len) return -1;\n                    result = gas[slow];\n                    fast = (slow+1)%len;\n                }\n                else return -1;\n            }\n            if(fast == slow) return slow;\n        }\n    }\n}\n```"}]}, {"qid": 33, "title": "Search in Rotated Sorted Array", "link": "https://leetcode.com/problems/search-in-rotated-sorted-array/", "tags": ["Array", "Binary Search"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Method 1: use binary search for 3 times", "text": "The most direct method is to find the pivot, and then separate `nums` into two subarrays according to the position of the pivot, and then apply binary search to each subarray. \n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if(nums.length == 0) return -1;\n        int l = 0, r = nums.length-1;\n        while(l+1 < r){\n            int mid = l + ((r-l)>>1);\n            if(nums[mid] < nums[0]) r = mid;\n            else l = mid;\n        }\n        // System.out.println(l + \" \" + r);\n        int a = Arrays.binarySearch(nums, 0, r, target);\n        if(a<0){\n            int b = Arrays.binarySearch(nums, r, nums.length, target);\n            if(b<0) return -1;\n            return b;\n        }\n        return a;\n    }\n}\n```"}, {"title": "Method 2: use binary search for 2 times", "text": "Just like the above solution, we find the pivot first. Once we have pivot, we can establish a mapping of indices before and after the rotation. \n\nBe careful to a special case where `shift == 0` (i.e. the position of the smallest element)\n\nTime: 6 ms\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        // compute `shift`\n        if(nums.length == 0) return -1;\n        int l = 0, r = nums.length-1;\n        int shift = -1;\n        if(nums[l] < nums[r]) shift = 0;\n        else {\n            while(l+1 < r){\n                int mid = l + ((r-l)>>1);\n                if(nums[mid] < nums[0]) r = mid;\n                else l = mid;\n            }\n            shift = r;\n        }\n        // use `shift` to map index\n        l = 0;\n        r = nums.length-1;\n        while(l<=r) {\n            int mid = l + ((r-l)>>1);\n            int midAfterRotate = (mid+shift)%nums.length; //idxAfterRotate(mid, shift, nums.length);\n            if(nums[midAfterRotate] == target) return midAfterRotate;\n            else if(nums[midAfterRotate] > target) r = mid - 1;\n            else l = mid + 1;\n        }\n        return -1;\n    }\n    // private int idxAfterRotate(int i, int k, int len){\n    //     return (i+k)%len;\n    // }\n}\n```"}, {"title": "Method 3: use binary search for 3 times", "text": "`nums` is almost in a sorted order, and we can take advantage of it! \n\nwe can divide this problem into two cases:  \n1. `target >= nums[0]`: target is in the left part\n2. `target < nums[0]`: target is in the right part\n\nFor each case, we only need to deal with a situation when `nums[mid]` is in the wrong part.\n\nTime: 6 ms\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if(nums.length == 0) return -1;\n        int l = 0, r = nums.length - 1;\n        // take care of the special case\n        if(nums[l] < nums[r]){\n            int idx = Arrays.binarySearch(nums, l, r+1, target);\n            return idx<0 ? -1 : idx;\n        }\n        if(target >= nums[0]){\n            // target is in the left part\n            while(l<=r){\n                int mid = l + ((r-l)>>1);\n                if(nums[mid] < nums[0]) r = mid-1;\n                else if(nums[mid] == target) return mid;\n                else if(nums[mid] > target) r = mid-1;\n                else l = mid + 1;\n            }\n            return -1;\n        }\n        else {\n            // target is in the right part\n            while(l<=r){\n                int mid = l + ((r-l)>>1);\n                if(nums[mid] >= nums[0]) l = mid+1;\n                else if(nums[mid] == target) return mid;\n                else if(nums[mid] > target) r = mid-1;\n                else l = mid+1;\n            }\n            return -1;\n        }\n    }\n}\n```"}]}, {"qid": 150, "title": "Evaluate Reverse Polish Notation", "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/", "tags": ["Stack"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "stack", "text": "1. `token.length()>1` is used to deal with negative numbers.\n2. pay attention to the order of parameters in `compute` function\n```java\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> st = new Stack<>();\n        for(String token: tokens){\n            // System.out.println(st.toString());\n            if(Character.isDigit(token.charAt(0)) || token.length()>1){ \n                int num = Integer.parseInt(token);\n                st.push(num);\n            }\n            else {\n                st.push(compute(st.pop(), st.pop(), token.charAt(0)));\n            }\n        }\n        // System.out.println(st.toString());\n        return st.pop();\n    }\n    private int compute(int b, int a, char c){\n        if(c == '+') return a+b;\n        else if(c=='-') return a-b;\n        else if(c=='*') return a*b;\n        else return a/b;\n    }\n}\n```"}]}, {"qid": 55, "title": "Jump Game", "link": "https://leetcode.com/problems/jump-game/", "tags": ["Array", "Greedy"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP", "text": "```java\nclass Solution {\n    public boolean canJump(int[] nums) {\n        int dp = nums[0];\n        for(int i=1; i<nums.length; i++){\n            if(dp < i) return false;\n            dp = Math.max(dp, i+nums[i]);\n        }\n        return dp>=nums.length-1;\n    }\n}\n```"}]}, {"qid": 2, "title": "Add Two Numbers", "link": "https://leetcode.com/problems/add-two-numbers/", "tags": ["Linked List", "Math"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "simple solution beats 91.83% in time and 96.99% in space", "text": "```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        int cin = 0;\n        ListNode head = new ListNode(-1);\n        ListNode curr = head;\n        while(l1 != null || l2 != null){\n            int temp = cin;\n            if(l1 != null) {\n                temp += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){\n                temp += l2.val;\n                l2 = l2.next;\n            }\n            curr.next = new ListNode(temp%10);\n            curr = curr.next;\n            cin = temp/10;\n        }\n        if(cin > 0)\n            curr.next = new ListNode(cin);\n        return head.next;\n    }\n}\n```"}]}, {"qid": 54, "title": "Spiral Matrix", "link": "https://leetcode.com/problems/spiral-matrix/", "tags": ["Array"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "recursive", "text": "The key of this problem lies in the boundaries.\n\n`if(m != 2*k+1)` and `if(n != 2*k+1)` are used to deal with rectangular matrices to prevent duplicates. \n```java\nclass Solution {\n    List<Integer> result = new ArrayList<>();\n    int m,n;\n    public List<Integer> spiralOrder(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0) return result;\n        this.m = matrix.length;\n        this.n = matrix[0].length;\n        spiralOrder(matrix, 0);\n        return result;\n    }\n    private void spiralOrder(int[][] matrix, int k){\n        if(k>(m-1)/2 || k>(n-1)/2) return ;\n        result.add(matrix[k][k]);\n        for(int j=k+1; j<n-k; j++) result.add(matrix[k][j]);\n        for(int i=k+1; i<m-k; i++) result.add(matrix[i][n-k-1]);\n        if(m != 2*k+1)\n            for(int j=n-k-2; j>=k; j--) result.add(matrix[m-k-1][j]);\n        if(n != 2*k+1)\n        for(int i=m-k-2; i>=k+1; i--) result.add(matrix[i][k]);\n        spiralOrder(matrix, k+1);\n    }\n}\n```"}]}, {"qid": 152, "title": "Maximum Product Subarray", "link": "https://leetcode.com/problems/maximum-product-subarray/", "tags": ["Array", "Dynamic Programming"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP, space-optimized", "text": "`dp[i]` means the largest product of the subarray ended up with nums[i]  \nHere we use `maxVal` and `minVal` to record the local state of an iteration. \n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        // int[] dp = new int[nums.length];\n        int dp;\n        int maxVal, minVal;\n        // maxVal = minVal = dp[0] = nums[0];\n        maxVal = minVal = dp = nums[0];\n        for(int i=1; i<nums.length; i++){\n            int num = nums[i];\n            if(num > 0){\n                maxVal = Math.max(num, maxVal * num);\n                minVal = Math.min(num, minVal * num);\n            }\n            else if(num < 0){\n                int nextMinVal = Math.min(num, maxVal * num);\n                maxVal = Math.max(num, minVal * num);\n                minVal = nextMinVal;\n            }\n            else {\n                maxVal = minVal = 0;\n            }\n            // dp[i] = maxVal;\n            if(dp < maxVal) dp = maxVal;\n        }\n        // int result = Integer.MIN_VALUE;\n        // for(int res: dp)\n        //     if(result < res) result = res;\n        // return result;\n        return dp;\n    }\n}\n```"}]}, {"qid": 50, "title": "Pow(x, n)", "link": "https://leetcode.com/problems/powx-n/", "tags": ["Math", "Binary Search"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "iterative", "text": "```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(n == 0) return 1;\n        if(x == 0) return 0;\n        if(n == Integer.MIN_VALUE) {\n            if(x > 1 || x<-1) return 0;\n            return 1;\n        }\n        if(n<0) {\n            n = -n;\n            x = 1/x;\n        }\n        HashMap<Integer, Double> map = new HashMap<>();\n        map.put(1, x);\n        int currN = 1;\n        while((currN<<1) > 0 && (currN<<1) < n){\n            double temp = map.get(currN);\n            currN <<= 1;\n            map.put(currN, temp * temp);\n        }\n        double result = 1;\n        while(n>0){\n            while(n < currN) currN >>= 1;\n            result *= map.get(currN);\n            n -= currN;\n        }\n        return result;\n    }\n}\n```"}, {"title": "recursive", "text": "```java\nclass Solution {\n    public double myPow(double x, int n) {\n        if(n == 0) return 1;\n        if(n == Integer.MIN_VALUE){\n            return myPow(x*x, n>>1);\n        } \n        if(n<0) {\n            n = -n;\n            x = 1/x;\n        }\n        return (n%2) == 0 ? myPow(x*x, n>>1) : x * myPow(x*x, n>>1);\n    }\n}\n```"}]}, {"qid": 3, "title": "Longest Substring Without Repeating Characters", "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/", "tags": ["Hash Table", "Two Pointers", "String"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "two pointers, thinking in a DP way", "text": "Notice that `s` may contain any ASCII character. \n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s == null || s.length() == 0) return 0;\n        boolean[] alphabet = new boolean[256];\n        int head = 0, tail = 1;\n        alphabet[s.charAt(0)] = true;\n        int result = 1;\n        while(tail < s.length()){\n            if(alphabet[s.charAt(tail)]){\n                do {\n                    alphabet[s.charAt(head++)] = false;\n                } while(s.charAt(head-1) != s.charAt(tail));\n            }\n            alphabet[s.charAt(tail++)] = true;\n            if(result < tail-head) result = tail-head;\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 138, "title": "Copy List with Random Pointer", "link": "https://leetcode.com/problems/copy-list-with-random-pointer/", "tags": ["Hash Table", "Linked List"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "2 pass copy with Hash Mapping, O(n) space and O(n) time", "text": "```java\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if(head == null) return null;\n        Node newHead = new Node(head.val, head.next, head.random);\n        HashMap<Node, Node> map = new HashMap<>();\n        map.put(head, newHead);\n        Node curr = newHead;\n        while(curr.next != null){\n            Node temp = curr.next;\n            curr.next = new Node(temp.val, temp.next, temp.random);\n            map.put(temp, curr.next);\n            curr = curr.next;\n        }\n        curr = newHead;\n        while(curr != null){\n            if(curr.random != null)\n                curr.random = map.get(curr.random);\n            curr = curr.next;\n        }\n        return newHead;\n    }\n}\n```"}, {"title": "3 pass O(1) space and O(n) time", "text": "Since the original Linkedlist has to remain unchanged, we need to restore next pointer of the original nodes.  \nNotice that you cannot setup the random pointers while extracting the new Head at the same time. \n```java\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if(head == null) return null;\n        // interleaving copy\n        Node curr = head;\n        while(curr != null){\n            curr.next = new Node(curr.val, curr.next, curr.random);\n            curr = curr.next.next;\n        }\n        Node newHead = head.next;\n        // setup the random pointers\n        curr = head.next;\n        while(true){\n            if(curr.random != null)\n                curr.random = curr.random.next;\n            if(curr.next == null) break;\n            curr = curr.next.next;\n        }\n        // extract the newHead\n        curr = head;\n        Node copy = newHead;\n        while(true) {\n            curr.next = copy.next;\n            curr = curr.next;\n            if(copy.next == null) break;\n            copy.next = curr.next;\n            copy = copy.next;\n        }\n        return newHead;\n    }\n}\n```"}]}, {"qid": 179, "title": "Largest Number", "link": "https://leetcode.com/problems/largest-number/", "tags": ["Sort"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Arrays.sort Comparator", "text": "1. be careful about these cases: comparing 3456 & 345, 3451 & 345\n2. remember to remove the leading zeroes\n3. `Arrays.sort(xxx, new Comparator<xxx>() {})` can only be applied to object arrays\n```java\nclass Solution {\n    public String largestNumber(int[] nums) {\n        // convert nums to a String Array\n        String[] strs = new String[nums.length];\n        for(int i=0; i<nums.length; i++)\n            strs[i] = Integer.toString(nums[i]);\n        // Self-defined sorting\n        Arrays.sort(strs, new Comparator<String>() {\n            @Override\n            public int compare(String a, String b) {\n                int i=0; \n                while(i<a.length() && i<b.length()){\n                    if(a.charAt(i) != b.charAt(i))\n                        return b.charAt(i) - a.charAt(i);\n                    i++;\n                }\n                if(i == a.length() && i == b.length()) return 0;\n                else if(i == b.length())\n                    return compare(a.substring(i, a.length()) + b, a);\n                else \n                    return compare(b, b.substring(i, b.length()) + a);\n            }\n        });\n        // join the strings\n        String result = String.join(\"\", Arrays.asList(strs));\n        int k = 0;\n        // remove the leading zeros\n        while(k<result.length() && result.charAt(k) == '0') k++;\n        if(k == result.length()) return \"0\";\n        return result.substring(k, result.length());\n    }\n}\n```"}, {"title": "smarter but much slower idea using concatenation", "text": "```java\nclass Solution {\n    public String largestNumber(int[] nums) {\n        String[] strs = new String[nums.length];\n        for(int i=0; i<nums.length; i++)\n            strs[i] = Integer.toString(nums[i]);\n        Arrays.sort(strs, (String a, String b)->(b+a).compareTo(a+b));\n        String result = String.join(\"\", Arrays.asList(strs));\n        int k = 0;\n        while(k<result.length() && result.charAt(k) == '0') k++;\n        if(k == result.length()) return \"0\";\n        return result.substring(k, result.length());\n    }\n}\n```"}]}, {"qid": 98, "title": "Validate Binary Search Tree", "link": "https://leetcode.com/problems/validate-binary-search-tree/", "tags": ["Tree", "BFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "recursive", "text": "Attention that you need to take care of cases like `root.val == Integer.MIN_VALUE` and `root.val == Integer.MAX_VALUE`, because under these circumstances, the boundaries might overflow.\n```java\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n    public boolean isValidBST(TreeNode root, int l, int r){\n        if(root == null) return true;\n        if(root.val > r || root.val < l) return false;\n        if(root.val == Integer.MIN_VALUE && root.left != null) return false;\n        if(root.val == Integer.MAX_VALUE && root.right != null) return false;\n        return isValidBST(root.left, l, root.val-1) && isValidBST(root.right, root.val+1, r);\n    }\n}\n```"}]}, {"qid": 127, "title": "Word Ladder", "link": "https://leetcode.com/problems/word-ladder/", "tags": ["BFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "My BFS", "text": "1. You need to mark all the words that has been visited. \n2. You can initiate a boolean array for marking, but removing elements from wordList directly seems faster. \n```java\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Queue<String> qu = new LinkedList<>();\n        qu.add(beginWord);\n        // boolean[] mark = new boolean[wordList.size()];\n        int count = 1, level = 0;\n        while(!qu.isEmpty()){\n            String curr = qu.poll();\n            count--;\n            if(curr.equals(endWord)) return level+1;\n            for(int i=0; i<wordList.size(); i++){\n                String word = wordList.get(i);\n                // if(!mark[i] && isSimilar(curr, word)) {qu.add(word); mark[i] = true;}\n                if(isSimilar(curr, word)) {\n                    qu.add(word); \n                    wordList.remove(i--);\n                }\n            }\n            if(count == 0){\n                count = qu.size();\n                level++;\n            }\n        }\n        return 0;\n    }\n    private boolean isSimilar(String a, String b){\n        // if(a.length() != b.length()) return false;\n        int count = 0;\n        for(int i=0; i<a.length(); i++){\n            if(a.charAt(i) != b.charAt(i)) count++;\n            if(count == 2) return false;\n        }\n        return true;\n    }\n}\n```"}, {"title": "A faster BFS", "text": "```java\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        HashSet<String> set = new HashSet<>(wordList);\n        Queue<String> qu = new LinkedList<>();\n        qu.add(beginWord);\n        int count = 1, level = 0;\n        while(!qu.isEmpty()){\n            String curr = qu.poll();\n            count--;\n            if(curr.equals(endWord)) return level+1;\n            char[] chrs = curr.toCharArray();\n            for(int i=0; i<chrs.length; i++){\n                char temp = chrs[i];\n                for(char c='a'; c<='z'; c++){\n                    if(c == temp) continue;\n                    chrs[i] = c;\n                    String word = new String(chrs);\n                    if(set.contains(word)) {\n                        qu.add(word);\n                        set.remove(word);\n                    }\n                }\n                chrs[i] = temp;\n            }\n            if(count == 0){\n                count = qu.size();\n                level++;\n            }\n        }\n        return 0;\n    }\n}\n```"}]}, {"qid": 130, "title": "Surrounded Regions", "link": "https://leetcode.com/problems/surrounded-regions/", "tags": ["DFS", "BFS", "Union Find"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "My BFS", "text": "```java\nclass Solution {\n    int[][] map;\n    public void solve(char[][] board) {\n        if(board.length == 0 || board[0].length == 0) return ;\n        map = new int[board.length][board[0].length];\n        for(int i=0; i<board.length; i++)\n            for(int j=0; j<board[0].length; j++){\n                if(isSurrounded(board, i, j)) flip(board, i, j, 'M', 'X');\n                else flip(board, i, j, 'M', 'O');\n            }\n    }\n    private boolean isSurrounded(char[][] board, int i, int j){\n        if(board[i][j] == 'X' || board[i][j] == 'M') return true;\n        if(i==0 || i==board.length-1 || j==0 || j==board[0].length-1) return false;\n        if(map[i][j] == 1) return true;\n        else if(map[i][j] == -1) return false;\n        board[i][j] = 'M';\n        boolean temp = isSurrounded(board, i-1, j) && isSurrounded(board, i+1, j) && isSurrounded(board, i, j-1) && isSurrounded(board, i, j+1);\n        map[i][j] = temp ? 1 : -1;\n        return temp;\n    }\n    private void flip(char[][] board, int i, int j, char src, char dst){\n        if(board[i][j] == src) {\n            board[i][j] = dst;\n            flip(board, i+1, j, src, dst);\n            flip(board, i-1, j, src, dst);\n            flip(board, i, j+1, src, dst);\n            flip(board, i, j-1, src, dst);\n        }\n    }\n}\n```"}, {"title": "My faster BFS, in an outside-in way", "text": "Flip all the un-surrounded 'O's into 'M' in an outside-in way. Then, iterate the board and flip the remaining 'O's into 'X'. Finally, flip all the 'M's into 'O'. \n```java\nclass Solution {\n    int m, n;\n    public void solve(char[][] board) {\n        if(board.length == 0 || board[0].length == 0) return ;\n        m = board.length;\n        n = board[0].length;\n        // Flip all the un-surrounded 'O's into 'M' in an outside-in way.\n        for(int i=0; i<m; i++){\n            if(board[i][0] == 'O') flip(board, i, 0, 'O', 'M');\n            if(board[i][n-1] == 'O') flip(board, i, n-1, 'O', 'M');\n        }\n        for(int j=1; j<n-1; j++){\n            if(board[0][j] == 'O') flip(board, 0, j, 'O', 'M');\n            if(board[m-1][j] == 'O') flip(board, m-1, j, 'O', 'M');\n        }\n        // flip the remaining 'O's into 'X'.\n        for(int i=0; i<m; i++)\n            for(int j=0; j<n; j++)\n                if(board[i][j] == 'O') flip(board, i, j, 'O', 'X');\n        // flip all the 'M's into 'O'. \n        for(int i=0; i<m; i++)\n            for(int j=0; j<n; j++)\n                if(board[i][j] == 'M') flip(board, i, j, 'M', 'O');\n    }\n    private void flip(char[][] board, int i, int j, char src, char dst){\n        if(i>=0 && j>=0 && i<m && j<n && board[i][j] == src){\n            board[i][j] = dst;\n            flip(board, i+1, j, src, dst);\n            flip(board, i-1, j, src, dst);\n            flip(board, i, j+1, src, dst);\n            flip(board, i, j-1, src, dst);\n        }\n    }\n}\n```"}]}, {"qid": 91, "title": "Decode Ways", "link": "https://leetcode.com/problems/decode-ways/", "tags": ["String", "Dynamic Programming"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP, space optimized", "text": "`s.charAt(i) == 0` is a special case. \n```java\nclass Solution {\n    public int numDecodings(String s) {\n        if(s.length() == 0 || s.charAt(0) == '0') return 0;\n        // int[] dp = new int[s.length()];\n        // dp[0] = 1;\n        int dp1 = 1, dp2 = 1;\n        for(int i=1; i<s.length(); i++){\n            int dp=0;\n            if(s.charAt(i) == '0'){\n                if(s.charAt(i-1) == '1' || s.charAt(i-1) == '2') dp = dp2;\n                else return 0;\n            }\n            else {\n                dp = dp1;\n                if(s.charAt(i-1) == '1' || \n                   (s.charAt(i-1) == '2' && s.charAt(i) < '7'))\n                    dp += dp2;\n            }\n            dp2 = dp1;\n            dp1 = dp;\n        }\n        return dp1;\n    }\n}\n```"}]}, {"qid": 29, "title": "Divide Two Integers", "link": "https://leetcode.com/problems/divide-two-integers/", "tags": ["Math", "Binary Search"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "subtract and double", "text": "```java\nclass Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend == 0) return 0;\n        int sign = (dividend<0 && divisor<0) || (dividend>0 && divisor>0) ? 1 : -1;\n        //convert to positive and avoid overflow\n        if(divisor == Integer.MIN_VALUE) return dividend == Integer.MIN_VALUE ? 1 : 0;\n        if(divisor < 0) divisor = -divisor;\n        int result = 0;\n        if(dividend == Integer.MIN_VALUE) {\n            if(divisor == 1 && sign == 1) return Integer.MAX_VALUE;\n            dividend += divisor;\n            result++;\n        }\n        if(dividend < 0) dividend = -dividend;\n        //use map to record\n        HashMap<Integer, Integer> map = new HashMap<>();\n        map.put(1, divisor);\n        int curr = 1;\n        while(dividend >= map.get(curr)){\n            // experiment shows that adding the following two lines will makes it faster, though not necessary. \n            dividend -= map.get(curr);\n            result += curr;\n            // avoid overflow\n            if((map.get(curr)<<1) < 0) break;\n            map.put(curr<<1, map.get(curr)<<1);\n            curr <<= 1;\n        }\n        while(dividend >= map.get(1)){\n            while(dividend < map.get(curr)) curr>>=1;\n            dividend -= map.get(curr);\n            result += curr;\n        }\n        return sign * result;\n    }\n}\n```"}]}, {"qid": 8, "title": "String to Integer (atoi)", "link": "https://leetcode.com/problems/string-to-integer-atoi/", "tags": ["Math", "String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "boundary check", "text": "```java\nclass Solution {\n    public int myAtoi(String str) {\n        if(str.length() == 0) return 0;\n        int i=0;\n        // remove leading white space\n        while(i<str.length() && str.charAt(i) == ' ') i++;\n        // detect plus/minus sign\n        int sign = 1;\n        if(i<str.length() && str.charAt(i) == '-') {sign = -1; i++;}\n        else if(i<str.length() && str.charAt(i) == '+') {sign = 1; i++;}\n        // remove leading zeros\n        while(i<str.length() && str.charAt(i) == '0') i++;\n        // parse Integer\n        long result = 0;\n        int start = i;\n        for(; i<str.length() && i-start < 11; i++){\n            if(!Character.isDigit(str.charAt(i))) break;\n            result *= 10;\n            result += str.charAt(i) - '0';\n        }\n        result *= sign;\n        if(result < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n        else if (result > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        return (int)result;\n    }\n}\n```"}]}, {"qid": 222, "title": "Count Complete Tree Nodes", "link": "https://leetcode.com/problems/count-complete-tree-nodes/", "tags": ["Binary Search", "Tree"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Binary Search in a tree", "text": "Compute the left height `h` in each iteration. \nif #nodes of right subtree > #perfect complete tree with height `h-2`, we can conclude that the left subtree must be a perfect complete tree with height `h-1`.\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root == null) return 0;\n        int height = getLeftHeight(root);\n        if(height == 0) return 1;\n        if(height == 1) return root.right == null ? 2 : 3;\n        int rightNum = countNodes(root.right);\n        if(rightNum > computeTotalNodes(height-2))\n            return computeTotalNodes(height-1) + rightNum + 1;\n        return countNodes(root.left) + rightNum + 1;\n    }\n    private int computeTotalNodes(int height){\n        return (1<<(height+1))-1;\n    }\n    private int getLeftHeight(TreeNode root){\n        int count = 0;\n        while(root.left != null){\n            count++;\n            root = root.left;\n        }\n        return count;\n    }\n}\n```"}, {"title": "concise version", "text": "```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        int height = getHeight(root);\n        if(height == 0) return 0;\n        if(getHeight(root.right) == height-1)\n            return (1<<height-1) + countNodes(root.right);\n        return countNodes(root.left) + (1<<(height-2));\n    }\n    private int getHeight(TreeNode root){\n        int count = 0;\n        while(root != null){\n            count++;\n            root = root.left;\n        }\n        return count;\n    }\n}\n```"}]}, {"qid": 53, "title": "Maximum Subarray", "link": "https://leetcode.com/problems/maximum-subarray/", "tags": ["Array", "Divide and Conquer", "Dynamic Programming"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP", "text": "```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums.length == 0) return 0;\n        int dp = nums[0], result = nums[0];\n        for(int i=1; i<nums.length; i++){\n            if(dp < 0) dp = nums[i];\n            else dp += nums[i];\n            if(result < dp) result = dp;\n        }\n        return result;\n    }\n}\n```"}, {"title": "Divide and Conquer", "text": "```java\n// not implemented yet\n```"}]}, {"qid": 343, "title": "Integer Break", "link": "https://leetcode.com/problems/integer-break/", "tags": ["Math", "Dynamic Programming"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Math solution", "text": "```java\nclass Solution {\n    public int integerBreak(int n) {\n        if(n == 2) return 1;\n        if(n == 3) return 2;\n        int result = 1;\n        while(n>4){\n            result *= 3;\n            n -= 3;\n        }\n        result *= n;\n        return result;\n    }\n}\n```"}]}, {"qid": 415, "title": "Add Strings", "link": "https://leetcode.com/problems/add-strings/", "tags": ["Math"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "while loop with StringBuilder.insert(0, xxx)", "text": "```java\nclass Solution {\n    public String addStrings(String num1, String num2) {\n        StringBuilder sb = new StringBuilder();\n        int i=num1.length()-1, j=num2.length()-1;\n        int cin = 0;\n        while(i>=0 || j>=0){\n            int temp = cin;\n            if(i>=0) temp += num1.charAt(i--)-'0';\n            if(j>=0) temp += num2.charAt(j--)-'0';\n            if(temp > 9){\n                cin = 1;\n                temp %= 10;\n            }\n            else cin = 0;\n            sb.insert(0, temp);\n        }\n        if(cin > 0) sb.insert(0, cin);\n        return sb.toString();\n    }\n}\n```"}]}, {"qid": 43, "title": "Multiply Strings", "link": "https://leetcode.com/problems/multiply-strings/", "tags": ["Math", "String"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "StringBuilder.insert", "text": "```java\nclass Solution {\n    public String multiply(String num1, String num2) {\n        StringBuilder sb = new StringBuilder();\n        int base = 0, carry = 0;\n        while(++base <= num1.length() + num2.length()){\n            for(int i=0; i<base && i<num1.length(); i++){\n                int j = base-1-i;\n                if(j >= num2.length()) continue;\n                carry += (num1.charAt(num1.length()-1-i)-'0') * (num2.charAt(num2.length()-1-j)-'0');\n            }\n            sb.insert(0, carry%10);\n            carry /= 10;\n        }\n        if(carry > 0) sb.insert(0, carry);\n        for(int i=0; i<sb.length(); i++){\n            if(sb.charAt(i) != '0') return sb.substring(i, sb.length());\n        }\n        return \"0\";\n    }\n}\n```"}]}, {"qid": 349, "title": "Intersection of Two Arrays", "link": "https://leetcode.com/problems/intersection-of-two-arrays/", "tags": ["Hash Table", "Two Pointers", "Binary Search", "Sort"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Hash Set 2ms", "text": "```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        HashSet<Integer> set = new HashSet<>();\n        for(int num: nums1) set.add(num);\n        for(int num: nums2) {\n            if(set.contains(num)){\n                list.add(num);\n                set.remove(num);\n            }\n        }\n        int[] result = new int[list.size()];\n        for(int i=0; i<list.size(); i++)\n            result[i] = list.get(i);\n        return result;\n    }\n}\n```"}, {"title": "Two pointers 2ms", "text": "```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i=0, j=0;\n        while(i<nums1.length && j<nums2.length){\n            if(nums1[i] == nums2[j]){\n                list.add(nums1[i]);\n                i++; j++;\n                while(i<nums1.length && nums1[i] == nums1[i-1]) i++;\n                while(j<nums2.length && nums2[j] == nums2[j-1]) j++;\n            }\n            else if(nums1[i] > nums2[j]) {\n                j++;\n                while(j<nums2.length && nums2[j] == nums2[j-1]) j++;\n            }\n            else {\n                i++;\n                while(i<nums1.length && nums1[i] == nums1[i-1]) i++;\n            }\n        }\n        int[] result = new int[list.size()];\n        for(int k=0; k<list.size(); k++)\n            result[k] = list.get(k);\n        return result;\n    }\n}\n```"}]}, {"qid": 350, "title": "Intersection of Two Arrays II", "link": "https://leetcode.com/problems/intersection-of-two-arrays-ii/", "tags": ["Hash Table", "Two Pointers", "Binary Search", "Sort"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Hash Table O(n)time, O(n)space  2ms", "text": "```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int num: nums1)\n            map.put(num, map.getOrDefault(num, 0)+1);\n        for(int num : nums2){\n            int temp = map.getOrDefault(num, 0);\n            if(temp > 0){\n                map.put(num, temp-1);\n                list.add(num);\n            }\n        }\n        int[] result = new int[list.size()];\n        for(int i=0; i<list.size(); i++)\n            result[i] = list.get(i);\n        return result;\n    }\n}\n```"}, {"title": "Two pointers O(nlogn)time O(1) space, 1ms", "text": "```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        List<Integer> list = new ArrayList<>();\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i=0, j=0;\n        while(i<nums1.length && j<nums2.length){\n            if(nums1[i] < nums2[j]) i++;\n            else if(nums1[i] > nums2[j]) j++;\n            else {\n                list.add(nums1[i]);\n                i++; j++;\n            }\n        }\n        int[] result = new int[list.size()];\n        for(int k=0; k<list.size(); k++)\n            result[k] = list.get(k);\n        return result;\n    }\n}\n```"}]}, {"qid": 101, "title": "Symmetric Tree", "link": "https://leetcode.com/problems/symmetric-tree/", "tags": ["Tree", "DFS", "BFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if(root == null) return true;\n        return isSymmetric(root.left, root.right);\n    }\n    private boolean isSymmetric(TreeNode a, TreeNode b){\n        if(a==null) return b==null;\n        if(b==null) return false;\n        if(a.val != b.val) return false;\n        return isSymmetric(a.right, b.left) && isSymmetric(a.left, b.right);\n    }\n}\n```"}]}, {"qid": 69, "title": "Sqrt(x)", "link": "https://leetcode.com/problems/sqrtx/", "tags": ["Math", "Binary Search"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "binary search", "text": "```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = 46340;\n        while(l+1<r) {\n            int mid = l + ((r-l)>>1);\n            if(mid*mid == x) return mid;\n            else if(mid*mid > x) r = mid-1;\n            else l = mid;\n        }\n        if(r*r <= x) return r;\n        return l;\n    }\n}\n```"}]}, {"qid": 674, "title": "Longest Continuous Increasing Subsequence", "link": "https://leetcode.com/problems/longest-continuous-increasing-subsequence/", "tags": ["Array"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP", "text": "```java\nclass Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        if(nums.length == 0) return 0;\n        int maxLen = 1, result = 1;\n        for(int i=1; i<nums.length; i++){\n            if(nums[i] > nums[i-1]) maxLen++;\n            else {\n                if(result < maxLen) result = maxLen;\n                maxLen = 1;\n            }\n        }\n        if(result < maxLen) result = maxLen;\n        return result;\n    }\n}\n```"}]}, {"qid": 673, "title": "Number of Longest Increasing Subsequence", "link": "https://leetcode.com/problems/number-of-longest-increasing-subsequence/", "tags": ["Dynamic Programming"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP O(n^2)time", "text": "```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] len = new int[nums.length]; // the longest length of Increasing Subsequence that ends with nums[i]\n        int[] count = new int[nums.length];// the number of longest Increasing Subsequence that ends with nums[i]\n        len[0] = 1;\n        count[0] = 1;\n        int maxLen = 1, result = 1;\n        for(int i=1; i<nums.length; i++){\n            len[i] = count[i] = 1;\n            for(int j=0; j<i; j++){\n                if(nums[i] > nums[j]){\n                    if(len[i] == len[j]+1) count[i] += count[j];\n                    else if(len[i] < len[j]+1) {\n                        len[i] = len[j]+1;\n                        count[i] = count[j];\n                    }\n                }\n            }\n            if(maxLen == len[i]) result += count[i];\n            else if(maxLen < len[i]) {\n                maxLen = len[i];\n                result = count[i];\n            }\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 324, "title": "Wiggle Sort II", "link": "https://leetcode.com/problems/wiggle-sort-ii/", "tags": ["Sort"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "sort and reverse, O(nlogn) time", "text": "This solution can be optimized by virtual indexing! \n\n[Explanation/Proof for the correctness](https://leetcode.com/problems/wiggle-sort-ii/discuss/77678/3-lines-Python-with-Explanation-Proof)\n```java\nclass Solution {\n    public void wiggleSort(int[] nums) {\n        if(nums.length == 0) return ;\n        int[] copy = nums.clone();\n        Arrays.sort(copy);\n        int l = (nums.length-1)/2, r = nums.length-1;\n        int i=0;\n        while(i<nums.length){\n            nums[i++] = copy[l--];\n            if(r==(nums.length-1)/2) break;\n            nums[i++] = copy[r--];\n        }\n    }\n}\n```"}]}, {"qid": 42, "title": "Trapping Rain Water", "link": "https://leetcode.com/problems/trapping-rain-water/", "tags": ["Array", "Two Pointers", "Stack"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "My Solution, O(n) time, O(1) space", "text": "1. Iterate `height` from left to right: each iteration, check if height[i] is the highest height (higher than `currHeight`). If true, count the volume of water between `currIdx`(i.e. the index of the currHeight position) and `i`. \n2. The iterations above fail to account for water after the last highest height. Therefore, do the same thing from right to left again. \n```java\nclass Solution {\n    public int trap(int[] height) {\n        if(height.length < 2) return 0;\n        int currHeight = 0, currIdx = 0, result = 0;\n        // Iterate from left to right\n        for(int i=0; i<height.length; i++){\n            if(height[i] >= currHeight){\n                for(int j=currIdx+1; j<i; j++)\n                    result += currHeight-height[j];\n                currHeight = height[i];\n                currIdx = i;\n            }\n        }\n        int midIdx = currIdx, midHeight=currHeight;\n        currHeight = 0; currIdx = height.length-1;\n        // Iterate from right to left\n        for(int i=height.length-1; i>=midIdx; i--){\n            if(height[i] >= currHeight){\n                for(int j=i+1; j<currIdx; j++)\n                    result += currHeight-height[j];\n                currHeight = height[i];\n                currIdx = i;\n            }\n            if(height[i] == midHeight) break;\n        }\n        return result;\n    }\n}\n```"}, {"title": "one-pass solution, O(n) time, O(1) space", "text": "Two pointers!  \nIf height[i] <= height[j], there are only two situations:  \n1) height[i] is the highest in subarray from 0 to i. For this situation, the `result` remains unchanged.  \n2) height[i] is not the highest from left, there must be water above it, and the height of water above height[i] should be `maxLeftHeight - height[i]`. \n```java\nclass Solution {\n    public int trap(int[] height) {\n        if(height.length < 2) return 0;\n        int i=0, j=height.length-1;\n        int result = 0, maxLeftHeight = 0, maxRightHeight = 0;\n        while(i<=j){\n            if(height[i] <= height[j]){\n                if(maxLeftHeight < height[i]) maxLeftHeight = height[i];\n                result += maxLeftHeight-height[i];\n                i++;\n            }\n            else {\n                if(maxRightHeight < height[j]) maxRightHeight = height[j];\n                result += maxRightHeight-height[j];\n                j--;\n            }\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 128, "title": "Longest Consecutive Sequence", "link": "https://leetcode.com/problems/longest-consecutive-sequence/", "tags": ["Array", "Union Find"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "union find based on HashMap, only beats 27.49% in time and 34.14% in space", "text": "```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length == 0) return 0;\n        HashMap<Integer, Integer> uf = new HashMap<>();\n        HashMap<Integer, Integer> lens = new HashMap<>();\n        for(int num: nums){\n            if(uf.containsKey(num)) continue;\n            uf.put(num, num);\n            lens.put(num, 1);\n            if(uf.get(num-1)!=null) union(uf, lens, num, num-1);\n            if(uf.get(num+1)!=null) union(uf, lens, num, num+1);\n        }\n        int result = 0;\n        for(int num: nums)\n            if(uf.get(num) == num && result < lens.get(num)) result = lens.get(num);\n        return result;\n    }\n    private void union(HashMap<Integer, Integer> uf, HashMap<Integer, Integer> lens,\n                       int a, int b){\n        int roota = find(uf, a), rootb = find(uf, b);\n        if(roota==rootb) return ;\n        if(lens.get(roota) <= lens.get(rootb)){\n            uf.put(roota, rootb);\n            lens.put(rootb, lens.get(roota)+lens.get(rootb));\n        }\n        else {\n            uf.put(rootb, roota);\n            lens.put(roota, lens.get(roota)+lens.get(rootb));\n        }\n    }\n    private int find(HashMap<Integer, Integer> uf, int a){\n        while(uf.get(a) != a){\n            int b = uf.get(a);\n            uf.put(a, uf.get(b));\n            a = b;\n        }\n        return a;\n    }\n}\n```"}, {"title": "only the boundaries, real O(n) time, beats 90.75% in time", "text": "The tricky part was to understand why only the boundaries need to be updated and not the entire sequence with the new sum.\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length == 0) return 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int result = 0;\n        for(int num: nums){\n            if(map.containsKey(num)) continue;\n            // get left and right sequence length\n            int leftLen = map.getOrDefault(num-1, 0);\n            int rightLen = map.getOrDefault(num+1, 0);\n            map.put(num, leftLen+rightLen+1);\n            // update the return value `result`\n            result = Math.max(result, leftLen+rightLen+1);\n            // we only need to udpate the ends of a sequence\n            if(leftLen>0) map.put(num-leftLen, leftLen+rightLen+1);\n            if(rightLen>0) map.put(num+rightLen, leftLen+rightLen+1);\n        }\n        return result;\n    }\n}\n```"}, {"title": "GENIUS!!", "text": "```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        HashSet<Integer> set = new HashSet<>();\n        for(int num : nums) set.add(num);\n        int result = 0;\n        for(int num: set){\n            if(set.contains(num-1)) continue;\n            int idx = num+1, count = 1;\n            while(set.contains(idx)){\n                count++;\n                idx++;\n            }\n            if(result < count) result = count;\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 329, "title": "Longest Increasing Path in a Matrix", "link": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/", "tags": ["DFS", "Topological Sort", "Memoization"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "My solution, DFS+Memoization, only beats 18% in time", "text": "1. borrowed idea from 128#GENIUS!! where only starts from the smaller side to avoid bi-direction checks. That's why I use `isMin` instead of `isMinMax`. `isMin` is a function to check whether an element in `matrix` is the minimum compared to its surrounding neighbors. \n2. Use DFS to get the longest increasing path starting from a local minimum. \n3. Need to record all the intermediate outcomes to avoid waste of computation. (Memoization) \n```java\nclass Solution {\n    int[][] record;\n    public int longestIncreasingPath(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0) return 0;\n        record = new int[matrix.length][matrix[0].length];\n        boolean[][] mark = new boolean[matrix.length][matrix[0].length];\n        int result = 0;\n        for(int i=0; i<matrix.length; i++)\n            for(int j=0; j<matrix[0].length; j++){\n                if(!isMin(matrix, i, j)) continue;\n                int temp = DFS(matrix, mark, i, j);\n                if(result < temp) result = temp;\n            }\n        return result;\n    }\n    private int DFS(int[][] matrix, boolean[][] mark, int i, int j){\n        if(i<0 || j<0 || i>= matrix.length || j>= matrix[0].length) return 0;\n        if(record[i][j] > 0) return record[i][j];\n        mark[i][j] = true;\n        int result = 1;\n        if(i-1>=0 && matrix[i-1][j] > matrix[i][j]) \n            result = Math.max(result, 1+DFS(matrix, mark, i-1, j));\n        if(i+1<matrix.length && matrix[i+1][j] > matrix[i][j]) \n            result = Math.max(result, 1+DFS(matrix, mark, i+1, j));\n        if(j-1>=0 && matrix[i][j-1] > matrix[i][j]) \n            result = Math.max(result, 1+DFS(matrix, mark, i, j-1));\n        if(j+1<matrix[0].length && matrix[i][j+1] > matrix[i][j]) \n            result = Math.max(result, 1+DFS(matrix, mark, i, j+1));\n        mark[i][j] = false;\n        record[i][j] = result;\n        return result;\n    }\n    private boolean isMin(int[][] matrix, int i, int j){\n        boolean result = true;\n        if(i-1>=0 && matrix[i-1][j] < matrix[i][j]) return false;\n        if(i+1<matrix.length && matrix[i+1][j] < matrix[i][j]) return false;\n        if(j-1>=0 && matrix[i][j-1] < matrix[i][j]) return false;\n        if(j+1<matrix[0].length && matrix[i][j+1] < matrix[i][j]) return false;\n        return true;\n    }\n}\n```"}, {"title": "optimized DFS, beats 98% in time", "text": "1. compared with the first solution, I find that don't actually need `isMin` method. \n2. I can use a static final `directions` to indicate all the possible four directions, instead of hard coding the four directions like the solution above. \n3. the `mark` boolean array can be discarded, as the `record` has already contains the information. \n```java\nclass Solution {\n    public int[][] record;\n    public final static int[][] directions = {{0,1},{0,-1},{1,0},{-1,0}};\n    public int longestIncreasingPath(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0) return 0;\n        record = new int[matrix.length][matrix[0].length];\n        int result = 0;\n        for(int i=0; i<matrix.length; i++)\n            for(int j=0; j<matrix[0].length; j++){\n                int temp = DFS(matrix, i, j);\n                if(result < temp) result = temp;\n            }\n        return result;\n    }\n    private int DFS(final int[][] matrix, final int i, final int j){\n        // if(i<0 || j<0 || i>= matrix.length || j>= matrix[0].length) return 0;\n        if(record[i][j] != 0) return record[i][j];\n        int result = 1;\n        for(int[] direction : directions){\n            int x = i+direction[0], y = j+direction[1];\n            if(x>=0 && y>=0 && x<matrix.length && y<matrix[0].length \n               && matrix[x][y] > matrix[i][j])\n                result = Math.max(result, 1+DFS(matrix, x, y));\n        }\n        record[i][j] = result;\n        return result;\n    }\n}\n```"}, {"title": "Topological Sort", "text": "https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/78336/Graph-theory-Java-solution-O(v2)-no-DFS"}]}, {"qid": 315, "title": "Count of Smaller Numbers After Self", "link": "https://leetcode.com/problems/count-of-smaller-numbers-after-self/", "tags": ["Divide and Conquer", "Binary Indexed Tree", "Segment Tree", "Binary Search Tree"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "lower bound binary search insertion, O(nlogn) time and O(n) space.", "text": "insert the elements of `nums` into `order` one by one from tail to head. \n```java\nclass Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        if(nums.length == 0) return result;\n        List<Integer> order = new ArrayList<>();\n        result.add(0);\n        order.add(nums[nums.length-1]);\n        for(int i=nums.length-2; i>=0; i--){\n            int idx = binarySearch(order, nums[i]);\n            if(idx<0) idx = -(idx+1);\n            result.add(0, idx);\n            order.add(idx, nums[i]);\n        }\n        return result;\n    }\n    private int binarySearch(List<Integer> list, int target){\n        int l=0, r=list.size()-1;\n        while(l+1 < r){\n            int mid = l+((r-l)>>1);\n            if(list.get(mid) >= target) r = mid;\n            else l = mid;\n        }\n        if(list.get(l) >= target) return l;\n        if(list.get(r) >= target) return r;\n        return r+1;\n    }\n}\n```"}]}, {"qid": 239, "title": "Sliding Window Maximum", "link": "https://leetcode.com/problems/sliding-window-maximum/", "tags": ["Heap", "Sliding Window"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "My solution, MaxQueue", "text": "MaxQueue is implemented by two MaxStack.\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length == 0) return new int[0];\n        MaxQueue qu = new MaxQueue();\n        int[] result = new int[nums.length-k+1];\n        int p = 0;\n        for(int i=0; i<nums.length; i++){\n            qu.add(nums[i]);\n            if(qu.size() == k){\n                result[p++] = qu.getMax();\n                qu.pop();\n            }\n        }\n        return result;\n    }\n}\nclass MaxQueue {\n    public MaxStack st1 = new MaxStack(), st2 = new MaxStack();\n    public void add(int x){\n        st1.add(x);\n    }\n    public int size(){\n        return st1.size() + st2.size();\n    }\n    public int pop(){\n        if(st2.isEmpty()){\n            assert !st1.isEmpty();\n            while(!st1.isEmpty()){\n                st2.add(st1.pop());\n            }\n        }\n        return st2.pop();\n    }\n    public int getMax(){\n        return Math.max(st1.getMax(), st2.getMax());\n    }\n}\nclass MaxStack {\n    public Stack<Integer> st = new Stack(), maxSt = new Stack();\n    public int maxVal = Integer.MIN_VALUE;\n    public void add(int x){\n        if(maxVal < x) maxVal = x;\n        maxSt.add(maxVal);\n        st.add(x);\n    }\n    public int size(){\n        return st.size();\n    }\n    public boolean isEmpty(){\n        return st.isEmpty();\n    }\n    public int pop(){\n        maxSt.pop();\n        maxVal = maxSt.size() == 0 ? Integer.MIN_VALUE : maxSt.peek();\n        return st.pop();\n    }\n    public int getMax(){\n        return maxVal;\n    }\n}\n```"}]}, {"qid": 295, "title": "Find Median from Data Stream", "link": "https://leetcode.com/problems/find-median-from-data-stream/", "tags": ["Heap", "Design"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "lower bound binary search insertion", "text": "```java\nclass MedianFinder {\n    List<Integer> list;\n    public MedianFinder() {\n        list = new ArrayList<>();\n    }\n    public void addNum(int num) {\n        int idx = binarySearch(list, num);\n        list.add(idx, num);\n    }\n    public double findMedian() {\n        if(list.size()%2 == 1) return (double)list.get(list.size()/2);\n        return (list.get(list.size()/2)+list.get(list.size()/2-1))/2.0;\n    }\n    private int binarySearch(List<Integer> list, int target){\n        if(list.size() == 0) return 0;\n        int l=0, r=list.size()-1;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            if(list.get(mid) >= target) r = mid-1;\n            else l = mid + 1;\n        }\n        if(list.get(l) >=target) return l;\n        return l+1;\n    }\n}\n```"}, {"title": "minHeap and maxHeap", "text": "```java\nclass MedianFinder {\n    PriorityQueue<Integer> maxHeap;\n    PriorityQueue<Integer> minHeap;\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\n        minHeap = new PriorityQueue<>();\n    }\n    public void addNum(int num) {\n        if(maxHeap.isEmpty() || maxHeap.peek() >= num) maxHeap.add(num);\n        else minHeap.add(num);\n        while(maxHeap.size() < minHeap.size())\n            maxHeap.add(minHeap.poll());\n        while(maxHeap.size()-1 > minHeap.size())\n            minHeap.add(maxHeap.poll());\n    }\n    public double findMedian() {\n        if(maxHeap.size() == minHeap.size()) return (maxHeap.peek()+minHeap.peek())/2.0;\n        return (double)maxHeap.peek();\n    }\n}\n```"}]}, {"qid": 23, "title": "Merge k Sorted Lists", "link": "https://leetcode.com/problems/merge-k-sorted-lists/", "tags": ["Linked List", "Divide and Conquer", "Heap"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "minHeap, 41ms", "text": "```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        ListNode head = new ListNode(0), curr = head;\n        PriorityQueue<Tuple> qu = new PriorityQueue<>(\n            (tup1, tup2) -> (tup1.node.val-tup2.node.val));\n        for(int i=0; i<lists.length; i++){\n            if(lists[i] != null){\n                qu.add(new Tuple(i, lists[i]));\n                lists[i] = lists[i].next;\n            }\n        }\n        while(!qu.isEmpty()){\n            Tuple tup = qu.poll();\n            curr.next = tup.node;\n            curr = curr.next;\n            if(lists[tup.idx] != null){\n                qu.add(new Tuple(tup.idx, lists[tup.idx]));\n                lists[tup.idx] = lists[tup.idx].next;\n            }\n        }\n        return head.next;\n    }\n}\nclass Tuple {\n    int idx;\n    ListNode node;\n    public Tuple(int i, ListNode n){\n        idx = i;\n        node = n;\n    }\n}\n```"}, {"title": "minHeap, simplified version, 9ms", "text": "```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        ListNode head = new ListNode(0), curr = head;\n        PriorityQueue<ListNode> qu = new PriorityQueue<>(new Comparator<ListNode>(){\n            public int compare(ListNode a, ListNode b){\n                return a.val - b.val;\n            }\n        });\n        for(ListNode node : lists)\n            if(node != null) qu.add(node);\n        while(!qu.isEmpty()){\n            curr.next = qu.poll();\n            curr = curr.next;\n            if(curr.next != null) qu.add(curr.next);\n        }\n        return head.next;\n    }\n}\n```"}, {"title": "divide and conquer, use merge 2 linkedlist, 5ms beats 100% in time", "text": "```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if(lists.length == 0) return null;\n        return mergeKLists(lists, 0, lists.length-1);\n    }\n    public ListNode mergeKLists(ListNode[] lists, int start, int end){\n        if(start == end) return lists[start];\n        int mid = start + ((end-start)>>1);\n        ListNode l1 = mergeKLists(lists, start, mid);\n        ListNode l2 = mergeKLists(lists, mid+1, end);\n        return merge(l1, l2);\n    }\n    private ListNode merge(ListNode l1, ListNode l2){\n        if(l1 == null) return l2;\n        if(l2 == null) return l1;\n        if(l1.val < l2.val){\n            l1.next = merge(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = merge(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```"}]}, {"qid": 124, "title": "Binary Tree Maximum Path Sum", "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum/", "tags": ["Tree", "DFS"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS, (tree-like) maximum subarray", "text": "```java\nclass Solution {\n    int result = Integer.MIN_VALUE;\n    public int maxPathSum(TreeNode root) {\n        if(root == null) return 0;\n        DFS(root);\n        return result;\n    }\n    private int DFS(TreeNode root){\n        if(root == null) return 0;\n        int left = Math.max(0, DFS(root.left)), right = Math.max(0, DFS(root.right));\n        result = Math.max(result, left+right+root.val);\n        return Math.max(left, right)+root.val;\n    }\n}\n```"}]}, {"qid": 41, "title": "First Missing Positive", "link": "https://leetcode.com/problems/first-missing-positive/", "tags": ["Array"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "establish val2index and index2val mapping, O(n) time and O(1) space", "text": "1. ignore all elements that are <= 0 or > nums.length\n2. establish val2index and index2val mapping for the remaining elements. i.e. `val2index[i] = i-1` and `index2val[i] = i+1`. \n3. iterate `nums`. For each num, swap this num to the index that it is supposed to be. \n4. the condition `nums[nums[i]-1] != nums[i]` in the while loop is used to avoid infinite loop caused by duplicates. \n```java\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        if(nums.length == 0) return 1;\n        for(int i=0; i<nums.length; i++){\n            while(nums[i]>0 && nums[i] <= nums.length && \n                  nums[i] != i+1 && nums[nums[i]-1] != nums[i])\n                swap(nums, nums[i]-1, i);\n        }\n        for(int i=0; i<nums.length; i++)\n            if(nums[i] != i+1) return i+1;\n        return nums.length+1;\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```"}, {"title": "O(n) time and O(n) space", "text": "We only need to mark numbers in [1, nums.length]. \n```java\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        if(nums.length == 0) return 1;\n        boolean[] mark = new boolean[nums.length];\n        for(int num: nums)\n            if(num>0 && num<=nums.length) mark[num-1] = true;\n        for(int i=0; i<mark.length; i++)\n            if(!mark[i]) return i+1;\n        return nums.length+1;\n    }\n}\n```"}]}, {"qid": 4, "title": "Median of Two Sorted Arrays", "link": "https://leetcode.com/problems/median-of-two-sorted-arrays/", "tags": ["Array", "Binary Search", "Divide and Conquer"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "binary search", "text": "To avoid boundary check, use \n```\nl1 = mid1 == 0 ? Integer.MIN_VALUE : nums1[mid1-1];\nr1 = mid1 == nums1.length ? Integer.MAX_VALUE : nums1[mid1];\nl2 = mid2 == 0 ? Integer.MIN_VALUE : nums2[mid2-1];\nr2 = mid2 == nums2.length ? Integer.MAX_VALUE : nums2[mid2];\n```\n.\n\n```java\nclass Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        // make sure nums1.length >= nums2.length\n        if(nums1.length < nums2.length) return findMedianSortedArrays(nums2, nums1);\n        int l = 0, r = nums1.length;\n        // mid: the index to divide the nums into two parts. range [0, nums.length], (nums.length+1) possible values in total\n        // l1: the value just before mid1 \n        // r1: the value just after mid1 \n        int mid1 = 0, mid2 = 0, l1=0, r1=0, l2=0,  r2=0;\n        while(l<r){\n            mid1 = l + ((r-l)>>1);\n            mid2 = (nums1.length+nums2.length+1)/2 - mid1;\n            if(mid2 > nums2.length) {\n                l = mid1+1;\n                continue;\n            }\n            else if(mid2 < 0){\n                r = mid1-1;\n                continue;\n            }\n            l1 = mid1 == 0 ? Integer.MIN_VALUE : nums1[mid1-1];\n            r1 = mid1 == nums1.length ? Integer.MAX_VALUE : nums1[mid1];\n            l2 = mid2 == 0 ? Integer.MIN_VALUE : nums2[mid2-1];\n            r2 = mid2 == nums2.length ? Integer.MAX_VALUE : nums2[mid2];\n            if(l1 <= r2 && l2<=r1) break;\n            if(l1 > r2) r = mid1 - 1;\n            if(l2 > r1) l = mid1 + 1;\n        }\n        mid1 = l + ((r-l)>>1);\n        mid2 = (nums1.length+nums2.length+1)/2 - mid1;\n        l1 = mid1 == 0 ? Integer.MIN_VALUE : nums1[mid1-1];\n        r1 = mid1 == nums1.length ? Integer.MAX_VALUE : nums1[mid1];\n        l2 = mid2 == 0 ? Integer.MIN_VALUE : nums2[mid2-1];\n        r2 = mid2 == nums2.length ? Integer.MAX_VALUE : nums2[mid2];\n        if((nums1.length+nums2.length)%2==1) return Math.max(l1, l2);\n        return (Math.max(l1, l2) + Math.min(r1, r2))/2.0;\n    }\n}\n```"}]}, {"qid": 461, "title": "Hamming Distance", "link": "https://leetcode.com/problems/hamming-distance/", "tags": ["Bit Manipulation"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Java Built-in Function", "text": "```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        return Integer.bitCount(x ^ y);\n    }\n}\n```"}, {"title": "bit counting by groups", "text": "1. `x = (x&0x55555555) + ((x>>>1)&0x55555555)` can also be written as `x = x - ((x >>> 1) & 0x55555555)`. \n2. The following solution can be further simplified to `i = (i + (i >>> 4)) & 0x0f0f0f0f; i = i + (i >>> 8); i = i + (i >>> 16); return i & 0x3f;`\n```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        x ^= y;\n        x = (x&0x55555555) + ((x>>>1)&0x55555555);\n        x = (x&0x33333333) + ((x>>>2)&0x33333333);\n        x = (x&0x0f0f0f0f) + ((x>>>4)&0x0f0f0f0f);\n        x = (x&0x00ff00ff) + ((x>>>8)&0x00ff00ff);\n        x = (x&0x0000ffff) + ((x>>>16)&0x0000ffff);\n        return x;\n    }\n}\n```"}]}, {"qid": 448, "title": "Find All Numbers Disappeared in an Array", "link": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/", "tags": ["Array"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "O(n) time and O(1) space", "text": "Given an element, we can calculate the expected index. \n```java\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        for(int i=0; i<nums.length; i++){\n            while(i != nums[i]-1){\n                if(nums[nums[i]-1] == nums[i]) break;\n                swap(nums, i, nums[i]-1);\n            }\n        }\n        for(int i=0; i<nums.length; i++)\n            if(i != nums[i]-1) \n                result.add(i+1);\n        return result;\n    }\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```"}, {"title": "in-place marking, another O(n) time and O(1) space", "text": "```java\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        if(nums.length == 0) return result;\n        // mark the existing numbers: use the existing numbers as index and set it to its opposite number\n        for(int i=0; i<nums.length; i++){\n            int num = Math.abs(nums[i])-1;\n            if(nums[num] > 0) nums[num] = -nums[num];\n        }\n        // iterate through nums array and find all still-positive numbers\n        for(int i=0; i<nums.length; i++)\n            if(nums[i] > 0) result.add(i+1);\n        return result;\n    }\n}\n```"}]}, {"qid": 538, "title": "Convert BST to Greater Tree", "link": "https://leetcode.com/problems/convert-bst-to-greater-tree/", "tags": ["Tree"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "recursive", "text": "```java\nclass Solution {\n    int accu = 0;\n    public TreeNode convertBST(TreeNode root) {\n        if(root == null) return null;\n        convertBST(root.right);\n        accu += root.val;\n        root.val = accu;\n        convertBST(root.left);\n        return root;\n    }\n}\n```"}]}, {"qid": 543, "title": "Diameter of Binary Tree", "link": "https://leetcode.com/problems/diameter-of-binary-tree/", "tags": ["Tree"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "recursive", "text": "1. Found that the two ends of the longest path must be leaf nodes, unless one of the leaf nodes is root. \n2. Given two leaf nodes, the path between them contains their highest-level common parent. \n```java\nclass Solution {\n    int maxLen = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        if(root == null) return 0;\n        DFTraversal(root);\n        return maxLen-1;\n    }\n    private int DFTraversal(TreeNode root) {\n        if(root == null) return 0;\n        int leftLen = DFTraversal(root.left), rightLen = DFTraversal(root.right);\n        int len = 1 + leftLen + rightLen;\n        if(maxLen < len) maxLen = len;\n        return 1 + Math.max(leftLen, rightLen);\n    }\n}\n```"}]}, {"qid": 437, "title": "Path Sum III", "link": "https://leetcode.com/problems/path-sum-iii/", "tags": ["Tree"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "backtracking", "text": "```java\nclass Solution {\n    int result = 0;\n    public int pathSum(TreeNode root, int sum) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        map.put(0, 1);\n        backtrack(root, map, 0, sum);\n        return result;\n    }\n    private void backtrack(TreeNode root, HashMap<Integer, Integer> map, int curr, int sum){\n        if(root == null) return ;\n        curr += root.val;\n        result += map.getOrDefault(curr-sum, 0);\n        map.put(curr, map.getOrDefault(curr, 0)+1);\n        backtrack(root.left, map, curr, sum);\n        backtrack(root.right, map, curr, sum);\n        map.put(curr, map.get(curr)-1);\n    }\n}\n```"}]}, {"qid": 572, "title": "Subtree of Another Tree", "link": "https://leetcode.com/problems/subtree-of-another-tree/", "tags": ["Tree"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "recursive", "text": "ATTENTION: `isSubtree` and `isEqual` are different DFS process. Do not try to integrate into a single function.\n```java\nclass Solution {\n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        if(s == null) return false;\n        if(isEqual(s, t)) return true;\n        return isSubtree(s.left, t) || isSubtree(s.right, t);\n    }\n    private boolean isEqual(TreeNode a, TreeNode b){\n        if(a == null || b==null){\n            if(a==null && b==null) return true;\n            return false;\n        }\n        if(a.val != b.val) return false;\n        return isEqual(a.left, b.left) && isEqual(a.right, b.right);\n    }\n}\n```"}]}, {"qid": 96, "title": "Unique Binary Search Trees", "link": "https://leetcode.com/problems/unique-binary-search-trees/", "tags": ["Dynamic Programming", "Tree"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP, double 100%", "text": "An additional node n only has two directions available for connection:\n```\n(subtree a)\n        \\\n         (node n)\n        /\n(subtree b)\n```\nSubtree a and b together contains all the nodes from 1 to n-1, and all the nodes in subtree a must be smaller than any node of subtree b. \nFor each possible combination of subtree a and b, the additional node n brings about `f(#nodes of a) * f(#nodes of b)` additional unique BSTs. \nTherefore, the DP formula is `f(n) = sum([f(i) * f(n-1-i) for i in range(0, n)])`\n\n```java\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<=i; j++) {\n                dp[i+1] += dp[j] * dp[i-j];\n            }\n        }\n        return dp[n];\n    }\n}\n```"}]}, {"qid": 438, "title": "Find All Anagrams in a String", "link": "https://leetcode.com/problems/find-all-anagrams-in-a-string/", "tags": ["Hash Table"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "sliding window", "text": "```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        if(s.length() < p.length()) return result;\n        int[] pattern = getPattern(p, 0, p.length());\n        int[] stat = getPattern(s, 0, p.length()-1);\n        int i=0;\n        while(true){\n            if(i + p.length() - 1 == s.length()) break;\n            stat[s.charAt(i + p.length()-1)-'a']++;\n            if(isSame(stat, pattern)) result.add(i);\n            stat[s.charAt(i)-'a']--;\n            i++;\n        }\n        return result;\n    }\n    private int[] getPattern(String s, int start, int end){\n        int[] pattern = new int[26];\n        for(int i=start; i<end; i++)\n            pattern[s.charAt(i)-'a']++;\n        return pattern;\n    }\n    private boolean isSame(int[] a, int[] b){\n        for(int i=0; i<26; i++)\n            if(a[i] != b[i]) return false;\n        return true;\n    }\n}\n```"}]}, {"qid": 20, "title": "Valid Parentheses", "link": "https://leetcode.com/problems/valid-parentheses/", "tags": ["String", "Stack"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "stack", "text": "```java\nclass Solution {\n    public boolean isValid(String s) {\n        if(s.length() == 0) return true;\n        Stack<Character> st = new Stack<>();\n        for(int i=0; i<s.length(); i++){\n            if(s.charAt(i) == '(') st.add(')');\n            else if(s.charAt(i) == '[') st.add(']');\n            else if(s.charAt(i) == '{') st.add('}');\n            else {\n                if(st.isEmpty() || (char)(st.pop()) != s.charAt(i)) return false;\n            }\n        }\n        return st.size() == 0;\n    }\n}\n```"}]}, {"qid": 581, "title": "Shortest Unsorted Continuous Subarray", "link": "https://leetcode.com/problems/shortest-unsorted-continuous-subarray/", "tags": ["Array"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "my solution, sort and compare, O(nlogn) time and O(n) space, suboptimal", "text": "```java\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] copy = Arrays.copyOfRange(nums, 0, nums.length);\n        Arrays.sort(copy);\n        int i=0, j=nums.length-1;\n        while(i<j && nums[i] == copy[i]) i++;\n        while(i<j && nums[j] == copy[j]) j--;\n        if(i == j) return 0;\n        return j-i+1;\n    }\n}\n```"}, {"title": "my solution, binary search", "text": "```java\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        if(nums.length == 0) return 0;\n        int i=0, j=nums.length-1;\n        // skip the ordered subarray started from head. \n        while(i<j && nums[i] <= nums[i+1]) i++;\n        // go left to ensure all duplicates of nums[i] has an index >= i. \n        if(i == j) return 0;\n        else while(i>0 && nums[i-1] == nums[i]) i--;\n        // skip the ordered subarray ended with tail. \n        while(i<j && nums[j-1] <= nums[j]) j--;\n        // go right to ensure all duplicates of nums[j] has an index <= j. \n        if(i == j) return 0;\n        else while(j<nums.length-1 && nums[j+1] == nums[j]) j++;\n        // get the minVal and maxVal of subarray between i and j\n        int minVal = nums[i], maxVal = nums[j];\n        for(int k=i; k<=j; k++){\n            if(minVal > nums[k]) minVal = nums[k];\n            if(maxVal < nums[k]) maxVal = nums[k];\n        }\n        // find idx s.t. all elements in nums[0:idx] are < minVal\n        // notice we set target of binary search to minVal+1 instead of minVal\n        int minIdx = Arrays.binarySearch(nums, 0, i, minVal+1);\n        if(minIdx < 0) minIdx = -(minIdx+1);\n        // find idx s.t. all elements in nums[idx:] are >= maxVal\n        int maxIdx = Arrays.binarySearch(nums, j+1, nums.length, maxVal);\n        if(maxIdx < 0) maxIdx = -(maxIdx+1);\n        return maxIdx - minIdx;\n    }\n}\n```"}, {"title": "GENIUS!!", "text": "```java\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        if(nums.length == 0) return 0;\n        int start=-1, end=-2, currMax = nums[0], currMin = nums[nums.length-1];\n        for(int i=0; i<nums.length; i++){\n            currMax = Math.max(currMax, nums[i]);\n            if(currMax > nums[i]) end = i;\n            currMin = Math.min(currMin, nums[nums.length-i-1]);\n            if(currMin < nums[nums.length-i-1]) start = nums.length-i-1;\n        }\n        return end-start+1;\n    }\n}\n```"}]}, {"qid": 129, "title": "Sum Root to Leaf Numbers", "link": "https://leetcode.com/problems/sum-root-to-leaf-numbers/", "tags": ["Tree", "DFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    int result = 0;\n    public int sumNumbers(TreeNode root) {\n        if(root == null) return 0;\n        DFS(root, 0);\n        return result;\n    }\n    public void DFS(TreeNode root, int curr){\n        curr *= 10;\n        curr += root.val;\n        if(root.left == null && root.right == null){\n            result += curr;\n            return ;\n        }\n        if(root.left != null) DFS(root.left, curr);\n        if(root.right != null) DFS(root.right, curr);\n    }\n}\n```"}]}, {"qid": 292, "title": "Nim Game", "link": "https://leetcode.com/problems/nim-game/", "tags": ["Brainteaser", "Minimax"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Math solution", "text": "1. n might be very big. Thus, DP solutions doesn't work (for the reason that O(n) time is too slow). \n2. try to write down several answers for small n:  \n`  n = 1 2 3 4 5 6 7 8 9 ...`  \n`ans = t t t f t t t f t ...`  \nWe can see that the answers repeated in a `t t t f` pattern. Actually, the DP formula is  \n`dp[i] = !dp[i-1] || !dp[i-2] || !dp[i-3]`. \n\n```java\nclass Solution {\n    public boolean canWinNim(int n) {\n        return n%4!=0;\n    }\n}\n```"}]}, {"qid": 258, "title": "Add Digits", "link": "https://leetcode.com/problems/add-digits/", "tags": ["Math"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Math Solution", "text": "For num > 0, the possible answer is 1,2,3,4,5,6,7,8,9. These answers occur periodically as num increases. \n\n**For this kinds of questions, if you don't have any idea at first glance, try to write several answers for simple input cases to see if you can find something useful.** \n\n```java\nclass Solution {\n    public int addDigits(int num) {\n        if(num == 0) return 0;\n        return num%9 == 0 ? 9 : num%9;\n    }\n}\n```"}]}, {"qid": 171, "title": "Excel Sheet Column Number", "link": "https://leetcode.com/problems/excel-sheet-column-number/", "tags": ["Math"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "O(n) time", "text": "```java\nclass Solution {\n    public int titleToNumber(String s) {\n        int result = 0;\n        for(char c : s.toCharArray()){\n            result *= 26;\n            result += c - 'A' + 1;\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 108, "title": "Convert Sorted Array to Binary Search Tree", "link": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/", "tags": ["Tree", "DFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return sortedArrayToBST(nums, 0, nums.length-1);\n    }\n    public TreeNode sortedArrayToBST(int[] nums, int l, int r) {\n        if(l > r) return null;\n        int mid = l + ((r-l)>>1);\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = sortedArrayToBST(nums, l, mid-1);\n        root.right = sortedArrayToBST(nums, mid+1, r);\n        return root;\n    }\n}\n```"}]}, {"qid": 107, "title": "Binary Tree Level Order Traversal II", "link": "https://leetcode.com/problems/binary-tree-level-order-traversal-ii/", "tags": ["Tree", "BFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "BFS + level-count", "text": "```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        Queue<TreeNode> qu = new LinkedList<>();\n        qu.add(root);\n        int count = 1;\n        List<Integer> layer = new ArrayList<>();\n        while(!qu.isEmpty()){\n            TreeNode node = qu.poll();\n            count--;\n            if(node.left != null) qu.add(node.left);\n            if(node.right != null) qu.add(node.right);\n            layer.add(node.val);\n            if(count == 0){\n                count = qu.size();\n                result.add(layer);\n                layer = new ArrayList<>();\n            }\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n```"}, {"title": "BFS", "text": "```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(root == null) return result;\n        DFS(result, root, 0);\n        Collections.reverse(result);\n        return result;\n    }\n    public void DFS(List<List<Integer>> result, TreeNode root, int level) {\n        if(result.size() < level+1) result.add(new ArrayList<>());\n        result.get(level).add(root.val);\n        if(root.left != null) DFS(result, root.left, level+1);\n        if(root.right != null) DFS(result, root.right, level+1);\n    }\n}\n```"}]}, {"qid": 257, "title": "Binary Tree Paths", "link": "https://leetcode.com/problems/binary-tree-paths/", "tags": ["Tree", "DFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        if(root == null) return result;\n        backtrack(result, root, \"\");\n        return result;\n    }\n    private void backtrack(List<String> result, TreeNode root, String curr){\n        curr += curr.length() == 0 ? root.val : \"->\"+root.val;\n        if(root.left == null && root.right == null){\n            result.add(curr);\n            return ;\n        }\n        if(root.left != null) backtrack(result, root.left, curr);\n        if(root.right != null) backtrack(result, root.right, curr);\n    }\n}\n```"}, {"title": "DFS + StringBuilder", "text": "```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        if(root == null) return result;\n        backtrack(result, root, new StringBuilder());\n        return result;\n    }\n    private void backtrack(List<String> result, TreeNode root, StringBuilder sb){\n        int start = sb.length();\n        sb.append(sb.length() == 0? root.val : \"->\" + root.val);\n        if(root.left == null && root.right == null){\n            result.add(sb.toString());\n        }\n        else {\n            if(root.left != null) backtrack(result, root.left, sb);\n            if(root.right != null) backtrack(result, root.right, sb);\n        }\n        sb.delete(start, sb.length());\n    }\n}\n```"}]}, {"qid": 118, "title": "Pascal's Triangle", "link": "https://leetcode.com/problems/pascals-triangle/", "tags": ["Array"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "iterative adding row by row, beats 100% 100%!", "text": "```java\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> result = new ArrayList<>();\n        if(numRows == 0) return result;\n        List<Integer> layer = new ArrayList<>();\n        layer.add(1);\n        result.add(layer);\n        for(int level = 2; level <= numRows; level++){\n            List<Integer> newLayer = new ArrayList<>();\n            newLayer.add(1);\n            for(int i=0; i<layer.size()-1; i++)\n                newLayer.add(layer.get(i) + layer.get(i+1));\n            newLayer.add(1);\n            result.add(newLayer);\n            layer = newLayer;\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 27, "title": "Remove Element", "link": "https://leetcode.com/problems/remove-element/", "tags": ["Array", "Two Pointers"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "remove and swap with the last element, beats 100% in time", "text": "```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        if(nums.length == 0) return 0;\n        int i=0, j = nums.length-1;\n        while(i<=j){\n            if(nums[i] != val) i++;\n            else swap(nums, i, j--);\n        }\n        return j+1;\n    }\n    private void swap(int[] nums, int i, int j){\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```"}, {"title": "similar to [283. Move Zeroes](#283. Move Zeroes), keeps nums in order", "text": "```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int p = 0;\n        for(int i=0; i<nums.length; i++)\n            if(nums[i] != val) nums[p++] = nums[i];\n        return p;\n    }\n}\n```"}]}, {"qid": 119, "title": "Pascal's Triangle II", "link": "https://leetcode.com/problems/pascals-triangle-ii/", "tags": ["Array"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "ArrayList insert", "text": "```java\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> result = new ArrayList<>();\n        result.add(1);\n        for(int i=1; i<=rowIndex; i++){\n            result.add(0, 0);\n            for(int j=0; j<result.size()-1; j++)\n                result.set(j, result.get(j) + result.get(j+1));\n        }\n        return result;\n    }\n}\n```"}, {"title": "Faster solution", "text": "Avoid inserting elements into the head during iteration. \n```java\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        Integer[] result = new Integer[rowIndex+1];\n        result[rowIndex] = 1;\n        for(int i=rowIndex-1; i>=0; i--){\n            for(int j=i; j<rowIndex; j++)\n                result[j] = result[j] == null? result[j+1] : result[j] + result[j+1];\n        }\n        return Arrays.asList(result);\n    }\n}\n```"}]}, {"qid": 232, "title": "Implement Queue using Stacks", "link": "https://leetcode.com/problems/implement-queue-using-stacks/", "tags": ["Stack", "Design"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "two stacks", "text": "```java\nimport java.util.EmptyStackException;\nclass MyQueue {\n    Stack<Integer> st1, st2;\n    public MyQueue() {\n        st1 = new Stack<>();\n        st2 = new Stack<>();\n    }    \n    public void push(int x) {\n        st1.add(x);\n    }\n    public int pop() {\n        if(st2.isEmpty()){\n            if(st1.isEmpty()) throw new EmptyStackException();\n            while(!st1.isEmpty()) st2.add(st1.pop());\n        }\n        return st2.pop();\n    }\n    public int peek() {\n        if(st2.isEmpty()){\n            if(st1.isEmpty()) throw new EmptyStackException();\n            while(!st1.isEmpty()) st2.add(st1.pop());\n        }\n        return st2.peek();\n    }\n    public boolean empty() {\n        return st1.isEmpty() && st2.isEmpty();\n    }\n}\n ```"}]}, {"qid": 191, "title": "Number of 1 Bits", "link": "https://leetcode.com/problems/number-of-1-bits/", "tags": ["Bit Manipulation"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "bit manipulation, beats 100% time and 100% space", "text": "```java\npublic class Solution {\n    public int hammingWeight(int n) {\n        n = (n&0x55555555) + ((n&0xAAAAAAAA)>>>1);\n        n = (n&0x33333333) + ((n&0xCCCCCCCC)>>>2);\n        n = (n&0x0F0F0F0F) + ((n&0xF0F0F0F0)>>>4);\n        n = (n&0x00FF00FF) + ((n&0xFF00FF00)>>>8);\n        n = (n&0x0000FFFF) + ((n&0xFFFF0000)>>>16);\n        return n;\n    }\n}\n```"}]}, {"qid": 83, "title": "Remove Duplicates from Sorted List", "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/", "tags": ["Linked List"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "O(n) time", "text": "```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head == null) return null;\n        ListNode curr = head;\n        while(curr.next != null){\n            if(curr.next.val == curr.val) curr.next = curr.next.next;\n            else curr = curr.next;\n        }\n        return head;\n    }\n}\n```"}]}, {"qid": 231, "title": "Power of Two", "link": "https://leetcode.com/problems/power-of-two/", "tags": ["Math", "Bit Manipulation"], "difficulty": 1, "comment": "- References: https://leetcode.com/problems/power-of-two/discuss/63966/4-different-ways-to-solve-Iterative-Recursive-Bit-operation-Math", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "math", "text": "Refer to [Power of Three](#326-power-of-three)\n```java\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        return (n > 0) && (1073741824%n == 0);\n    }\n}\n```"}, {"title": "bit manipulation", "text": "```java\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        return (n>0) && (n&(n-1)) == 0;\n    }\n}\n```"}]}, {"qid": 35, "title": "Search Insert Position", "link": "https://leetcode.com/problems/search-insert-position/", "tags": ["Array", "Binary Search"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "lower bound binary search insertion", "text": "```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0, r = nums.length;\n        while(l<r){\n            int mid = l + ((r-l)>>1);\n            if(nums[mid] == target) return mid;\n            else if(nums[mid] < target) l = mid+1;\n            else r = mid;\n        }\n        return l;\n    }\n}\n```"}]}, {"qid": 110, "title": "Balanced Binary Tree", "link": "https://leetcode.com/problems/balanced-binary-tree/", "tags": ["Tree", "DFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    boolean result = true;\n    public boolean isBalanced(TreeNode root) {\n        DFS(root);\n        return result;\n    }\n    private int DFS(TreeNode root){\n        if(root == null) return 0;\n        int left = DFS(root.left), right = DFS(root.right);\n        if(Math.abs(left-right) > 1) result = false;\n        return 1 + Math.max(left, right);\n    }\n}\n```"}, {"title": "another DFS (without environmental variable)", "text": "```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return DFS(root) != -1;\n    }\n    private int DFS(TreeNode root){\n        if(root == null) return 0;\n        int left = DFS(root.left);\n        if(left == -1) return -1;\n        int right = DFS(root.right);\n        if(right == -1) return -1;\n        if(Math.abs(left-right) > 1) return -1;\n        return 1 + Math.max(left, right);\n    }\n}\n```"}]}, {"qid": 263, "title": "Ugly Number", "link": "https://leetcode.com/problems/ugly-number/", "tags": ["Math"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "divide", "text": "```java\nclass Solution {\n    public boolean isUgly(int num) {\n        if(num == 0) return false;\n        while(num != 0 && num % 2 == 0) num /= 2;\n        while(num != 0 && num % 3 == 0) num /= 3;\n        while(num != 0 && num % 5 == 0) num /= 5;\n        return num == 1 || num == 0;\n    }\n}\n```"}]}, {"qid": 26, "title": "Remove Duplicates from Sorted Array", "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/", "tags": ["Array", "Two Pointers"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "two pointers", "text": "```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int i=0;\n        for(int num: nums){\n            if(i>0 && nums[i-1] == num) continue;\n            nums[i++] = num;\n        }\n        return i;\n    }\n}\n```"}]}, {"qid": 38, "title": "Count and Say", "link": "https://leetcode.com/problems/count-and-say/", "tags": ["String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "iterative", "text": "```java\nclass Solution {\n    public String countAndSay(int n) {\n        String s = \"1\";\n        if(n == 1) return s;\n        for(int i=2; i<=n; i++)\n            s = getNextString(s);\n        return s;\n    }\n    private String getNextString(String s){\n        StringBuilder sb = new StringBuilder();\n        int i=0, j=0;\n        for(; j<s.length(); j++){\n            if(j == i || s.charAt(i) == s.charAt(j)) continue;\n            sb.append(j-i);\n            sb.append(s.charAt(i));\n            i = j;\n        }\n        sb.append(j-i);\n        sb.append(s.charAt(i));\n        return sb.toString();\n    }\n}\n```"}]}, {"qid": 225, "title": "Implement Stack using Queues", "link": "https://leetcode.com/problems/implement-stack-using-queues/", "tags": ["Stack", "Design"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "one queue", "text": "```java\nclass MyStack {\n    Queue<Integer> qu;\n    public MyStack() {\n        qu = new LinkedList<>();\n    }\n    public void push(int x) {\n        qu.add(x);\n    }\n    public int pop() {\n        Queue<Integer> temp = new LinkedList<>();\n        while(qu.size() > 1) temp.add(qu.poll());\n        int result = qu.poll();\n        qu = temp;\n        return result;\n    }\n    public int top() {\n        int temp = pop();\n        qu.add(temp);\n        return temp;\n    }\n    public boolean empty() {\n        return qu.isEmpty();\n    }\n}\n```"}, {"title": "another one queue solution", "text": "```java\nclass MyStack {\n    Queue<Integer> qu;\n    public MyStack() {\n        qu = new LinkedList<>();\n    }\n    public void push(int x) {\n        qu.add(x);\n        for(int i=0; i<qu.size()-1; i++)\n            qu.add(qu.poll());\n    }\n    public int pop() {\n        return qu.poll();\n    }\n    public int top() {\n        return qu.peek();\n    }\n    public boolean empty() {\n        return qu.isEmpty();\n    }\n}\n```"}]}, {"qid": 67, "title": "Add Binary", "link": "https://leetcode.com/problems/add-binary/", "tags": ["Math", "String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "StringBuilder", "text": "```java\nclass Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder sb = new StringBuilder();\n        int i = a.length()-1, j = b.length()-1, carry = 0;\n        while(i>=0 || j>=0){\n            if(i>=0) carry += a.charAt(i--)-'0';\n            if(j>=0) carry += b.charAt(j--)-'0';\n            sb.insert(0, carry&1);\n            carry >>= 1;\n        }\n        while(carry > 0) {\n            sb.insert(0, carry&1);\n            carry >>= 1;\n        }\n        return sb.toString();\n    }\n}\n```"}]}, {"qid": 112, "title": "Path Sum", "link": "https://leetcode.com/problems/path-sum/", "tags": ["Tree", "DFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null) return false;\n        if(root.left == null && root.right == null && root.val == sum) return true;\n        sum -= root.val;\n        return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n    }\n}\n```"}]}, {"qid": 205, "title": "Isomorphic Strings", "link": "https://leetcode.com/problems/isomorphic-strings/", "tags": ["Hash Table"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashMap, only beats 36.92% in time", "text": "```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        HashMap<Character, Character> map1 = new HashMap<>(), map2 = new HashMap<>();\n        for(int i=0; i<s.length(); i++){\n            char c1 = s.charAt(i), c2 = t.charAt(i);\n            if(map1.containsKey(c1) && map2.containsKey(c2)){\n                if(map1.get(c1) != c2 || map2.get(c2) != c1) return false;\n                continue;\n            }\n            if(map1.containsKey(c1) || map2.containsKey(c2)) return false;\n            map1.put(c1, c2);\n            map2.put(c2, c1);\n        }\n        return true;\n    }\n}\n\n// Similar Idea Using HashMap + HashSet\n// class Solution {\n//     public boolean isIsomorphic(String s, String t) {\n//         HashMap<Character, Character> map = new HashMap<>();\n//         HashSet<Character> set = new HashSet<>();\n//         for(int i=0; i<s.length(); i++){\n//             char c1 = s.charAt(i), c2 = t.charAt(i);\n//             if(map.containsKey(c1)){\n//                 if(!set.contains(c2) || map.get(c1) != c2) return false;\n//                 continue;\n//             }\n//             if(set.contains(c2)) return false;\n//             map.put(c1, c2);\n//             set.add(c2);\n//         }\n//         return true;\n//     }\n// }\n```"}, {"title": "Great solution! beats 96.69% in time", "text": "```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        int[] m = new int[256], n = new int[256];\n        for(int i=0; i<s.length(); i++){\n            char c1 = s.charAt(i), c2 = t.charAt(i);\n            if(m[c1] != n[c2]) return false;\n            m[c1] = n[c2] = i+1;\n        }\n        return true;\n    }\n}\n```"}]}, {"qid": 203, "title": "Remove Linked List Elements", "link": "https://leetcode.com/problems/remove-linked-list-elements/", "tags": ["Linked List"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "partial recursive solution, beats 100% in time", "text": "```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if(head == null) return null;\n        if(head.val == val) return removeElements(head.next, val);\n        ListNode curr = head;\n        while(curr.next != null) {\n            ListNode next = curr.next;\n            if(next.val == val) curr.next = next.next;\n            else curr = curr.next;\n        }\n        return head;\n    }\n}\n```"}, {"title": "recursive solution, beats 99.94% in time", "text": "```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        if(head == null) return null;\n        head.next = removeElements(head.next, val);\n        return head.val == val ? head.next : head;\n    }\n}\n```"}, {"title": "iterative solution, beats 99.94% in time", "text": "```java\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode fakeHead = new ListNode(0);\n        fakeHead.next = head;\n        ListNode curr = fakeHead;\n        while(curr.next != null) {\n            ListNode next = curr.next;\n            if(next.val == val) curr.next = next.next;\n            else curr = curr.next;\n        }\n        return fakeHead.next;\n    }\n}\n```"}]}, {"qid": 88, "title": "Merge Sorted Array", "link": "https://leetcode.com/problems/merge-sorted-array/", "tags": ["Array", "Two Pointers"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "two pointers", "text": "```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i=m-1, j=n-1, k=m+n-1;\n        while(i>=0 && j>=0) {\n            if(nums2[j] > nums1[i]) nums1[k--] = nums2[j--];\n            else nums1[k--] = nums1[i--];\n        }\n        while(j >= 0) nums1[k--] = nums2[j--];\n    }\n}\n```"}]}, {"qid": 111, "title": "Minimum Depth of Binary Tree", "link": "https://leetcode.com/problems/minimum-depth-of-binary-tree/", "tags": ["Tree", "BFS", "DFS"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if(root == null) return 0;\n        if(root.left == null && root.right == null) return 1;\n        int result = Integer.MAX_VALUE;\n        if(root.left != null) result = minDepth(root.left);\n        if(root.right != null) result = Math.min(minDepth(root.right), result);\n        return result + 1;\n    }\n}\n```"}]}, {"qid": 219, "title": "Contains Duplicate II", "link": "https://leetcode.com/problems/contains-duplicate-ii/", "tags": ["Array", "Hash Table"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashSet", "text": "```java\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        HashSet<Integer> set = new HashSet<>();\n        for(int i=0; i<nums.length; i++) {\n            if(!set.add(nums[i])) return true;\n            if(set.size() > k) set.remove(nums[i-k]);\n        }\n        return false;\n    }\n}\n```"}]}, {"qid": 290, "title": "Word Pattern", "link": "https://leetcode.com/problems/word-pattern/", "tags": ["Hash Table"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashMap mapping", "text": "```java\nclass Solution {\n    public boolean wordPattern(String pattern, String str) {\n        String[] char2word = new String[26];\n        HashMap<String, Integer> word2char = new HashMap<>();\n        String[] words = str.split(\" \");\n        if(pattern.length() != words.length) return false;\n        for(int i=0; i<words.length; i++) {\n            if(char2word[pattern.charAt(i)-'a'] == null && \n               !word2char.containsKey(words[i])) {\n                char2word[pattern.charAt(i)-'a'] = words[i];\n                word2char.put(words[i], pattern.charAt(i)-'a');\n            }\n            else if(char2word[pattern.charAt(i)-'a'] == null || \n                    !word2char.containsKey(words[i])) \n                return false;\n            else if(!char2word[pattern.charAt(i)-'a'].equals(words[i]) ||\n                    word2char.get(words[i]) != pattern.charAt(i)-'a')\n                return false;\n        }\n        return true;\n    }\n}\n```"}]}, {"qid": 58, "title": "Length of Last Word", "link": "https://leetcode.com/problems/length-of-last-word/", "tags": ["String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "beats 100% in time", "text": "```java\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        int i = s.length() - 1;\n        while(i>=0 && s.charAt(i) == ' ') i--;\n        if(i<0) return 0;\n        int j = i-1;\n        while(j>=0 && s.charAt(j) != ' ') j--;\n        return i-j;\n    }\n}\n```"}, {"title": "String.split()", "text": "```java\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        String[] list = s.split(\" \");\n        for(int i=list.length-1; i>=0; i--) \n            if(list[i].length() != 0) return list[i].length();\n        return 0;\n    }\n}\n```"}]}, {"qid": 168, "title": "Excel Sheet Column Title", "link": "https://leetcode.com/problems/excel-sheet-column-title/", "tags": ["Math"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "shifted divide", "text": "```java\nclass Solution {\n    public String convertToTitle(int n) {\n        StringBuilder sb = new StringBuilder();\n        while(true) {\n            if(n == 0) break;\n            n--;\n            sb.insert(0, (char)(n%26 + 'A'));\n            n /= 26;\n        }\n        return sb.toString();\n    }\n}\n```"}, {"title": "recursive shifted divide", "text": "```java\nclass Solution {\n    public String convertToTitle(int n) {\n        return n == 0 ? \"\" : convertToTitle(--n/26) + (char)(n%26 + 'A');\n    }\n}\n```"}]}, {"qid": 204, "title": "Count Primes", "link": "https://leetcode.com/problems/count-primes/", "tags": ["Hash Table", "Math"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "O(n) time", "text": "```java\nclass Solution {\n    public int countPrimes(int n) {\n        if(n<2) return 0;\n        boolean[] arr = new boolean[n];\n        Arrays.fill(arr, true);\n        int result = 0;\n        for(int i=2; i<arr.length; i++) {\n            if(arr[i]){\n                result++;\n                for(int j=i*2; j<arr.length; j+=i) arr[j] = false;\n            }\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 7, "title": "Reverse Integer", "link": "https://leetcode.com/problems/reverse-integer/", "tags": ["Math"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "convert to long integer", "text": "```java\nclass Solution {\n    public int reverse(int x) {\n        long result = 0, num = (long)x;\n        int sign = x < 0 ? -1 : 1;\n        num *= sign;\n        while(num > 0) {\n            result *= 10;\n            result += num%10;\n            num /= 10;\n        }\n        result *= sign;\n        if(result < Integer.MIN_VALUE || result > Integer.MAX_VALUE)\n            return 0;\n        return (int)result;\n    }\n}\n```"}, {"title": "Great Solution! no Long, no sign, check overflow in each iteration", "text": "```java\nclass Solution {\n    public int reverse(int x) {\n        int result = 0;\n        while(x != 0) {\n            int newResult = result*10 + x%10;\n            if((newResult - x%10)/10 != result) return 0;\n            result = newResult;\n            x /= 10;\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 260, "title": "Single Number III", "link": "https://leetcode.com/problems/single-number-iii/", "tags": ["Bit Manipulation"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "XOR", "text": "To find n one-appearance elements based on XOR result, divide nums into n groupd s.t. each group only contains one one-appearance element. \n```java\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int res = 0;\n        for(int num: nums) res ^= num;\n        int diff = res&(-res);\n        int a = 0, b = 0;\n        for(int num: nums) {\n            if((num&diff) > 0) a ^= num;\n            else b ^= num;\n        }\n        int[] result = { a, b };\n        return result;\n    }\n}\n```"}]}, {"qid": 216, "title": "Combination Sum III", "link": "https://leetcode.com/problems/combination-sum-iii/", "tags": ["Array", "Backtracking"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "backtrack", "text": "Notice that the numbers from 1 to 9 cannot be selected twice\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        backtrack(new ArrayList<>(), 0, 1, k, n);\n        return result;\n    }\n    private void backtrack(List<Integer> list, int curr, int start, int k, int n) {\n        if(k == 0) {\n            if(curr == n) result.add(new ArrayList<>(list));\n            return ;\n        }\n        for(int i=start; i<=9; i++) {\n            if(curr + i > n) break;\n            list.add(i);\n            backtrack(list, curr+i, i+1, k-1, n);\n            list.remove(list.size()-1);\n        }\n    }\n}\n```"}]}, {"qid": 230, "title": "Kth Smallest Element in a BST", "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/", "tags": ["Binary Search", "Tree"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "recursive DFS", "text": "```java\nclass Solution {\n    TreeNode result = null;\n    int count;\n    public int kthSmallest(TreeNode root, int k) {\n        count = k;\n        inOrderTraversal(root);\n        return result.val;\n    }\n    public void inOrderTraversal(TreeNode root) {\n        if(root == null) return ;\n        inOrderTraversal(root.left);\n        count--;\n        if(count == 0) result = root;\n        else inOrderTraversal(root.right);\n    }\n}\n```"}, {"title": "non-recursive DFS", "text": "```java\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> st = new Stack<>();\n        while(root.left != null) {\n            st.add(root);\n            root = root.left;\n        }\n        while(true) {\n            k--;\n            if(k == 0) return root.val;\n            root = root.right;\n            while(root != null) {\n                st.add(root);\n                root = root.left;\n            }\n            root = st.pop();\n        }\n    }\n}\n```"}]}, {"qid": 12, "title": "Integer to Roman", "link": "https://leetcode.com/problems/integer-to-roman/", "tags": ["Math", "String"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "divide from high digit to low", "text": "```java\nclass Solution {\n    public String intToRoman(int num) {\n        HashMap<Integer, Character> map = new HashMap<>();\n        map.put(1, 'I');\n        map.put(5, 'V');\n        map.put(10, 'X');\n        map.put(50, 'L');\n        map.put(100, 'C');\n        map.put(500, 'D');\n        map.put(1000, 'M');\n        StringBuilder result = new StringBuilder();\n        int base = 1000;\n        while(num > 0) {\n            int div = num / base;\n            num %= base;\n            if(div == 0) {\n                base /= 10;\n                continue;\n            }\n            if(div == 4 || div == 9) {\n                result.append(map.get(base));\n                result.append(map.get((div+1)*base));\n                continue;\n            }\n            if(div >= 5) {\n                result.append(map.get(5*base));\n                div -= 5;\n            }\n            for(int i=0; i<div; i++) result.append(map.get(base));\n        }\n        return result.toString();\n    }\n}\n```"}, {"title": "map every digit into a string with direct concat", "text": "```java\nclass Solution {\n    public String intToRoman(int num) {\n        String[][] table = {\n            {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"},\n            {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"},\n            {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"},\n            {\"\", \"M\", \"MM\", \"MMM\"},\n        };\n        int count = 0;\n        StringBuilder sb = new StringBuilder();\n        while(num > 0) {\n            int digit = num % 10;\n            num /= 10;\n            sb.insert(0, table[count++][digit]);\n        }\n        return sb.toString();\n    }\n}\n```"}, {"title": "interview solution!! Simple and clear!! beats 100% and 100%!!", "text": "```java\nclass Solution {\n    public String intToRoman(int num) {\n        int[] values = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n        String[] strs = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n        StringBuilder result = new StringBuilder();\n        for(int i=0; i<values.length; i++) {\n            while(num >= values[i]) {\n                result.append(strs[i]);\n                num -= values[i];\n            }\n        }\n        return result.toString();\n    }\n}\n```"}]}, {"qid": 241, "title": "Different Ways to Add Parentheses", "link": "https://leetcode.com/problems/different-ways-to-add-parentheses/", "tags": ["Divide and Conquer"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "recursive divide and conquer, beats 80% in time", "text": "```java\nclass Solution {\n    public List<Integer> diffWaysToCompute(String input) {\n        return diffWaysToCompute(input, 0, input.length()-1);\n    }\n    public List<Integer> diffWaysToCompute(String input, int l, int r) {\n        List<Integer> result = new ArrayList<>();\n        if(l > r) return result;\n        for(int i=l; i<=r; i++) {\n            char c = input.charAt(i);\n            if(Character.isDigit(c)) continue;\n            List<Integer> leftList = diffWaysToCompute(input, l, i-1);\n            List<Integer> rightList = diffWaysToCompute(input, i+1, r);\n            for(int a : leftList)\n                for(int b : rightList)\n                    result.add(compute(a, b, c));\n        }\n        if(result.size() == 0)\n            result.add(Integer.parseInt(input.substring(l, r+1)));\n        return result;\n    }\n    private int compute(int a, int b, char op) {\n        if(op == '+') return a+b;\n        if(op == '-') return a-b;\n        return a*b;\n    }\n}\n```"}]}, {"qid": 173, "title": "Binary Search Tree Iterator", "link": "https://leetcode.com/problems/binary-search-tree-iterator/", "tags": ["Stack", "Tree", "Design"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "non-recursive DFS", "text": "```java\nclass BSTIterator {\n    Stack<TreeNode> st = new Stack<>();\n    public BSTIterator(TreeNode root) {\n        pushUntilLeftMost(root);\n    }\n    public int next() {\n        TreeNode temp = st.pop();\n        pushUntilLeftMost(temp.right);\n        return temp.val;\n    }\n    public boolean hasNext() {\n        return !st.isEmpty();\n    }\n    private void pushUntilLeftMost(TreeNode node) {\n        while(node != null) {\n            st.add(node);\n            node = node.left;\n        }\n    }\n}\n```"}]}, {"qid": 199, "title": "Binary Tree Right Side View", "link": "https://leetcode.com/problems/binary-tree-right-side-view/", "tags": ["Tree", "DFS", "BFS"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    List<Integer> result = new ArrayList<>();\n    public List<Integer> rightSideView(TreeNode root) {\n        DFS(root, 1);\n        return result;\n    }\n    private void DFS(TreeNode root, int h) {\n        if(root == null) return ;\n        if(h > result.size()) result.add(root.val);\n        DFS(root.right, h+1);\n        DFS(root.left, h+1);\n    }\n}\n```"}]}, {"qid": 77, "title": "Combinations", "link": "https://leetcode.com/problems/combinations/", "tags": ["Backtracking"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "backtrack, double 100%", "text": "```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combine(int n, int k) {\n        backtrack(new ArrayList<>(), 1, n, k);\n        return result;\n    }\n    private void backtrack(List<Integer> currList, int start, int n, int k) {\n        if(k == 0) {\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int i=start; i<=n-k+1; i++) {\n            currList.add(i);\n            backtrack(currList, i+1, n, k-1);\n            currList.remove(currList.size()-1);\n        }\n    }\n}\n```"}]}, {"qid": 64, "title": "Minimum Path Sum", "link": "https://leetcode.com/problems/minimum-path-sum/", "tags": ["Array", "Dynamic Programming"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DP", "text": "```java\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        if(grid.length == 0 || grid[0].length == 0) return 0;\n        int m = grid.length, n = grid[0].length;\n        int[] dp = grid[0];\n        for(int i=1; i<n; i++) dp[i] += dp[i-1];\n        for(int i=1; i<m; i++) {\n            dp[0] += grid[i][0];\n            for(int j=1; j<n; j++) \n                dp[j] = Math.min(dp[j-1], dp[j]) + grid[i][j];\n        }\n        return dp[dp.length-1];\n    }\n}\n```"}]}, {"qid": 59, "title": "Spiral Matrix II", "link": "https://leetcode.com/problems/spiral-matrix-ii/", "tags": ["Array"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "recursive onion, double 100%", "text": "```java\nclass Solution {\n    int[][] result;\n    int n;\n    public int[][] generateMatrix(int n) {\n        this.n = n;\n        result = new int[n][n];\n        onion(0, 1);\n        if(n%2 == 1) result[n/2][n/2] = n*n;\n        return result;\n    }\n    private void onion(int k, int start) {\n        if(2*k >= n) return ;\n        for(int j=k; j<n-k-1; j++) result[k][j] = start++;\n        for(int i=k; i<n-k-1; i++) result[i][n-k-1] = start++;\n        for(int j=n-k-1; j>k; j--) result[n-k-1][j] = start++;\n        for(int i=n-k-1; i>k; i--) result[i][k] = start++;\n        onion(k+1, start);\n    }\n}\n```"}]}, {"qid": 557, "title": "Reverse Words in a String III", "link": "https://leetcode.com/problems/reverse-words-in-a-string-iii/", "tags": ["String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "two pointers reverse word by word", "text": "```java\nclass Solution {\n    public String reverseWords(String s) {\n        int i=0;\n        StringBuilder sb = new StringBuilder(s);\n        while(i<sb.length()){\n            while(i<sb.length() && sb.charAt(i) == ' ') i++;\n            int j = i;\n            while(j<sb.length() && sb.charAt(j) != ' ') j++;\n            reverse(sb, i, j-1);\n            i = j+1;\n        }\n        return sb.toString();\n    }\n    private void reverse(StringBuilder sb, int i, int j){\n        while(i<j) swap(sb, i++, j--);\n    }\n    private void swap(StringBuilder sb, int i, int j){\n        char c = sb.charAt(i);\n        sb.setCharAt(i, sb.charAt(j));\n        sb.setCharAt(j, c);\n    }\n}\n```"}, {"title": "Built-in functions", "text": "```java\nclass Solution {\n    public String reverseWords(String s) {\n        String[] strs = s.split(\" \");\n        for(int i=0; i<strs.length; i++){\n            strs[i] = (new StringBuilder(strs[i])).reverse().toString();\n        }\n        return String.join(\" \", Arrays.asList(strs));\n    }\n}\n```"}]}, {"qid": 893, "title": "Groups of Special-Equivalent Strings", "link": "https://leetcode.com/problems/groups-of-special-equivalent-strings/", "tags": ["String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashArray", "text": "The key is to encode the string into something hashable and put it all into a HashSet.\n\nCount number of characters for odd and even indices separately.  \nOdd-indexed characters are counted in chars[:26], while even-indexed characters are counted in chars[26:]. \n```java\nclass Solution {\n    public int numSpecialEquivGroups(String[] A) {\n        HashSet<HashArray> set = new HashSet<>();\n        for(String s : A){\n            HashArray harr = new HashArray(s);\n            set.add(harr);\n        }\n        return set.size();\n    }\n}\nclass HashArray {\n    int[] chars = new int[52];\n    public HashArray(String s){\n        for(int i=0; i<s.length(); i+=2)\n            chars[s.charAt(i)-'a']++;\n        for(int i=1; i<s.length(); i+=2)\n            chars[s.charAt(i)-'a'+26]++;\n    }\n    public boolean equals(Object o){\n        for(int i=0; i<52; i++)\n            if(this.chars[i] != ((HashArray)o).chars[i]) return false;\n        return true;\n    }\n    public int hashCode(){\n        return Arrays.hashCode(chars);\n    }\n}\n```"}]}, {"qid": 824, "title": "Goat Latin", "link": "https://leetcode.com/problems/goat-latin/", "tags": ["String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "StringBuilder modify, no split", "text": "```java\nclass Solution {\n    HashSet<Character> set = new HashSet<>(\n        Arrays.asList(new Character[] {'a', 'e', 'i','o','u','A','E','I','O','U'}));\n    public String toGoatLatin(String s) {\n        StringBuilder sb = new StringBuilder(s);\n        int i = 0, count = 0;\n        while(true){\n            while(i<sb.length() && sb.charAt(i) == ' ') i++;\n            if(i == sb.length()) break;\n            int j = i;\n            while(j<sb.length() && sb.charAt(j) != ' ') j++;\n            count++;\n            \n            if(beginsWithVowels(sb, i, j)) {\n                sb.insert(j, \"ma\");\n                j += 2;\n            }\n            else{\n                char c = sb.charAt(i);\n                sb.delete(i, i+1);\n                sb.insert(j-1, c);\n                sb.insert(j, \"ma\");\n                j+=2;\n            }\n            for(int k=0; k<count; k++) sb.insert(j++, 'a');\n            \n            i = j;\n        }\n        return sb.toString();\n    }\n    private boolean beginsWithVowels(StringBuilder sb, int start, int end){\n        return set.contains(sb.charAt(start));\n    }\n}\n```"}]}, {"qid": 521, "title": "Longest Uncommon Subsequence I", "link": "https://leetcode.com/problems/longest-uncommon-subsequence-i/", "tags": ["String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "April Fool's Question", "text": "```java\nclass Solution {\n    public int findLUSlength(String a, String b) {\n        return a.equals(b) ? -1 : Math.max(a.length(), b.length());\n    }\n}\n```"}]}, {"qid": 917, "title": "Reverse Only Letters", "link": "https://leetcode.com/problems/reverse-only-letters/", "tags": ["String"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "skipping two pointers swap", "text": "```java\nclass Solution {\n    public String reverseOnlyLetters(String S) {\n        StringBuilder s = new StringBuilder(S);\n        int i = 0, j = s.length()-1;\n        while(true){\n            while(i<j && !Character.isLetter(s.charAt(i))) i++;\n            while(i<j && !Character.isLetter(s.charAt(j))) j--;\n            if(i >= j) break;\n            char c = s.charAt(i);\n            s.setCharAt(i, s.charAt(j));\n            s.setCharAt(j, c);\n            i++; j--;\n        }\n        return s.toString();\n    }\n}\n```"}]}, {"qid": 876, "title": "Middle of the Linked List", "link": "https://leetcode.com/problems/middle-of-the-linked-list/", "tags": ["Linked List"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "slow-fast", "text": "```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if(head == null) return null;\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```"}]}, {"qid": 78, "title": "Subsets", "link": "https://leetcode.com/problems/subsets/", "tags": ["Array", "Backtracking", "Bit Manipulation"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "General Approach", "text": "```java\nclass Solution {\n    List<List<Integer>> result;\n    public List<List<Integer>> subsets(int[] nums) {\n        result = new ArrayList<>();\n        backtrack(new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    \n    private void backtrack(List<Integer> currList, int[] nums, int start){\n        result.add(new ArrayList<>(currList));\n        for(int i=start; i<nums.length; i++){\n            currList.add(nums[i]);\n            backtrack(currList, nums, i+1);\n            currList.remove(currList.size()-1);\n        }\n    }\n}\n```"}, {"title": "My solution (Faster!)", "text": "```java\nclass Solution {\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> subsets(int[] nums) {\n        result = new ArrayList<>();\n        DFS(nums, 0, new ArrayList<Integer>());\n        return result;\n    }\n    private void DFS(int[] nums, int k, List<Integer> currList){\n        if(k==nums.length){\n            result.add(currList);\n            return ;\n        }\n        DFS(nums, k+1, new ArrayList<>(currList));\n        currList.add(nums[k]);\n        DFS(nums, k+1, currList);\n    }\n}\n```"}]}, {"qid": 90, "title": "Subsets II", "link": "https://leetcode.com/problems/subsets-ii/", "tags": ["Array", "Backtracking"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "General Approach", "text": "```java\nclass Solution {\n    List<List<Integer>> result;\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        result = new ArrayList<>();\n        Arrays.sort(nums);\n        backtrack(new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    private void backtrack(List<Integer> currList, int[] nums, int start){\n        result.add(new ArrayList<>(currList));\n        for(int i=start; i<nums.length; i++){\n            if(i==start || nums[i-1] != nums[i]){\n                currList.add(nums[i]);\n                backtrack(currList, nums, i+1);\n                currList.remove(currList.size()-1);\n            }\n        }\n    }\n}\n```"}, {"title": "My Solution", "text": "```java\nclass Solution {\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        result = new ArrayList<>();\n        Arrays.sort(nums);\n        backtrack(new ArrayList<Integer>(), nums, 0);\n        return result;\n    }\n    \n    private void backtrack(List<Integer> currList, int[] nums, int start){\n        if(start==nums.length) {\n            result.add(currList);\n            return ;\n        }\n        int end = start;\n        while(end<nums.length && nums[end] == nums[start])\n            end++;\n        for(int i = start+1; i<=end; i++){\n            List<Integer> temp = new ArrayList<>(currList);\n            for(int j=start; j<i; j++)\n                temp.add(nums[j]);\n            backtrack(temp, nums, end);\n        }\n        backtrack(currList, nums, end);\n    }\n}\n```"}]}, {"qid": 46, "title": "Permutations", "link": "https://leetcode.com/problems/permutations/", "tags": ["Backtracking"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "My Backtracking Solution (not general but faster)", "text": "<span id=\"46-DP\" />\nThis is a DP-like solution. \nFor each iteration, you only consider the additional permutations that the k-th element brings about. \n\n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> permute(int[] nums) {\n        if(nums.length == 0) return result;\n        result.add(new ArrayList<>());\n        for(int i=0; i<nums.length; i++)\n            backtrack(nums, i);\n        return result;\n    }\n    private void backtrack(int[] nums, int start) {\n        if(start == nums.length) return ;\n        int len = result.size(), num = nums[start];\n        for(int i=0; i<len; i++) {\n            List<Integer> row = result.get(i);\n            for(int j=0; j<row.size(); j++) {\n                List<Integer> newRow = new ArrayList<>(row);\n                newRow.add(j, num);\n                result.add(newRow);\n            }\n            row.add(num);\n        }\n    }\n}\n```"}, {"title": "Marking along the backtracking paths (general solution)", "text": "```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> permute(int[] nums) {\n        backtrack(nums, new HashSet<>(), new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] nums, HashSet<Integer> mark, List<Integer> currList){\n        if(currList.size() == nums.length){\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int i=0; i<nums.length; i++)\n            if(!mark.contains(i)){\n                mark.add(i);\n                currList.add(nums[i]);\n                backtrack(nums, mark, currList);\n                currList.remove(currList.size()-1);\n                mark.remove(i);\n            }\n    }\n    \n}\n```"}]}, {"qid": 47, "title": "Permutations II", "link": "https://leetcode.com/problems/permutations-ii/", "tags": ["Backtracking"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Marking along the backtracking paths (general solution)", "text": "Notice that the DP-like solution in [46. Permutations](#46-DP) does not work here because of the presence of duplicates. \ne.g. If both `[1,3,3]` and `[3,1,3]` are in the result and you are going to insert a `1` in them, they can both get the same array `[1,3,1,3]`, which is not allowed. \n```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    HashSet<Integer> unique = new HashSet<>();\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int num: nums) {\n            unique.add(num);\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        backtrack(nums, map, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] nums, HashMap<Integer, Integer> map, List<Integer> currList){\n        if(currList.size() == nums.length) {\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int num : unique){\n            if(map.get(num)>0){\n                map.put(num, map.get(num)-1);\n                currList.add(num);\n                backtrack(nums, map, currList);\n                currList.remove(currList.size()-1);\n                map.put(num, map.get(num)+1);\n            }\n        }\n    }\n}\n```"}, {"title": "Marking again! (faster general solution)", "text": "```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        backtrack(nums, new boolean[nums.length], new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] nums, boolean[] used, List<Integer> currList){\n        if(currList.size() == nums.length){\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int i=0; i<nums.length; i++){\n            if(used[i] || i>0 && nums[i-1] == nums[i] && !used[i-1]) continue;\n            used[i] = true;\n            currList.add(nums[i]);\n            backtrack(nums, used, currList);\n            currList.remove(currList.size()-1);\n            used[i] = false;\n        }\n    }\n}\n```"}]}, {"qid": 22, "title": "Generate Parentheses", "link": "https://leetcode.com/problems/generate-parentheses/", "tags": ["String", "Backtracking"], "difficulty": 1, "comment": "[YouTube Video](https://www.youtube.com/watch?v=sz1qaKt0KGQ)", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "My Backtracking Solution", "text": "```java\nclass Solution {\n    List<String> result;\n    public List<String> generateParenthesis(int n) {\n        result = new ArrayList<>();\n        backtrack(new StringBuilder(), n, 0);\n        return result;\n    }\n    private void backtrack(StringBuilder sb, int left, int right){\n        if(left == 0 && right == 0){\n            result.add(sb.toString());\n            return ;\n        }\n        if(left>0){\n            sb.append('(');\n            backtrack(sb, left-1, right+1);\n            sb.delete(sb.length()-1, sb.length());\n        }\n        if(right>0){\n            sb.append(')');\n            backtrack(sb, left, right-1);\n            sb.delete(sb.length()-1, sb.length());\n        }\n    }\n}\n```"}]}, {"qid": 17, "title": "Letter Combinations of a Phone Number", "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/", "tags": ["String", "Backtracking"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "simple backtracking", "text": "```java\nclass Solution {\n    List<String> result = new ArrayList<>();\n    HashMap<Character, String> map = new HashMap<>();\n    public List<String> letterCombinations(String digits) {\n        if(digits == null || digits.length() == 0) return result;\n        map.put('2', \"abc\");\n        map.put('3', \"def\");\n        map.put('4', \"ghi\");\n        map.put('5', \"jkl\");\n        map.put('6', \"mno\");\n        map.put('7', \"pqrs\");\n        map.put('8', \"tuv\");\n        map.put('9', \"wxyz\");\n        backtrack(digits, 0, new StringBuilder());\n        return result;\n    }\n    private void backtrack(String digits, int start, StringBuilder currsb){\n        if(start == digits.length()){\n            result.add(currsb.toString());\n            return ;\n        }\n        for(char c: map.get(digits.charAt(start)).toCharArray()){\n            currsb.append(c);\n            backtrack(digits, start+1, currsb);\n            currsb.delete(currsb.length()-1, currsb.length());\n        }\n    }\n}\n```"}]}, {"qid": 200, "title": "Number of Islands", "link": "https://leetcode.com/problems/number-of-islands/", "tags": ["DFS", "BFS", "Union Find"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "DFS", "text": "```java\nclass Solution {\n    public int numIslands(char[][] grid) {\n        if(grid.length==0 || grid[0].length==0) return 0;\n        int result = 0;\n        for(int i=0; i<grid.length; i++)\n            for(int j=0; j<grid[0].length; j++){\n                if(grid[i][j] == '1'){\n                    DFS(grid, i, j);\n                    result++;\n                }\n            }\n        return result;\n    }\n    private void DFS(char[][] grid, int i, int j){\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j] != '1')\n            return;\n        grid[i][j] = 'x';\n        DFS(grid, i-1, j);\n        DFS(grid, i+1, j);\n        DFS(grid, i, j+1);\n        DFS(grid, i, j-1);\n    }\n}\n```"}]}, {"qid": 131, "title": "Palindrome Partitioning", "link": "https://leetcode.com/problems/palindrome-partitioning/", "tags": ["Backtracking"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "sub-optimal palindrome method", "text": "```java\nclass Solution {\n    List<List<String>> result = new ArrayList<>();\n    public List<List<String>> partition(String s) {\n        backtrack(s, 0, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(String s, int start, List<String> list){\n        if(start == s.length()){\n            result.add(list);\n            return ;\n        }\n        for(int i=start; i<s.length(); i++){\n            if(isPalindrome(s, start, i)){\n                List<String> newList = new ArrayList<>(list);\n                newList.add(s.substring(start, i+1));\n                backtrack(s, i+1, newList);\n            }\n        }\n    }\n    private boolean isPalindrome(String s, int i, int j){\n        while(i<j){\n            if(s.charAt(i++)!=s.charAt(j--))\n                return false;\n        }\n        return true;\n    }\n}\n```"}, {"title": "Manacher's Algorithm", "text": "The Manacher method is copied from [a CSDN blog](https://blog.csdn.net/u014771464/article/details/79120964)\n```java\nclass Solution {\n    List<List<String>> result = new ArrayList<>();\n    public List<List<String>> partition(String s) {\n        int[] p = ManacherArray(s);\n        backtrack(s, 0, p, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(String s, int start, int[] p, List<String> list){\n        if(start == s.length()){\n            result.add(list);\n            return ;\n        }\n        int idx = 2*(start+1);\n        for(int i=idx; i<p.length; i++){\n            int len = p[i]-1;\n            int left = i - len + 1;\n            int diff = start - (left/2 - 1);\n            if(diff >= 0){\n                List<String> newList = new ArrayList<>(list);\n                newList.add(s.substring(start, start+len-diff*2));\n                backtrack(s, start+len-diff*2, p, newList);\n            }\n        }\n    } \n    public int[] ManacherArray(String s) {\n        // Insert '#'\n        String t = \"$#\";\n        for (int i = 0; i < s.length(); ++i) {\n            t += s.charAt(i);\n            t += \"#\";\n        }\n        t += \"@\";\n        // Process t\n        int[] p = new int[t.length()];;\n        int mx = 0, id = 0, resLen = 0, resCenter = 0;\n        for (int i = 1; i < t.length()-1; ++i) {\n            p[i] = mx > i ? Math.min(p[2 * id - i], mx - i) : 1;\n            while (((i - p[i])>=0) && \n                   ((i + p[i])<t.length()-1) && \n                   (t.charAt(i + p[i]) == t.charAt(i - p[i])))\n                ++p[i];\n            if (mx < i + p[i]) {\n                mx = i + p[i];\n                id = i;\n            }\n            if (resLen < p[i]) {\n                resLen = p[i];\n                resCenter = i;\n            }\n        }\n        return p;\n    }\n}\n```"}]}, {"qid": 39, "title": "Combination Sum", "link": "https://leetcode.com/problems/combination-sum/", "tags": ["Array", "Backtracking"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "general backtracking solution", "text": "```java\nclass Solution {\n    int[] candidates;\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        this.candidates = candidates;\n        backtrack(new ArrayList<>(), 0, target);\n        return result;\n    }\n    private void backtrack(List<Integer> currList, int start, int target) {\n        if(target == 0) {\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        for(int i=start; i<candidates.length; i++) {\n            if(candidates[i] > target) return ;\n            currList.add(candidates[i]);\n            backtrack(currList, i, target-candidates[i]);\n            currList.remove(currList.size()-1);\n        }\n    }\n}\n```"}]}, {"qid": 40, "title": "Combination Sum II", "link": "https://leetcode.com/problems/combination-sum-ii/", "tags": ["Array", "Backtracking"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "general backtracking solution", "text": "```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        backtrack(candidates, 0, target, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] candidates, int start, int target, List<Integer> currList){\n        if(target == 0){\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        if(start == candidates.length || target < candidates[start]) return ;\n        int idx = start+1, num = candidates[start];\n        while(idx < candidates.length && candidates[idx] == num) idx++; // get the index of the next distinct candidate\n        // case 1: do not use `num`\n        backtrack(candidates, idx, target, currList);\n        // case 2: use `num`\n        for(int i=start; i<idx; i++){\n            currList.add(candidates[i]);\n            target -= num;\n            backtrack(candidates, idx, target, currList);\n        }\n        for(int i=0; i<idx-start; i++) currList.remove(currList.size()-1);\n    }\n}\n```"}, {"title": "genenral backtracking solution in a better way", "text": "```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        backtrack(candidates, 0, target, new ArrayList<>());\n        return result;\n    }\n    private void backtrack(int[] candidates, int start, int target, List<Integer> currList){\n        if(target == 0){\n            result.add(new ArrayList<>(currList));\n            return ;\n        }\n        if(start == candidates.length || target < candidates[start]) return ;\n        for(int i=start; i<candidates.length; i++){\n            if(i>start && candidates[i] == candidates[i-1]) continue;\n            currList.add(candidates[i]);\n            backtrack(candidates, i+1, target-candidates[i], currList);\n            currList.remove(currList.size()-1);\n        }\n    }\n}\n```"}]}, {"qid": 79, "title": "Word Search", "link": "https://leetcode.com/problems/word-search/", "tags": ["Array", "Backtracking"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "simple backtracking solution beats 99.56% in time and 75.11% in space", "text": "```java\nclass Solution {\n    char[][] board;\n    String word;\n    boolean[][] used;\n    public boolean exist(char[][] board, String word) {\n        if(word.length() == 0) return true;\n        if(board.length == 0 || board[0].length == 0) return false;\n        this.board = board;\n        this.word = word;\n        this.used = new boolean[board.length][board[0].length];\n        for(int i=0; i<board.length; i++)\n            for(int j=0; j<board[0].length; j++)\n                if(recurr(i, j, 0)) return true;\n        return false;\n    }\n    private boolean recurr(int i, int j, int start){\n        if(start == word.length()) return true;\n        if(i<0 || j<0 || i>=board.length || j>=board[0].length || used[i][j] || board[i][j] != word.charAt(start)) return false;\n        used[i][j] = true;\n        if(recurr(i+1, j, start+1) || recurr(i-1, j, start+1) || recurr(i, j+1, start+1) || recurr(i, j-1, start+1)) return true;\n        used[i][j] = false;\n        return false;\n    }\n}\n```"}]}, {"qid": 1, "title": "Two Sum", "link": "https://leetcode.com/problems/two-sum/", "tags": ["Array", "Hash Table"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashMap", "text": "```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int i=0; i<nums.length; i++){\n            if(map.containsKey(target-nums[i]))\n                return new int[] {map.get(target-nums[i]), i};\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```"}]}, {"qid": 454, "title": "4Sum II", "link": "https://leetcode.com/problems/4sum-ii/", "tags": ["Hash Table", "Binary Search"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashMap + two sum", "text": "```java\nclass Solution {\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n        int result = 0;\n        HashMap<Integer, Integer> map1 = twoSum(A, B);\n        HashMap<Integer, Integer> map2 = twoSum(C, D);\n        for(Map.Entry<Integer, Integer> e1: map1.entrySet()){\n            if(map2.containsKey(-e1.getKey())){\n                result += e1.getValue() * map2.get(-e1.getKey());\n            }\n        }\n        return result;\n    }\n    private HashMap<Integer, Integer> twoSum(int[] A, int[] B){\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int a: A)\n            for(int b: B)\n                map.put(a+b, map.getOrDefault(a+b, 0) + 1);\n        return map;\n    }\n}\n```"}]}, {"qid": 15, "title": "3Sum", "link": "https://leetcode.com/problems/3sum/", "tags": ["Array", "Two Pointers"], "difficulty": 2, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "HashSet, clear but slow", "text": "```java\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> threeSum(int[] nums) {\n        if(nums.length == 0) return result;\n        HashSet<Integer> set = new HashSet<>();\n        for(int num: nums) set.add(num);\n        Arrays.sort(nums);\n        for(int i=0; i<nums.length-2; i++){\n            if(i>0 && nums[i] == nums[i-1]) continue;\n            for(int j=i+1; j<nums.length-1; j++){\n                if(j>i+1 && nums[j] == nums[j-1]) continue;\n                if(set.contains(-(nums[i]+nums[j])) && -(nums[i]+nums[j]) >= nums[j+1])\n                    result.add(Arrays.asList((Integer)nums[i], (Integer)nums[j], (Integer)(-(nums[i]+nums[j]))));\n            }\n        }\n        return result;\n    }\n}\n```"}, {"title": "jumping iteration + Two Sum two pointers", "text": "```java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        Arrays.sort(nums);\n        for(int i=0; i<nums.length-2; i++){\n            if(i>0 && nums[i] == nums[i-1]) continue;\n            int j=i+1, k=nums.length-1;\n            while(j<k){\n                if(nums[i]+nums[j]+nums[k] == 0) {\n                    result.add(Arrays.asList((Integer)nums[i], (Integer)nums[j++], (Integer)nums[k--]));\n                    while(j<k && nums[j] == nums[j-1]) j++;\n                    while(j<k && nums[k] == nums[k+1]) k--;\n                }\n                else if(nums[i]+nums[j]+nums[k]>0) k--;\n                else j++;\n            }\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 881, "title": "Boats to Save People", "link": "https://leetcode.com/problems/boats-to-save-people/", "tags": ["Two Pointers", "Greedy"], "difficulty": 1, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "two pointers", "text": "```java\nclass Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int i=0, j=people.length-1;\n        int result = 0;\n        while(i<=j){\n            if(i==j){\n                result++;\n                break;\n            }\n            if(people[i]+people[j] > limit){\n                j--;\n            }\n            else{\n                i++;\n                j--;\n            }\n            result++;\n        }\n        return result;\n    }\n}\n```"}]}, {"qid": 880, "title": "Decoded String at Index", "link": "https://leetcode.com/problems/decoded-string-at-index/", "tags": ["Stack"], "difficulty": 3, "comment": "", "reviews": ["2019-02-01T15:33:17.821Z"], "solutions": [{"title": "Iterative", "text": "```java\nclass Solution {\n    public String decodeAtIndex(String S, int K) {\n        List<Tuple> list = getTuples(S);\n        int pos = -1;\n        for(int i=0; i<list.size(); i++)\n            if(list.get(i).accu >= K) pos = i;\n        int curr = K-1;\n        while(pos>0){\n            curr %= list.get(pos).curr;\n            if(curr >= list.get(pos-1).accu) {\n                curr -= list.get(pos-1).accu;\n                return Character.toString(list.get(pos).str.charAt(curr));\n            }\n            pos--;\n        }\n        curr %= list.get(0).curr;\n        return Character.toString(list.get(0).str.charAt(curr));\n    }\n    private List<Tuple> getTuples(String S){\n        S = S + \"1\";\n        List<Tuple> result = new ArrayList<>();\n        int lastIdx = 0;\n        for(int i=0; i<S.length(); i++){\n            char c = S.charAt(i);\n            if(!Character.isLetter(c)){\n                if(lastIdx == i){\n                    result.get(result.size()-1).repeat *= c-'0';\n                    lastIdx = i+1;\n                }\n                else {\n                    Tuple tup = new Tuple(S.substring(lastIdx, i), c-'0', i-lastIdx);\n                    result.add(tup);\n                    lastIdx = i+1;\n                }\n            }\n        }\n        result.get(0).accu = result.get(0).curr * result.get(0).repeat;\n        for(int i=1; i<result.size(); i++){\n            result.get(i).curr = (result.get(i-1).accu + result.get(i).curr);\n            result.get(i).accu = result.get(i).curr * result.get(i).repeat;\n        }\n        return result;\n    }\n}\nclass Tuple{\n    String str;\n    int repeat;\n    long accu; // accumulative length after repeat\n    long curr; // accumulative length before repeat\n    public Tuple(String s, int r, long a){\n        str = s;\n        repeat = r;\n        curr = a;\n    }\n}\n```"}, {"title": "recursive", "text": "Attention: strLen might OVERFLOW!!!!!!! Thus, we must use long. \n```java\nclass Solution {\n    public String decodeAtIndex(String S, int K) {\n        long strLen = 0;\n        for(int i=0; i<S.length(); i++){\n            char c = S.charAt(i);\n            if(Character.isLetter(c)){\n                if(++strLen == K) return Character.toString(c);\n            }\n            else {\n                int repeat = c-'0';\n                if(strLen * repeat >= K) \n                    return decodeAtIndex(S.substring(0, i), (int)((K-1)%strLen+1));\n                strLen *= repeat;\n            }\n        }\n        return null;\n    }\n}\n```"}]}]}